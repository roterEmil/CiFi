<!DOCTYPE html>
<html >
<head><link rel="icon" href="favicon-checkerframework.png" type="image/png"/>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="generator" content="hevea 2.23">
<style type="text/css">
img { max-width: 100%; max-height: 100%; }
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.footnotetext{margin:0ex; padding:0ex;}
div.footnotetext P{margin:0px; text-indent:1em;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.titlemain{margin:1ex 2ex 2ex 1ex;}
.titlerest{margin:0ex 2ex;}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
div table{margin-left:inherit;margin-right:inherit;margin-bottom:2px;margin-top:2px}
td table{margin:auto;}
table{border-collapse:collapse;}
td{padding:0;}
.cellpadding0 tr td{padding:0;}
.cellpadding1 tr td{padding:1px;}
pre{text-align:left;margin-left:0ex;margin-right:auto;}
blockquote{margin-left:4ex;margin-right:4ex;text-align:left;}
td p{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
.lstlisting{font-family:monospace;white-space:pre;margin-right:auto;margin-left:0pt;text-align:left}
.lstframe{margin:auto;margin-bottom:2em}
</style>
<title>The Checker Framework Manual:  
Custom pluggable types for Java
</title>
</head>
<body >
<!--HEVEA command line is: hevea -fix -exec xxdate.exe manual.tex -->
<!--CUT STYLE book--><!--CUT DEF chapter 1 --><div class="center">
<img src="CFLogo.png">
</div><table class="title"><tr><td style="padding:1ex"><h1 class="titlemain">The Checker Framework Manual: <br>
Custom pluggable types for Java</h1><h3 class="titlerest"><a href="http://checkerframework.org/"><span style="font-family:monospace">http://checkerframework.org/</span></a></h3><h3 class="titlerest">Version 2.0.0 (2 May 2016)</h3></td></tr>
</table><p><span style="font-weight:bold">For the impatient:</span>
Section&#XA0;<a href="#installation">1.3</a>
describes how to <span style="font-weight:bold">install and use</span> pluggable type-checkers.</p><!--TOC chapter id="sec1" Contents-->
<h1 id="sec1" class="chapter">Contents</h1><!--SEC END --><ul class="toc"><li class="li-toc">
<a href="#introduction">Chapter&#XA0;1&#XA0;&#XA0;Introduction</a>
<ul class="toc"><li class="li-toc">
<a href="#how-to-read-this-manual">1.1&#XA0;&#XA0;How to read this manual</a>
</li><li class="li-toc"><a href="#pluggable-types">1.2&#XA0;&#XA0;How it works: Pluggable types</a>
</li><li class="li-toc"><a href="#installation">1.3&#XA0;&#XA0;Installation</a>
</li><li class="li-toc"><a href="#example-use">1.4&#XA0;&#XA0;Example use: detecting a null pointer bug</a>
</li></ul>
</li><li class="li-toc"><a href="#using-a-checker">Chapter&#XA0;2&#XA0;&#XA0;Using a checker</a>
<ul class="toc"><li class="li-toc">
<a href="#writing-annotations">2.1&#XA0;&#XA0;Writing annotations</a>
</li><li class="li-toc"><a href="#running">2.2&#XA0;&#XA0;Running a checker</a>
</li><li class="li-toc"><a href="#checker-guarantees">2.3&#XA0;&#XA0;What the checker guarantees</a>
</li><li class="li-toc"><a href="#tips-about-writing-annotations">2.4&#XA0;&#XA0;Tips about writing annotations</a>
</li></ul>
</li><li class="li-toc"><a href="#nullness-checker">Chapter&#XA0;3&#XA0;&#XA0;Nullness Checker</a>
<ul class="toc"><li class="li-toc">
<a href="#nullness-checks">3.1&#XA0;&#XA0;What the Nullness Checker checks</a>
</li><li class="li-toc"><a href="#nullness-annotations">3.2&#XA0;&#XA0;Nullness annotations</a>
</li><li class="li-toc"><a href="#writing-nullness-annotations">3.3&#XA0;&#XA0;Writing nullness annotations</a>
</li><li class="li-toc"><a href="#suppressing-warnings-nullness">3.4&#XA0;&#XA0;Suppressing nullness warnings</a>
</li><li class="li-toc"><a href="#nullness-example">3.5&#XA0;&#XA0;Examples</a>
</li><li class="li-toc"><a href="#nullness-getting-started">3.6&#XA0;&#XA0;Tips for getting started</a>
</li><li class="li-toc"><a href="#nullness-related-work">3.7&#XA0;&#XA0;Other tools for nullness checking</a>
</li><li class="li-toc"><a href="#initialization-checker">3.8&#XA0;&#XA0;Initialization Checker</a>
</li></ul>
</li><li class="li-toc"><a href="#map-key-checker">Chapter&#XA0;4&#XA0;&#XA0;Map Key Checker</a>
<ul class="toc"><li class="li-toc">
<a href="#map-key-annotations">4.1&#XA0;&#XA0;Map key annotations</a>
</li><li class="li-toc"><a href="#map-key-examples">4.2&#XA0;&#XA0;Examples</a>
</li><li class="li-toc"><a href="#map-key-annotations-inference">4.3&#XA0;&#XA0;Inference of @KeyFor annotations</a>
</li></ul>
</li><li class="li-toc"><a href="#interning-checker">Chapter&#XA0;5&#XA0;&#XA0;Interning Checker</a>
<ul class="toc"><li class="li-toc">
<a href="#interning-annotations">5.1&#XA0;&#XA0;Interning annotations</a>
</li><li class="li-toc"><a href="#annotating-with-interned">5.2&#XA0;&#XA0;Annotating your code with <span style="font-family:monospace">@Interned</span></a>
</li><li class="li-toc"><a href="#interning-checks">5.3&#XA0;&#XA0;What the Interning Checker checks</a>
</li><li class="li-toc"><a href="#interning-example">5.4&#XA0;&#XA0;Examples</a>
</li><li class="li-toc"><a href="#other-interning-annotations">5.5&#XA0;&#XA0;Other interning annotations</a>
</li></ul>
</li><li class="li-toc"><a href="#lock-checker">Chapter&#XA0;6&#XA0;&#XA0;Lock Checker</a>
<ul class="toc"><li class="li-toc">
<a href="#lock-guarantees">6.1&#XA0;&#XA0;What the Lock Checker guarantees</a>
</li><li class="li-toc"><a href="#lock-annotations">6.2&#XA0;&#XA0;Lock annotations</a>
</li><li class="li-toc"><a href="#lock-type-checking-rules">6.3&#XA0;&#XA0;Type-checking rules</a>
</li><li class="li-toc"><a href="#lock-examples">6.4&#XA0;&#XA0;Examples</a>
</li><li class="li-toc"><a href="#lock-details">6.5&#XA0;&#XA0;More locking details</a>
</li><li class="li-toc"><a href="#lock-other-annotations">6.6&#XA0;&#XA0;Other lock annotations</a>
</li><li class="li-toc"><a href="#lock-extensions">6.7&#XA0;&#XA0;Possible extensions</a>
</li></ul>
</li><li class="li-toc"><a href="#fenum-checker">Chapter&#XA0;7&#XA0;&#XA0;Fake Enum Checker</a>
<ul class="toc"><li class="li-toc">
<a href="#fenum-annotations">7.1&#XA0;&#XA0;Fake enum annotations</a>
</li><li class="li-toc"><a href="#fenum-checks">7.2&#XA0;&#XA0;What the Fenum Checker checks</a>
</li><li class="li-toc"><a href="#fenum-running">7.3&#XA0;&#XA0;Running the Fenum Checker</a>
</li><li class="li-toc"><a href="#fenum-suppressing">7.4&#XA0;&#XA0;Suppressing warnings</a>
</li><li class="li-toc"><a href="#fenum-example">7.5&#XA0;&#XA0;Example</a>
</li><li class="li-toc"><a href="#fenum-references">7.6&#XA0;&#XA0;References</a>
</li></ul>
</li><li class="li-toc"><a href="#tainting-checker">Chapter&#XA0;8&#XA0;&#XA0;Tainting Checker</a>
<ul class="toc"><li class="li-toc">
<a href="#tainting-annotations">8.1&#XA0;&#XA0;Tainting annotations</a>
</li><li class="li-toc"><a href="#writing-untainted">8.2&#XA0;&#XA0;Tips on writing <span style="font-family:monospace">@Untainted</span> annotations</a>
</li><li class="li-toc"><a href="#tainting-many-uses">8.3&#XA0;&#XA0;<span style="font-family:monospace">@Tainted</span> and <span style="font-family:monospace">@Untainted</span> can be used for many purposes</a>
</li></ul>
</li><li class="li-toc"><a href="#regex-checker">Chapter&#XA0;9&#XA0;&#XA0;Regex Checker for regular expression syntax</a>
<ul class="toc"><li class="li-toc">
<a href="#regex-annotations">9.1&#XA0;&#XA0;Regex annotations</a>
</li><li class="li-toc"><a href="#annotating-with-regex">9.2&#XA0;&#XA0;Annotating your code with <span style="font-family:monospace">@Regex</span></a>
</li></ul>
</li><li class="li-toc"><a href="#formatter-checker">Chapter&#XA0;10&#XA0;&#XA0;Format String Checker</a>
<ul class="toc"><li class="li-toc">
<a href="#formatter-terminology">10.1&#XA0;&#XA0;Formatting terminology</a>
</li><li class="li-toc"><a href="#formatter-annotations">10.2&#XA0;&#XA0;Format String Checker annotations</a>
</li><li class="li-toc"><a href="#formatter-guarantees">10.3&#XA0;&#XA0;What the Format String Checker checks</a>
</li><li class="li-toc"><a href="#formatter-implicit">10.4&#XA0;&#XA0;Implicit qualifiers</a>
</li><li class="li-toc"><a href="#formatter-FormatMethod">10.5&#XA0;&#XA0;FormatMethod</a>
</li><li class="li-toc"><a href="#formatter-run-time-tests">10.6&#XA0;&#XA0;Testing whether a format string is valid</a>
</li></ul>
</li><li class="li-toc"><a href="#i18n-formatter-checker">Chapter&#XA0;11&#XA0;&#XA0;Internationalization Format String Checker (I18n Format String Checker)</a>
<ul class="toc"><li class="li-toc">
<a href="#i18n-format-annotation">11.1&#XA0;&#XA0;Internationalization Format String Checker annotations</a>
</li><li class="li-toc"><a href="#i18n-format-conversion-catgeories">11.2&#XA0;&#XA0;Conversion categories</a>
</li><li class="li-toc"><a href="#i18n-format-checks">11.3&#XA0;&#XA0;What the Internationalization Format String Checker checks</a>
</li><li class="li-toc"><a href="#i18n-format-resource-files">11.4&#XA0;&#XA0;Resource files</a>
</li><li class="li-toc"><a href="#i18n-format-running">11.5&#XA0;&#XA0;Running the Internationalization Format Checker</a>
</li><li class="li-toc"><a href="#i18n-format-testing">11.6&#XA0;&#XA0;Testing whether a string has an i18n format type</a>
</li><li class="li-toc"><a href="#i18n-format-examples">11.7&#XA0;&#XA0;Examples of using the Internationalization Format Checker</a>
</li></ul>
</li><li class="li-toc"><a href="#propkey-checker">Chapter&#XA0;12&#XA0;&#XA0;Property File Checker</a>
<ul class="toc"><li class="li-toc">
<a href="#genpropkey-checker">12.1&#XA0;&#XA0;General Property File Checker</a>
</li><li class="li-toc"><a href="#i18n-checker">12.2&#XA0;&#XA0;Internationalization Checker</a>
</li><li class="li-toc"><a href="#compilermsgs-checker">12.3&#XA0;&#XA0;Compiler Message Key Checker</a>
</li></ul>
</li><li class="li-toc"><a href="#signature-checker">Chapter&#XA0;13&#XA0;&#XA0;Signature String Checker for string representations of types</a>
<ul class="toc"><li class="li-toc">
<a href="#signature-annotations">13.1&#XA0;&#XA0;Signature annotations</a>
</li><li class="li-toc"><a href="#signature-checks">13.2&#XA0;&#XA0;What the Signature Checker checks</a>
</li></ul>
</li><li class="li-toc"><a href="#guieffect-checker">Chapter&#XA0;14&#XA0;&#XA0;GUI Effect Checker</a>
<ul class="toc"><li class="li-toc">
<a href="#guieffect-annotations">14.1&#XA0;&#XA0;GUI effect annotations</a>
</li><li class="li-toc"><a href="#guieffect-checks">14.2&#XA0;&#XA0;What the GUI Effect Checker checks</a>
</li><li class="li-toc"><a href="#guieffect-running">14.3&#XA0;&#XA0;Running the GUI Effect Checker</a>
</li><li class="li-toc"><a href="#guieffect-defaults">14.4&#XA0;&#XA0;Annotation defaults</a>
</li><li class="li-toc"><a href="#guieffect-polymorphism">14.5&#XA0;&#XA0;Polymorphic effects</a>
</li><li class="li-toc"><a href="#guieffect-references">14.6&#XA0;&#XA0;References</a>
</li></ul>
</li><li class="li-toc"><a href="#units-checker">Chapter&#XA0;15&#XA0;&#XA0;Units Checker</a>
<ul class="toc"><li class="li-toc">
<a href="#units-annotations">15.1&#XA0;&#XA0;Units annotations</a>
</li><li class="li-toc"><a href="#extending-units">15.2&#XA0;&#XA0;Extending the Units Checker</a>
</li><li class="li-toc"><a href="#units-checks">15.3&#XA0;&#XA0;What the Units Checker checks</a>
</li><li class="li-toc"><a href="#units-running">15.4&#XA0;&#XA0;Running the Units Checker</a>
</li><li class="li-toc"><a href="#units-suppressing">15.5&#XA0;&#XA0;Suppressing warnings</a>
</li><li class="li-toc"><a href="#units-references">15.6&#XA0;&#XA0;References</a>
</li></ul>
</li><li class="li-toc"><a href="#constant-value-checker">Chapter&#XA0;16&#XA0;&#XA0;Constant Value Checker</a>
<ul class="toc"><li class="li-toc">
<a href="#constant-value-checker-annotations">16.1&#XA0;&#XA0;Annotations</a>
</li><li class="li-toc"><a href="#value-checker-warnings">16.2&#XA0;&#XA0;Warnings</a>
</li></ul>
</li><li class="li-toc"><a href="#aliasing-checker">Chapter&#XA0;17&#XA0;&#XA0;Aliasing Checker</a>
<ul class="toc"><li class="li-toc">
<a href="#aliasing-annotations">17.1&#XA0;&#XA0;Aliasing annotations</a>
</li><li class="li-toc"><a href="#aliasing-leaking-contexts">17.2&#XA0;&#XA0;Leaking contexts</a>
</li><li class="li-toc"><a href="#aliasing-unique-restrictions">17.3&#XA0;&#XA0;Restrictions on where <span style="font-family:monospace">@Unique</span> may be written</a>
</li><li class="li-toc"><a href="#aliasing-refinement">17.4&#XA0;&#XA0;Aliasing type refinement</a>
</li></ul>
</li><li class="li-toc"><a href="#linear-checker">Chapter&#XA0;18&#XA0;&#XA0;Linear Checker for preventing aliasing</a>
<ul class="toc"><li class="li-toc">
<a href="#linear-annotations">18.1&#XA0;&#XA0;Linear annotations</a>
</li><li class="li-toc"><a href="#linear-limitations">18.2&#XA0;&#XA0;Limitations</a>
</li></ul>
</li><li class="li-toc"><a href="#reflection-resolution">Chapter&#XA0;19&#XA0;&#XA0;Reflection resolution</a>
<ul class="toc"><li class="li-toc">
<a href="#methodval-and-classval-checkers">19.1&#XA0;&#XA0;MethodVal and ClassVal Checkers</a>
</li><li class="li-toc"><a href="#reflection-examples">19.2&#XA0;&#XA0;Reflection resolution example</a>
</li></ul>
</li><li class="li-toc"><a href="#subtyping-checker">Chapter&#XA0;20&#XA0;&#XA0;Subtyping Checker</a>
<ul class="toc"><li class="li-toc">
<a href="#subtyping-using">20.1&#XA0;&#XA0;Using the Subtyping Checker</a>
</li><li class="li-toc"><a href="#subtyping-example">20.2&#XA0;&#XA0;Subtyping Checker example</a>
</li></ul>
</li><li class="li-toc"><a href="#third-party-checkers">Chapter&#XA0;21&#XA0;&#XA0;Third-party checkers</a>
<ul class="toc"><li class="li-toc">
<a href="#typestate-checker">21.1&#XA0;&#XA0;Typestate checkers</a>
</li><li class="li-toc"><a href="#units-and-dimensions-checker">21.2&#XA0;&#XA0;Units and dimensions checker</a>
</li><li class="li-toc"><a href="#loci-thread-locality-checker">21.3&#XA0;&#XA0;Thread locality checker</a>
</li><li class="li-toc"><a href="#safety-critical-java-checker">21.4&#XA0;&#XA0;Safety-Critical Java checker</a>
</li><li class="li-toc"><a href="#gut-checker">21.5&#XA0;&#XA0;Generic Universe Types checker</a>
</li><li class="li-toc"><a href="#enerj-checker">21.6&#XA0;&#XA0;EnerJ checker</a>
</li><li class="li-toc"><a href="#checklt-checker">21.7&#XA0;&#XA0;CheckLT taint checker</a>
</li><li class="li-toc"><a href="#sparta-checker">21.8&#XA0;&#XA0;SPARTA information flow type-checker for Android</a>
</li><li class="li-toc"><a href="#igj-checker">21.9&#XA0;&#XA0;Immutability checkers: IGJ, OIGJ, and Javari</a>
</li></ul>
</li><li class="li-toc"><a href="#polymorphism">Chapter&#XA0;22&#XA0;&#XA0;Generics and polymorphism</a>
<ul class="toc"><li class="li-toc">
<a href="#generics">22.1&#XA0;&#XA0;Generics (parametric polymorphism or type polymorphism)</a>
</li><li class="li-toc"><a href="#qualifier-polymorphism">22.2&#XA0;&#XA0;Qualifier polymorphism</a>
</li><li class="li-toc"><a href="#qualifier-parameters">22.3&#XA0;&#XA0;Qualifier parameters</a>
</li></ul>
</li><li class="li-toc"><a href="#advanced-type-system-features">Chapter&#XA0;23&#XA0;&#XA0;Advanced type system features</a>
<ul class="toc"><li class="li-toc">
<a href="#invariant-arrays">23.1&#XA0;&#XA0;Invariant array types</a>
</li><li class="li-toc"><a href="#array-context-sensitive">23.2&#XA0;&#XA0;Context-sensitive type inference for array constructors</a>
</li><li class="li-toc"><a href="#effective-qualifier">23.3&#XA0;&#XA0;The effective qualifier on a type (defaults and inference)</a>
</li><li class="li-toc"><a href="#type-refinement">23.4&#XA0;&#XA0;Automatic type refinement (flow-sensitive type qualifier inference)</a>
</li><li class="li-toc"><a href="#java-expressions-as-arguments">23.5&#XA0;&#XA0;Writing Java expressions as annotation arguments</a>
</li><li class="li-toc"><a href="#unused-fields">23.6&#XA0;&#XA0;Unused fields</a>
</li></ul>
</li><li class="li-toc"><a href="#suppressing-warnings">Chapter&#XA0;24&#XA0;&#XA0;Suppressing warnings</a>
<ul class="toc"><li class="li-toc">
<a href="#suppresswarnings-annotation">24.1&#XA0;&#XA0;<span style="font-family:monospace">@SuppressWarnings</span> annotation</a>
</li><li class="li-toc"><a href="#assumeassertion">24.2&#XA0;&#XA0;<span style="font-family:monospace">@AssumeAssertion</span> string in an <span style="font-family:monospace">assert</span> message</a>
</li><li class="li-toc"><a href="#suppresswarnings-command-line">24.3&#XA0;&#XA0;<span style="font-family:monospace">-AsuppressWarnings</span> command-line option</a>
</li><li class="li-toc"><a href="#askipuses">24.4&#XA0;&#XA0;<span style="font-family:monospace">-AskipUses</span> and <span style="font-family:monospace">-AonlyUses</span> command-line options</a>
</li><li class="li-toc"><a href="#askipdefs">24.5&#XA0;&#XA0;<span style="font-family:monospace">-AskipDefs</span> and <span style="font-family:monospace">-AonlyDefs</span> command-line options</a>
</li><li class="li-toc"><a href="#alint">24.6&#XA0;&#XA0;<span style="font-family:monospace">-Alint</span> command-line option</a>
</li><li class="li-toc"><a href="#no-processor">24.7&#XA0;&#XA0;No <span style="font-family:monospace">-processor</span> command-line option</a>
</li><li class="li-toc"><a href="#checker-specific-suppression">24.8&#XA0;&#XA0;Checker-specific mechanisms</a>
</li></ul>
</li><li class="li-toc"><a href="#legacy-code">Chapter&#XA0;25&#XA0;&#XA0;Handling legacy code</a>
<ul class="toc"><li class="li-toc">
<a href="#unannotated-code">25.1&#XA0;&#XA0;Checking partially-annotated programs: handling unannotated code</a>
</li><li class="li-toc"><a href="#backward-compatibility">25.2&#XA0;&#XA0;Backward compatibility with earlier versions of Java</a>
</li></ul>
</li><li class="li-toc"><a href="#type-inference">Chapter&#XA0;26&#XA0;&#XA0;Type inference</a>
<ul class="toc"><li class="li-toc">
<a href="#type-inference-refinement">26.1&#XA0;&#XA0;Local type inference during type-checking</a>
</li><li class="li-toc"><a href="#type-inference-to-annotate">26.2&#XA0;&#XA0;Type inference to annotate a program</a>
</li></ul>
</li><li class="li-toc"><a href="#annotating-libraries">Chapter&#XA0;27&#XA0;&#XA0;Annotating libraries</a>
<ul class="toc"><li class="li-toc">
<a href="#annotated-libraries-using">27.1&#XA0;&#XA0;Using annotated libraries from the Checker Framework distribution</a>
</li><li class="li-toc"><a href="#annotated-libraries-creating">27.2&#XA0;&#XA0;Creating an annotated library</a>
</li><li class="li-toc"><a href="#compiling-libraries">27.3&#XA0;&#XA0;Compiling partially-annotated libraries</a>
</li><li class="li-toc"><a href="#stub">27.4&#XA0;&#XA0;Using stub classes</a>
</li><li class="li-toc"><a href="#libraries-troubleshooting">27.5&#XA0;&#XA0;Troubleshooting/debugging annotated libraries</a>
</li></ul>
</li><li class="li-toc"><a href="#writing-a-checker">Chapter&#XA0;28&#XA0;&#XA0;How to create a new checker</a>
<ul class="toc"><li class="li-toc">
<a href="#tool-relationships">28.1&#XA0;&#XA0;Relationship of the Checker Framework to other tools</a>
</li><li class="li-toc"><a href="#parts-of-a-checker">28.2&#XA0;&#XA0;The parts of a checker</a>
</li><li class="li-toc"><a href="#writing-typequals">28.3&#XA0;&#XA0;Annotations: Type qualifiers and hierarchy</a>
</li><li class="li-toc"><a href="#extending-visitor">28.4&#XA0;&#XA0;Visitor: Type rules</a>
</li><li class="li-toc"><a href="#writing-type-introduction">28.5&#XA0;&#XA0;Type factory: Implicit annotations (type introduction rules)</a>
</li><li class="li-toc"><a href="#dataflow">28.6&#XA0;&#XA0;Dataflow: enhancing flow-sensitive type qualifier inference</a>
</li><li class="li-toc"><a href="#writing-compiler-interface">28.7&#XA0;&#XA0;The checker class: Compiler interface</a>
</li><li class="li-toc"><a href="#testing-framework">28.8&#XA0;&#XA0;Testing framework</a>
</li><li class="li-toc"><a href="#debugging-options">28.9&#XA0;&#XA0;Debugging options</a>
</li><li class="li-toc"><a href="#documenting-a-checker">28.10&#XA0;&#XA0;Documenting the checker</a>
</li><li class="li-toc"><a href="#javac-tips">28.11&#XA0;&#XA0;javac implementation survival guide</a>
</li><li class="li-toc"><a href="#integrating-a-checker">28.12&#XA0;&#XA0;Integrating a checker with the Checker Framework</a>
</li></ul>
</li><li class="li-toc"><a href="#external-tools">Chapter&#XA0;29&#XA0;&#XA0;Integration with external tools</a>
<ul class="toc"><li class="li-toc">
<a href="#javac-installation">29.1&#XA0;&#XA0;Javac compiler</a>
</li><li class="li-toc"><a href="#ant-task">29.2&#XA0;&#XA0;Ant task</a>
</li><li class="li-toc"><a href="#maven">29.3&#XA0;&#XA0;Maven</a>
</li><li class="li-toc"><a href="#gradle">29.4&#XA0;&#XA0;Gradle</a>
</li><li class="li-toc"><a href="#android-gradle">29.5&#XA0;&#XA0;Android plugin for Gradle</a>
</li><li class="li-toc"><a href="#intellij">29.6&#XA0;&#XA0;IntelliJ IDEA</a>
</li><li class="li-toc"><a href="#eclipse">29.7&#XA0;&#XA0;Eclipse</a>
</li><li class="li-toc"><a href="#tide">29.8&#XA0;&#XA0;tIDE</a>
</li><li class="li-toc"><a href="#sec371">29.9&#XA0;&#XA0;Type inference tools</a>
</li></ul>
</li><li class="li-toc"><a href="#faq">Chapter&#XA0;30&#XA0;&#XA0;Frequently Asked Questions (FAQs)</a>
<ul class="toc"><li class="li-toc">
<a href="#faq-motivation-section">30.1&#XA0;&#XA0;Motivation for pluggable type-checking</a>
</li><li class="li-toc"><a href="#faq-getting-started-section">30.2&#XA0;&#XA0;Getting started</a>
</li><li class="li-toc"><a href="#faq-usability-section">30.3&#XA0;&#XA0;Usability of pluggable type-checking</a>
</li><li class="li-toc"><a href="#faq-warnings-section">30.4&#XA0;&#XA0;How to handle warnings and errors</a>
</li><li class="li-toc"><a href="#faq-syntax-section">30.5&#XA0;&#XA0;Syntax of type annotations</a>
</li><li class="li-toc"><a href="#faq-semantics-section">30.6&#XA0;&#XA0;Semantics of type annotations</a>
</li><li class="li-toc"><a href="#faq-create-a-checker-section">30.7&#XA0;&#XA0;Creating a new checker</a>
</li><li class="li-toc"><a href="#faq-other-tools-section">30.8&#XA0;&#XA0;Relationship to other tools</a>
</li></ul>
</li><li class="li-toc"><a href="#troubleshooting">Chapter&#XA0;31&#XA0;&#XA0;Troubleshooting and getting help</a>
<ul class="toc"><li class="li-toc">
<a href="#common-problems">31.1&#XA0;&#XA0;Common problems and solutions</a>
</li><li class="li-toc"><a href="#reporting-bugs">31.2&#XA0;&#XA0;How to report problems (bug reporting)</a>
</li><li class="li-toc"><a href="#build-source">31.3&#XA0;&#XA0;Building from source</a>
</li><li class="li-toc"><a href="#publications">31.4&#XA0;&#XA0;Publications</a>
</li><li class="li-toc"><a href="#other-tools">31.5&#XA0;&#XA0;Comparison to other tools</a>
</li><li class="li-toc"><a href="#credits">31.6&#XA0;&#XA0;Credits, changelog, and license</a>
</li></ul>
</li></ul><hr>
<!--TOC chapter id="introduction" Introduction-->
<h1 id="introduction" class="chapter">Chapter&#XA0;1&#XA0;&#XA0;Introduction</h1><!--SEC END --><p>The Checker Framework enhances Java&#X2019;s type system to make it more powerful
and useful.
This lets software developers detect and
prevent errors in their Java programs.</p><p>A &#X201C;checker&#X201D; is a tool that warns you about certain errors or gives you a
guarantee that those errors do not occur.
The Checker Framework comes with checkers for specific types of errors:</p><ol class="enumerate" type=1><li class="li-enumerate"><a href="#nullness-checker">Nullness Checker</a> for null pointer errors
(see Chapter&#XA0;<a href="#nullness-checker">3</a>)
</li><li class="li-enumerate"><a href="#initialization-checker">Initialization Checker</a> to ensure all
fields are set in the constructor (see
Chapter&#XA0;<a href="#initialization-checker">3.8</a>)
</li><li class="li-enumerate"><a href="#map-key-checker">Map Key Checker</a> to track which values are
keys in a map (see Chapter&#XA0;<a href="#map-key-checker">4</a>)
</li><li class="li-enumerate"><a href="#interning-checker">Interning Checker</a> for errors in equality
testing and interning (see Chapter&#XA0;<a href="#interning-checker">5</a>)
</li><li class="li-enumerate"><a href="#lock-checker">Lock Checker</a> for concurrency and lock errors
(see Chapter&#XA0;<a href="#lock-checker">6</a>)
</li><li class="li-enumerate"><a href="#fenum-checker">Fake Enum Checker</a> to allow type-safe fake enum
patterns (see Chapter&#XA0;<a href="#fenum-checker">7</a>)
</li><li class="li-enumerate"><a href="#tainting-checker">Tainting Checker</a> for trust and security errors
(see Chapter&#XA0;<a href="#tainting-checker">8</a>)
</li><li class="li-enumerate"><a href="#regex-checker">Regex Checker</a> to prevent use of syntactically
invalid regular expressions (see Chapter&#XA0;<a href="#regex-checker">9</a>)
</li><li class="li-enumerate"><a href="#formatter-checker">Format String Checker</a> to ensure that format
strings have the right number and type of <span style="font-family:monospace">%</span> directives (see
Chapter&#XA0;<a href="#formatter-checker">10</a>)
</li><li class="li-enumerate"><a href="#i18n-formatter-checker">Internationalization Format String Checker</a>
to ensure that i18n format strings have the right number and type of
<span style="font-family:monospace">{}</span> directives (see Chapter&#XA0;<a href="#i18n-formatter-checker">11</a>)
</li><li class="li-enumerate"><a href="#propkey-checker">Property File Checker</a> to ensure that valid
keys are used for property files and resource bundles (see
Chapter&#XA0;<a href="#propkey-checker">12</a>)
</li><li class="li-enumerate"><a href="#i18n-checker">Internationalization Checker</a> to
ensure that code is properly internationalized (see
Chapter&#XA0;<a href="#i18n-checker">12.2</a>)
</li><li class="li-enumerate"><a href="#signature-checker">Signature String Checker</a> to ensure that the
string representation of a type is properly used, for example in
<span style="font-family:monospace">Class.forName</span> (see Chapter&#XA0;<a href="#signature-checker">13</a>)
</li><li class="li-enumerate"><a href="#guieffect-checker">GUI Effect Checker</a> to ensure that non-GUI
threads do not access the UI, which would crash the application
(see Chapter&#XA0;<a href="#guieffect-checker">14</a>)
</li><li class="li-enumerate"><a href="#units-checker">Units Checker</a> to ensure operations are
performed on correct units of measurement
(see Chapter&#XA0;<a href="#units-checker">15</a>)
</li><li class="li-enumerate"><a href="#constant-value-checker">Constant Value Checker</a> to determine
whether an expression&#X2019;s value can be known at compile time
(see Chapter&#XA0;<a href="#constant-value-checker">16</a>)
</li><li class="li-enumerate"><a href="#aliasing-checker">Aliasing Checker</a> to identify whether
expressions have aliases (see Chapter&#XA0;<a href="#aliasing-checker">17</a>)
</li><li class="li-enumerate"><a href="#linear-checker">Linear Checker</a> to control aliasing and prevent
re-use (see Chapter&#XA0;<a href="#linear-checker">18</a>)
</li><li class="li-enumerate"><a href="#subtyping-checker">Subtyping Checker</a> for customized checking without
writing any code (see Chapter&#XA0;<a href="#subtyping-checker">20</a>)
</li><li class="li-enumerate"><a href="#third-party-checkers">Third-party checkers</a> that are distributed
separately from the Checker Framework
(see Chapter&#XA0;<a href="#third-party-checkers">21</a>)</li></ol><p>These checkers are easy to use and are invoked as arguments to <span style="font-family:monospace">javac</span>.</p><p>The Checker Framework also enables you to write new checkers of your
own; see Chapters&#XA0;<a href="#subtyping-checker">20</a> and&#XA0;<a href="#writing-a-checker">28</a>.</p>
<!--TOC section id="how-to-read-this-manual" How to read this manual-->
<h2 id="how-to-read-this-manual" class="section">1.1&#XA0;&#XA0;How to read this manual</h2><!--SEC END --><p>If you wish to get started using some particular type system from the list
above, then the most effective way to read this manual is:</p><ul class="itemize"><li class="li-itemize">
Read all of the introductory material
(Chapters&#XA0;<a href="#introduction">1</a>&#X2013;<a href="#using-a-checker">2</a>).
</li><li class="li-itemize">Read just one of the descriptions of a particular type system and its
checker (Chapters&#XA0;<a href="#nullness-checker">3</a>&#X2013;<a href="#third-party-checkers">21</a>).
</li><li class="li-itemize">Skim the advanced material that will enable you to make more effective
use of a type system
(Chapters&#XA0;<a href="#polymorphism">22</a>&#X2013;<a href="#troubleshooting">31</a>), so that you will
know what is available and can find it later. Skip
Chapter&#XA0;<a href="#writing-a-checker">28</a> on creating a new checker.
</li></ul>
<!--TOC section id="pluggable-types" How it works: Pluggable types-->
<h2 id="pluggable-types" class="section">1.2&#XA0;&#XA0;How it works: Pluggable types</h2><!--SEC END --><p>The Checker Framework supports adding
pluggable type systems to the Java language in a backward-compatible way.
Java&#X2019;s built-in type-checker finds and prevents many errors &#X2014; but it
doesn&#X2019;t find and prevent <em>enough</em> errors. The Checker Framework lets you
run an additional type-checker as a plug-in to the javac compiler. Your
code stays completely backward-compatible: your code compiles with any
Java compiler, it runs on any JVM, and your coworkers don&#X2019;t have to use the
enhanced type system if they don&#X2019;t want to. You can check only part of
your program. Type inference tools exist to help you annotate your
code; see Chapter&#XA0;<a href="#type-inference-to-annotate">26.2</a>.</p><p>A type system designer uses the Checker Framework to define type qualifiers
and their semantics, and a
compiler plug-in (a &#X201C;checker&#X201D;) enforces the semantics. Programmers can
write the type qualifiers in their programs and use the plug-in to detect
or prevent errors. The Checker Framework is useful both to programmers who
wish to write error-free code, and to type system designers who wish to
evaluate and deploy their type systems.</p><p>This document uses the terms &#X201C;checker&#X201D;, &#X201C;checker plugin&#X201D;,
&#X201C;type-checking compiler plugin&#X201D;, and &#X201C;annotation processor&#X201D; as
synonyms.</p>
<!--TOC section id="installation" Installation-->
<h2 id="installation" class="section">1.3&#XA0;&#XA0;Installation</h2><!--SEC END --><p>
This section describes how to install the Checker Framework.
(If you wish to use the Checker Framework from Eclipse, see the Checker
Framework Eclipse Plugin webpage instead:
<a href="http://types.cs.washington.edu/checker-framework/eclipse/"><span style="font-family:monospace">http://types.cs.washington.edu/checker-framework/eclipse/</span></a>.)
(If you wish to try the Checker Framework without installing it, use the
<a href="http://eisop.uwaterloo.ca/live/">Checker Framework Live Demo</a> webpage.)
</p><p>The Checker Framework release contains everything that you need, both to
run checkers and to write your own checkers. As an alternative, you can
build the latest development version from source
(Section&#XA0;<a href="#build-source">31.3</a>).</p><p><span style="font-weight:bold">Requirement:</span>
You must have <span style="font-weight:bold">JDK 7</span> or later installed. You can get JDK 7 from
<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Oracle</a>
or elsewhere. If you are using Apple Mac OS X, you can use
<a href="https://developer.apple.com/search/index.php?q=java">Apple&#X2019;s implementation</a>,
<a href="http://landonf.bikemonkey.org/static/soylatte/">SoyLatte</a>,
or the <a href="http://openjdk.java.net/">OpenJDK</a>.</p><p>The installation process is simple! It has two required steps and one
optional step.
</p><ol class="enumerate" type=1><li class="li-enumerate">
Download the Checker Framework distribution:
<a href="http://types.cs.washington.edu/checker-framework/current/checker-framework-2.0.0.zip"><span style="font-family:monospace">http://types.cs.washington.edu/checker-framework/current/checker-framework-2.0.0.zip</span></a></li><li class="li-enumerate">Unzip it to create a <span style="font-family:monospace">checker-framework</span> directory.</li><li class="li-enumerate"><a id="installation-configure-step"></a>Configure your IDE, build system, or command shell to include the Checker
Framework on the classpath. Choose the appropriate section of
Chapter&#XA0;<a href="#external-tools">29</a> for
javac (Section&#XA0;<a href="#javac-installation">29.1</a>),
Ant (Section&#XA0;<a href="#ant-task">29.2</a>),
Maven (Section&#XA0;<a href="#maven">29.3</a>),
Gradle (Section&#XA0;<a href="#gradle">29.4</a>),
IntelliJ IDEA (Section&#XA0;<a href="#intellij">29.6</a>),
Eclipse (Section&#XA0;<a href="#eclipse">29.7</a>),
or
tIDE (Section&#XA0;<a href="#tide">29.8</a>).</li></ol><p>That&#X2019;s all there is to it! Now you are ready to start using the checkers.</p><p>We recommend that you work through the
<a href="http://types.cs.washington.edu/checker-framework/tutorial/">Checker
Framework tutorial</a>, which walks you through how to use the Checker
Framework in Eclipse or on
the command line.
There is also a
<a href="https://github.com/glts/safer-spring-petclinic/wiki">Nullness Checker
tutorial</a> by David B&#XFC;rgin.</p><p>Section&#XA0;<a href="#example-use">1.4</a> walks you through a simple example. More detailed
instructions for using a checker appear in Chapter&#XA0;<a href="#using-a-checker">2</a>.</p>
<!--TOC section id="example-use" Example use: detecting a null pointer bug-->
<h2 id="example-use" class="section">1.4&#XA0;&#XA0;Example use: detecting a null pointer bug</h2><!--SEC END --><p>This section gives a very simple example of running the Checker Framework.
There is also a <a href="http://types.cs.washington.edu/checker-framework/tutorial/">tutorial</a>
that gives more extensive instructions for using the Checker Framework in
Eclipse or on the command line,
and a
<a href="https://github.com/glts/safer-spring-petclinic/wiki">Nullness Checker
tutorial</a> by David B&#XFC;rgin.</p><ol class="enumerate" type=1><li class="li-enumerate">
Let&#X2019;s consider this very simple Java class. The local variable <span style="font-family:monospace">ref</span>&#X2019;s type is
annotated as <a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a>, indicating that <span style="font-family:monospace">ref</span> must be a reference to a
non-null object. Save the file as <span style="font-family:monospace">GetStarted.java</span>.<pre class="verbatim">import org.checkerframework.checker.nullness.qual.*;

public class GetStarted {
    void sample() {
        @NonNull Object ref = new Object();
    }
}
</pre></li><li class="li-enumerate">Run the Nullness Checker on the class.
You can do that from the command line or from an IDE:<ol class="enumerate" type=a><li class="li-enumerate">
From the command line, run this command:<pre>
  <em>javac</em> -processor org.checkerframework.checker.nullness.NullnessChecker GetStarted.java
</pre><p>where <em><span style="font-family:monospace">javac</span></em> is set as in Section&#XA0;<a href="#javac-installation">29.1</a>.</p></li><li class="li-enumerate">To compile within your IDE, you must have customized it to use the
Checker Framework compiler and to pass the extra arguments (see
Chapter&#XA0;<a href="#external-tools">29</a>).
</li></ol><p>The compilation should complete without any errors.</p></li><li class="li-enumerate">Let&#X2019;s introduce an error now. Modify <span style="font-family:monospace">ref</span>&#X2019;s assignment to:
<pre>
  @NonNull Object ref = <span style="font-weight:bold">null</span>;
</pre></li><li class="li-enumerate">Run the Nullness Checker again, just as before. This run should emit
the following error:
<pre class="verbatim">GetStarted.java:5: incompatible types.
found   : @Nullable &lt;nulltype&gt;
required: @NonNull Object
        @NonNull Object ref = null;
                              ^
1 error
</pre></li></ol><p>The type qualifiers (e.g., <span style="font-family:monospace">@NonNull</span>) are permitted anywhere
that you can write a type, including generics and casts; see
Section&#XA0;<a href="#writing-annotations">2.1</a>. Here are some examples:</p><pre>
  <U>@Interned</U> String intern() <span style="font-family:monospace">{</span> ... <span style="font-family:monospace">}</span>             // return value
  int compareTo(<U>@NonNull</U> String other) <span style="font-family:monospace">{</span> ... <span style="font-family:monospace">}</span>  // parameter
  <U>@NonNull</U> List&lt;<U>@Interned</U> String&gt; messages;     // non-null list of interned Strings
</pre><hr>
<!--TOC chapter id="using-a-checker" Using a checker-->
<h1 id="using-a-checker" class="chapter">Chapter&#XA0;2&#XA0;&#XA0;Using a checker</h1><!--SEC END --><p>A pluggable type-checker enables you to detect certain bugs in your code,
or to prove that they are not present. The verification happens at compile
time.</p><p>Finding bugs, or verifying their absence, with a checker plugin is a two-step process, whose steps are
described in Sections&#XA0;<a href="#writing-annotations">2.1</a> and&#XA0;<a href="#running">2.2</a>.</p><ol class="enumerate" type=1><li class="li-enumerate">The programmer writes annotations, such as <a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a> and
<a href="api/org/checkerframework/checker/interning/qual/Interned.html"><span style="font-family:monospace">@Interned</span></a>, that specify additional information about Java types.
(Or, the programmer uses an inference tool to automatically insert
annotations in his code: see Section&#XA0;<a href="#nullness-inference">3.3.7</a>.)
It is possible to annotate only part of your code: see
Section&#XA0;<a href="#unannotated-code">25.1</a>.</li><li class="li-enumerate">The checker reports whether the program contains any erroneous code
&#X2014; that is, code that is inconsistent with the annotations.</li></ol><p>This chapter is structured as follows:
</p><ul class="itemize"><li class="li-itemize">
Section&#XA0;<a href="#writing-annotations">2.1</a>: How to write annotations
</li><li class="li-itemize">Section&#XA0;<a href="#running">2.2</a>: How to run a checker
</li><li class="li-itemize">Section&#XA0;<a href="#checker-guarantees">2.3</a>: What the checker guarantees
</li><li class="li-itemize">Section&#XA0;<a href="#tips-about-writing-annotations">2.4</a>: Tips about writing annotations
</li></ul><p>Additional topics that apply to all checkers are covered later in the manual:
</p><ul class="itemize"><li class="li-itemize">
Chapter&#XA0;<a href="#advanced-type-system-features">23</a>: Advanced type system features
</li><li class="li-itemize">Chapter&#XA0;<a href="#suppressing-warnings">24</a>: Suppressing warnings
</li><li class="li-itemize">Chapter&#XA0;<a href="#legacy-code">25</a>: Handling legacy code
</li><li class="li-itemize">Chapter&#XA0;<a href="#annotating-libraries">27</a>: Annotating libraries
</li><li class="li-itemize">Chapter&#XA0;<a href="#writing-a-checker">28</a>: How to create a new checker
</li><li class="li-itemize">Chapter&#XA0;<a href="#external-tools">29</a>: Integration with external tools
</li></ul><p>Finally, there is a
<a href="http://types.cs.washington.edu/checker-framework/tutorial/">tutorial</a>
that walks you through using the Checker Framework in Eclipse or on the
command line, and a separate
<a href="https://github.com/glts/safer-spring-petclinic/wiki">Nullness Checker tutorial</a>.</p>
<!--TOC section id="writing-annotations" Writing annotations-->
<h2 id="writing-annotations" class="section">2.1&#XA0;&#XA0;Writing annotations</h2><!--SEC END --><p>The syntax of type annotations in Java is specified by
the Java Language Specification (Java SE 8 edition).
</p><p>Java 5 defines declaration annotations such as <span style="font-family:monospace">@Deprecated</span>, which apply
to a class, method, or field, but do not apply to the method&#X2019;s return type
or the field&#X2019;s type. They are typically written on their own line in the
source code.</p><p>Java 8 defines type annotations, which you write immediately before any
use of a type, including in generics and casts. Because array levels are
types and receivers have types, you can also write type annotations on
them. Here are a few examples of type annotations:</p><pre>
  <U>@Interned</U> String intern() <span style="font-family:monospace">{</span> ... <span style="font-family:monospace">}</span>               // return value
  int compareTo(<U>@NonNull</U> String other) <span style="font-family:monospace">{</span> ... <span style="font-family:monospace">}</span>    // parameter
  String toString(<U>@Tainted</U> MyClass this) <span style="font-family:monospace">{</span> ... <span style="font-family:monospace">}</span>  // receiver ("this" parameter)
  <U>@NonNull</U> List&lt;<U>@Interned</U> String&gt; messages;       // generics:  non-null list of interned Strings
  <U>@Interned</U> String <U>@NonNull</U> [] messages;          // arrays:  non-null array of interned Strings
  myDate = (<U>@Initialized</U> Date) beingConstructed;  // cast
</pre><p>You only need to write annotations on method signatures and fields.
Annotations within method bodies are inferred for you; for more details,
see Section&#XA0;<a href="#type-refinement">23.4</a>.</p><p>You may write the annotations within comments, as in
<span style="font-family:monospace">List&lt;/*@NonNull*/ String&gt;</span>. The Checker Framework compiler, which is
distributed with the Checker Framework, will still process
the annotations.
However, your code will remain compilable by people who are not yet using
Java 8. For more details, see
Section&#XA0;<a href="#annotations-in-comments">25.2.1</a>.</p>
<!--TOC section id="running" Running a checker-->
<h2 id="running" class="section">2.2&#XA0;&#XA0;Running a checker</h2><!--SEC END --><p>To run a checker plugin, run the compiler <span style="font-family:monospace">javac</span> as usual,
but pass the <span style="font-family:monospace">-processor </span><span style="font-family:monospace"><em>plugin_class</em></span> command-line
option.
A concrete example (using the Nullness Checker) is:</p><pre class="verbatim">  javac -processor NullnessChecker MyFile.java
</pre><p>where <span style="font-family:monospace">javac</span> is as specified in Section&#XA0;<a href="#javac-installation">29.1</a>.</p><p>You can also run a checker from within your favorite IDE or build system. See
Chapter&#XA0;<a href="#external-tools">29</a> for details about
Ant (Section&#XA0;<a href="#ant-task">29.2</a>),
Maven (Section&#XA0;<a href="#maven">29.3</a>),
Gradle (Section&#XA0;<a href="#gradle">29.4</a>),
IntelliJ IDEA (Section&#XA0;<a href="#intellij">29.6</a>),
Eclipse (Section&#XA0;<a href="#eclipse">29.7</a>),
and
tIDE (Section&#XA0;<a href="#tide">29.8</a>),
and about customizing other IDEs and build tools.</p><p>The checker is run on only the Java files that javac compiles.
This includes all Java files specified on the command line (or
created by another annotation processor). It may also include other of
your Java files (but not if a more recent <span style="font-family:monospace">.class</span> file exists).
Even when the checker does not analyze a class (say, the class was
already compiled, or source code is not available), it does check
the <em>uses</em> of those classes in the source code being compiled.</p><p>You can always compile the code without the <span style="font-family:monospace">-processor</span>
command-line option, but in that case no checking of the type
annotations is performed. Furthermore, only explicitly-written annotations
are written to the <span style="font-family:monospace">.class</span> file; defaulted annotations are not, and this
will interfere with type-checking of clients that use your code.
Therefore, it is strongly recommended that whenever you are creating
<span style="font-family:monospace">.class</span> files that will be distributed or compiled against, you run the
type-checkers for all the annotations that your have written.</p>
<!--TOC subsection id="distributing" Distributing your annotated project-->
<h3 id="distributing" class="subsection">2.2.1&#XA0;&#XA0;Distributing your annotated project</h3><!--SEC END --><p>You have two main options for distributing your compiled code (<span style="font-family:monospace">.jar</span>
files).</p><ul class="itemize"><li class="li-itemize">
Option 1: no annotations appear in the <span style="font-family:monospace">.jar</span> files. There is no
run-time dependence on the Checker Framework, and the distributed <span style="font-family:monospace">.jar</span>
files are not useful for pluggable type-checking of client code.<p>Write annotations in comments (see
Section&#XA0;<a href="#annotations-in-comments">25.2.1</a>).
Developers perform pluggable type-checking in-house to detect errors and
verify their absence.
To create the distributed <span style="font-family:monospace">.jar</span> files, use a normal Java compiler,
which ignores the annotations.
</p></li><li class="li-itemize">Option 2: annotations appear in the <span style="font-family:monospace">.jar</span> files. The distributed
<span style="font-family:monospace">.jar</span> files can be used for pluggable type-checking of client code.
The <span style="font-family:monospace">.jar</span> files are only compatible with a Java 8 JVM, unless you
do extra work (see Section&#XA0;<a href="#declaration-annotations-for-java7">25.2.5</a>).<p>Write annotations in comments or not in comments (it doesn&#X2019;t matter which).
Developers perform pluggable type-checking in-house to detect errors and
verify their absence.
When you create <span style="font-family:monospace">.class</span> files, use the Checker Framework compiler
(Section&#XA0;<a href="#external-tools">29</a>) and running each relevant type system.
Create the distributed <span style="font-family:monospace">.jar</span> files from those <span style="font-family:monospace">.class</span> files, and also
include the contents of
<span style="font-family:monospace">checker-framework/checker/dist/checker-qual.jar</span> from the Checker
Framework distribution, to define the annotations.</p></li></ul>
<!--TOC subsection id="checker-options" Summary of command-line options-->
<h3 id="checker-options" class="subsection">2.2.2&#XA0;&#XA0;Summary of command-line options</h3><!--SEC END --><p>You can pass command-line arguments to a checker via javac&#X2019;s standard <span style="font-family:monospace">-A</span>
option (&#X201C;<span style="font-family:monospace">A</span>&#X201D; stands for &#X201C;annotation&#X201D;). All of the distributed
checkers support the following command-line options.</p><p>Unsound checking: ignore some errors
</p><ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">-AskipUses</span>, <span style="font-family:monospace">-AonlyUses</span>
Suppress all errors and warnings at all uses of a given class &#X2014; or at all
uses except those of a given class. See Section&#XA0;<a href="#askipuses">24.4</a>
</li><li class="li-itemize"><span style="font-family:monospace">-AskipDefs</span>, <span style="font-family:monospace">-AonlyDefs</span>
Suppress all errors and warnings within the definition of a given class
&#X2014; or everywhere except within the definition of a given class. See
Section&#XA0;<a href="#askipdefs">24.5</a>
</li><li class="li-itemize"><span style="font-family:monospace">-AsuppressWarnings</span>
Suppress all warnings matching the given key; see
Section&#XA0;<a href="#suppresswarnings-command-line">24.3</a>
</li><li class="li-itemize"><span style="font-family:monospace">-AignoreRawTypeArguments</span>
Ignore subtype tests for type arguments that were inferred for a raw
type. If possible, it is better to write the type arguments. See
Section&#XA0;<a href="#generics-raw-types">22.1.1</a>.
</li><li class="li-itemize"><span style="font-family:monospace">-AassumeSideEffectFree</span>
Unsoundly assume that every method is side-effect-free; see
Section&#XA0;<a href="#type-refinement-purity">23.4.5</a>.
</li><li class="li-itemize"><span style="font-family:monospace">-AassumeAssertionsAreEnabled</span>, <span style="font-family:monospace">-AassumeAssertionsAreDisabled</span>
Whether to assume that assertions are enabled or disabled; see Section&#XA0;<a href="#type-refinement-assertions">23.4.6</a>.
</li><li class="li-itemize"><span style="font-family:monospace">-AuseDefaultsForUncheckedCode</span>
Enables/disables unchecked code defualts. Takes arguments &#X201C;source,bytecode&#X201D;.
&#X201C;-source,-bytecode&#X201D; is the default setting.
&#X201C;bytecode&#X201D; specifies
whether the checker should apply unchecked code defaults to
bytecode; see
Section&#XA0;<a href="#defaults-classfile">23.3.5</a>.
Outside the scope of any relevant
<a href="api/org/checkerframework/framework/qual/AnnotatedFor.html"><span style="font-family:monospace">@AnnotatedFor</span></a> annotation, &#X201C;source&#X201D; specifies whether unchecked code
default annotations are applied to source code and suppress all type-checking warnings; see
Section&#XA0;<a href="#compiling-libraries">27.3</a>.
</li></ul><p><a id="unsound-by-default"></a>
More sound (strict) checking: enable errors that are disabled by default
</p><ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">-AcheckPurityAnnotations</span>
Check the bodies of methods marked
<a href="api/org/checkerframework/dataflow/qual/SideEffectFree.html"><span style="font-family:monospace">@SideEffectFree</span></a>,
<a href="api/org/checkerframework/dataflow/qual/Deterministic.html"><span style="font-family:monospace">@Deterministic</span></a>,
and <a href="api/org/checkerframework/dataflow/qual/Pure.html"><span style="font-family:monospace">@Pure</span></a>
to ensure the method satisfies the annotation. By default,
the Checker Framework unsoundly trusts the method annotation. See
Section&#XA0;<a href="#type-refinement-purity">23.4.5</a>.
</li><li class="li-itemize"><span style="font-family:monospace">-AinvariantArrays</span>
Make array subtyping invariant; that is, two arrays are subtypes of one
another only if they have exactly the same element type. By default,
the Checker Framework unsoundly permits covariant array subtyping, just
as Java does. See Section&#XA0;<a href="#invariant-arrays">23.1</a>.
</li><li class="li-itemize"><span style="font-family:monospace">-AconcurrentSemantics</span>
Whether to assume concurrent semantics (field values may change at any
time) or sequential semantics; see Section&#XA0;<a href="#faq-concurrency">30.4.4</a>.
</li></ul><p>Type-checking modes: enable/disable functionality
</p><ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">-Alint</span>
Enable or disable optional checks; see Section&#XA0;<a href="#lint-options">24.6</a>.
</li><li class="li-itemize"><span style="font-family:monospace">-AshowSuppressWarningKeys</span>
With each warning, show all possible keys to suppress that warning;
see Section&#XA0;<a href="#suppresswarnings-command-line">24.3</a>
</li><li class="li-itemize"><span style="font-family:monospace">-AsuggestPureMethods</span>
Suggest methods that could be marked
<a href="api/org/checkerframework/dataflow/qual/SideEffectFree.html"><span style="font-family:monospace">@SideEffectFree</span></a>,
<a href="api/org/checkerframework/dataflow/qual/Deterministic.html"><span style="font-family:monospace">@Deterministic</span></a>,
or <a href="api/org/checkerframework/dataflow/qual/Pure.html"><span style="font-family:monospace">@Pure</span></a>; see
Section&#XA0;<a href="#type-refinement-purity">23.4.5</a>.
</li><li class="li-itemize"><span style="font-family:monospace">-AcheckCastElementType</span>
In a cast, require that parameterized type arguments and array elements
are the same. By default, the Checker Framework unsoundly permits them
to differ, just as Java does. See Section&#XA0;<a href="#covariant-type-parameters">22.1.6</a>
and Section&#XA0;<a href="#invariant-arrays">23.1</a>.
</li><li class="li-itemize"><span style="font-family:monospace">-Awarns</span>
Treat checker errors as warnings. If you use this, you
may wish to also supply <span style="font-family:monospace">-Xmaxwarns 10000</span>, because by default
<span style="font-family:monospace">javac</span> prints at most 100 warnings.
</li></ul><p>Partially-annotated libraries
</p><ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">-Astubs</span>
List of stub files or directories; see Section&#XA0;<a href="#stub-using">27.4.1</a>.
</li><li class="li-itemize"><span style="font-family:monospace">-AstubWarnIfNotFound</span>
Warn if a stub file entry could not be found; see Section&#XA0;<a href="#stub-using">27.4.1</a>.
</li><li class="li-itemize"><span style="font-family:monospace">-AstubWarnIfOverwritesBytecode</span>
Warn if a stub file entry overwrite bytecode information; see
Section&#XA0;<a href="#stub-using">27.4.1</a>.
</li><li class="li-itemize"><span style="font-family:monospace">-AuseDefaultsForUncheckedCode=source</span>
Outside the scope of any relevant
<a href="api/org/checkerframework/framework/qual/AnnotatedFor.html"><span style="font-family:monospace">@AnnotatedFor</span></a> annotation, use unchecked code
default annotations and suppress all type-checking warnings; see
Section&#XA0;<a href="#compiling-libraries">27.3</a>.
</li></ul><p>Inference
</p><ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">-Ainfer</span>
Output suggested annotations for method signatures and fields.
These annotations may reduce the number of type-checking
errors when running type-checking in the future; see
Section&#XA0;<a href="#whole-program-inference">26.2.2</a>.</li></ul><p>Debugging
</p><ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">-AprintAllQualifiers</span>,
<span style="font-family:monospace">-Adetailedmsgtext</span>,
<span style="font-family:monospace">-AprintErrorStack</span>,
<span style="font-family:monospace">-Anomsgtext</span>
Amount of detail in messages; see Section&#XA0;<a href="#debugging-options-detail">28.9.1</a>.</li><li class="li-itemize"><span style="font-family:monospace">-Aignorejdkastub</span>,
<span style="font-family:monospace">-Anocheckjdk</span>
<span style="font-family:monospace">-AstubDebug</span>,
Stub and JDK libraries; see Section&#XA0;<a href="#debugging-options-libraries">28.9.2</a></li><li class="li-itemize"><span style="font-family:monospace">-Afilenames</span>,
<span style="font-family:monospace">-Ashowchecks</span>
Progress tracing; see Section&#XA0;<a href="#debugging-options-progress">28.9.3</a></li><li class="li-itemize"><span style="font-family:monospace">-AoutputArgsToFile</span>
Output the compiler command-line arguments to a file. Useful when the command line is generated and executed by a tool and is not
fully under your control. A standalone command line that can be executed
independently of the tool that generated it can make it easier to reproduce
and debug issues. For example, the command line can be modified to enable
attaching a debugger.
See Section&#XA0;<a href="#debugging-options-output-args">28.9.4</a></li><li class="li-itemize"><span style="font-family:monospace">-Acfgviz</span>,
<span style="font-family:monospace">-Aflowdotdir</span>,
<span style="font-family:monospace">-Averbosecfg</span>,
<span style="font-family:monospace">-AresourceStats</span>
Miscellaneous debugging options; see Section&#XA0;<a href="#debugging-options-misc">28.9.5</a>
</li></ul><p>Some checkers support additional options, which are described in that
checker&#X2019;s manual section.
For example, <span style="font-family:monospace">-Aquals</span> tells
the Subtyping Checker (see Chapter&#XA0;<a href="#subtyping-checker">20</a>) and the Fenum Checker
(see Chapter&#XA0;<a href="#fenum-checker">7</a>) which annotations to check.</p><p>Here are some standard javac command-line options that you may find useful.
Many of them contain the word &#X201C;processor&#X201D;, because in javac jargon, a
checker is an &#X201C;annotation processor&#X201D;.</p><ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">-processor</span> Names the checker to be
run; see Section&#XA0;<a href="#running">2.2</a>
</li><li class="li-itemize"><span style="font-family:monospace">-processorpath</span> Indicates where to search for the
checker; should also contain any qualifiers used by the Subtyping
Checker; see Section&#XA0;<a href="#subtyping-example">20.2</a>
</li><li class="li-itemize"><span style="font-family:monospace">-proc:</span>{<span style="font-family:monospace">none</span>,<span style="font-family:monospace">only</span>} Controls whether checking
happens; <span style="font-family:monospace">-proc:none</span>
means to skip checking; <span style="font-family:monospace">-proc:only</span> means to do only
checking, without any subsequent compilation; see
Section&#XA0;<a href="#checker-auto-discovery">2.2.3</a>
</li><li class="li-itemize"><span style="font-family:monospace">-implicit:class</span> Suppresses warnings about implicitly compiled files
(not named on the command line); see Section&#XA0;<a href="#ant-task">29.2</a>
</li><li class="li-itemize"><span style="font-family:monospace">-XDTA:noannotationsincomments</span> and <span style="font-family:monospace">-XDTA:spacesincomments</span>
to turn off parsing annotation comments and
to turn on parsing annotation comments even when they
contain spaces; applicable only to the Checker Framework compiler;
see Section&#XA0;<a href="#annotations-in-comments">25.2.1</a>
</li><li class="li-itemize"><span style="font-family:monospace">-J</span> Supply an argument to the JVM that is running javac;
for example, <span style="font-family:monospace">-J-Xmx2500m</span> to increase its maximum heap size
</li><li class="li-itemize"><span style="font-family:monospace">-doe</span> To &#X201C;dump on error&#X201D;, that is, output a stack trace
whenever a compiler warning/error is produced. Useful when debugging
the compiler or a checker.
</li></ul>
<!--TOC subsection id="checker-auto-discovery" Checker auto-discovery-->
<h3 id="checker-auto-discovery" class="subsection">2.2.3&#XA0;&#XA0;Checker auto-discovery</h3><!--SEC END --><p>&#X201C;Auto-discovery&#X201D; makes the <span style="font-family:monospace">javac</span> compiler always run a checker
plugin, even if you do not explicitly pass the <span style="font-family:monospace">-processor</span>
command-line option. This can make your command line shorter, and ensures
that your code is checked even if you forget the command-line option.</p><p>
To enable auto-discovery, place a configuration file named
<span style="font-family:monospace">META-INF/services/javax.annotation.processing.Processor</span>
in your classpath. The file contains the names of the checker plugins to
be used, listed one per line. For instance, to run the Nullness Checker and the
Interning Checker automatically, the configuration file should contain:
</p><pre class="verbatim">  org.checkerframework.checker.nullness.NullnessChecker
  org.checkerframework.checker.interning.InterningChecker
</pre><p>You can disable this auto-discovery mechanism by passing the
<span style="font-family:monospace">-proc:none</span> command-line option to <span style="font-family:monospace">javac</span>, which disables all
annotation processing including all pluggable type-checking.</p>
<!--TOC subsection id="shorthand-for-checkers" Shorthand for built-in checkers -->
<h3 id="shorthand-for-checkers" class="subsection">2.2.4&#XA0;&#XA0;Shorthand for built-in checkers </h3><!--SEC END --><p>Ordinarily, the <span style="font-family:monospace">-processor</span> flag expects fully-qualified class names.
For checkers that are packaged with the Checker Framework, the fully-qualified
name can be quite long. Therefore, when running a built-in checker, you may
omit the package name and the <span style="font-family:monospace">Checker</span> suffix.
The following three commands are equivalent:</p><pre>
  javac -processor <span style="font-weight:bold">org.checkerframework.checker.nullness.NullnessChecker</span> MyFile.java
  javac -processor <span style="font-weight:bold">NullnessChecker</span> MyFile.java
  javac -processor <span style="font-weight:bold">nullness</span> MyFile.java
</pre><p>This feature will work when multiple checkers are specified.
For example:</p><pre>
  javac -processor NullnessChecker,RegexChecker MyFile.java
  javac -processor nullness,regex MyFile.java
</pre><p>This feature does not apply to Javac <a href="https://docs.oracle.com/javase/7/docs/technotes/tools/windows/javac.html#commandlineargfile">@argfiles</a>.</p>
<!--TOC section id="checker-guarantees" What the checker guarantees-->
<h2 id="checker-guarantees" class="section">2.3&#XA0;&#XA0;What the checker guarantees</h2><!--SEC END --><p>A checker can guarantee that a particular property holds throughout the
code. For example, the Nullness Checker (Chapter&#XA0;<a href="#nullness-checker">3</a>)
guarantees that every expression whose type is a <a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a> type never
evaluates to null. The Interning Checker (Chapter&#XA0;<a href="#interning-checker">5</a>)
guarantees that every expression whose type is an <a href="api/org/checkerframework/checker/interning/qual/Interned.html"><span style="font-family:monospace">@Interned</span></a> type
evaluates to an interned value. The checker makes its guarantee by
examining every part of your program and verifying that no part of the
program violates the guarantee.</p><p>There are some limitations to the guarantee.</p><ul class="itemize"><li class="li-itemize">A compiler plugin can check only those parts of your program that you run
it on. If you compile some parts of your program without running the
checker, then there is no guarantee that the entire program satisfies the
property being checked. Some examples of un-checked code are:<ul class="itemize"><li class="li-itemize">
Code compiled without the <span style="font-family:monospace">-processor</span> switch, including any
external library supplied as a <span style="font-family:monospace">.class</span> file.
</li><li class="li-itemize">Code compiled with the <span style="font-family:monospace">-AskipUses</span>, <span style="font-family:monospace">-AonlyUses</span>, <span style="font-family:monospace">-AskipDefs</span> or <span style="font-family:monospace">-AonlyDefs</span>
properties (see Section&#XA0;<a href="#suppressing-warnings">24</a>).
</li><li class="li-itemize">Suppression of warnings, such as via the <span style="font-family:monospace">@SuppressWarnings</span>
annotation (see Section&#XA0;<a href="#suppressing-warnings">24</a>).
</li><li class="li-itemize">Native methods (because the implementation is not Java code, it cannot
be checked).
</li></ul><p>In each of these cases, any <em>use</em> of the code is checked &#X2014; for
example, a call to a native method must be compatible with any
annotations on the native method&#X2019;s signature.
However, the annotations on the un-checked code are trusted; there is no
verification that the implementation of the native method satisfies the
annotations.</p></li><li class="li-itemize">The Checker Framework is, by default, unsound in a few places where a
conservative analysis would issue too many false positive warnings.
These are listed in Section&#XA0;<a href="#unsound-by-default">2.2.2</a>.
You can supply a command-line argument to make the Checker Framework
sound for each of these cases.</li><li class="li-itemize">Specific checkers may have other limitations; see their documentation for
details.</li></ul><p>A checker can be useful in finding bugs or in verifying part of a
program, even if the checker is unable to verify the correctness of an
entire program.</p><p>In order to avoid a flood of unhelpful warnings, many of the checkers avoid
issuing the same warning multiple times. For example, in this code:</p><pre class="verbatim">  @Nullable Object x = ...;
  x.toString();                 // warning
  x.toString();                 // no warning
</pre><p>In this case, the second call to <span style="font-family:monospace">toString</span> cannot possibly throw a null
pointer warning &#X2014; <span style="font-family:monospace">x</span> is non-null if control flows to the second
statement.
In other cases, a checker avoids issuing later warnings with the same cause
even when later code in a method might also fail.
This does not
affect the soundness guarantee, but a user may need to examine more
warnings after fixing the first ones identified. (More often, at least in
our experience to date, a single fix corrects all the warnings.)</p><p>If you find that a checker fails to issue a warning that it
should, then please report a bug (see Section&#XA0;<a href="#reporting-bugs">31.2</a>).</p>
<!--TOC section id="tips-about-writing-annotations" Tips about writing annotations-->
<h2 id="tips-about-writing-annotations" class="section">2.4&#XA0;&#XA0;Tips about writing annotations</h2><!--SEC END -->
<!--TOC subsection id="get-started-with-legacy-code" How to get started annotating legacy code-->
<h3 id="get-started-with-legacy-code" class="subsection">2.4.1&#XA0;&#XA0;How to get started annotating legacy code</h3><!--SEC END --><p>Annotating an entire existing program may seem like a daunting task. But,
if you approach it systematically and do a little bit at a time, you will
find that it is manageable.</p><p>Start small, focusing on some specific property that matters to you and
on the most mission-critical or error-prone part of your code.
It is easiest to add annotations if you know the code or the
code contains documentation; you will find that you spend most of your time
understanding the code, and very little time actually writing annotations
or running the checker.</p><p>Start by annotating just part of your program. Be systematic; we recommend
annotating an entire class at a time (not just some of the methods)
so that you don&#X2019;t lose track of your work or redo work. For example,
working class-by-class avoids confusion about whether an unannotated type
means you determined that the default is desirable, or it means you didn&#X2019;t
yet examine that type.
You may find it helpful to start annotating the leaves of the call tree &#X2014;
that is,
start with methods/classes/packages that have few dependencies on other
code or, equivalently, start with code that a lot of your other code
depends on. The reason for this is that it is
easiest to annotate a class if the code it calls has already been
annotated.</p><p>For each class, read its Javadoc. For instance, if you are adding
annotations for the Nullness Checker (Section&#XA0;<a href="#nullness-checker">3</a>), then
you can search the documentation for &#X201C;null&#X201D; and then add <span style="font-family:monospace">@Nullable</span>
anywhere appropriate. For now, just annotate signatures and fields; there is no
need to annotate method bodies. The only reason to even
<em>read</em> the method bodies yet is to determine signature annotations for
undocumented methods &#X2014;
for example, if the method returns null, you know its return type should be
annotated <span style="font-family:monospace">@Nullable</span>, and a parameter that is compared against <span style="font-family:monospace">null</span>
may need to be annotated <span style="font-family:monospace">@Nullable</span>.</p><p>After you have annotated all the signatures, run the checker.
Then, fix bugs in code and add/modify annotations as necessary.
Don&#X2019;t get discouraged if you see many type-checker warnings at first.
Often, adding just a few missing annotations will eliminate many warnings,
and you&#X2019;ll be surprised how fast the process goes overall.</p><p>You may wonder about the effect of adding a given annotation &#X2014; how many
other annotations it will require, or whether it conflicts with other code.
Suppose you have added an annotation to a method parameter. You could
manually examine all callees. A better way can be to save the checker
output before adding the annotation, and to compare it to the checker
output after adding the annotation. This helps you to focus on the
specific consequences of your change.</p><p>Also see Chapter&#XA0;<a href="#suppressing-warnings">24</a>, which tells you what to do when
you are unable to eliminate checker warnings, and
Chapter&#XA0;<a href="#annotating-libraries">27</a>, which tells you how to annotate
libraries that your code uses.</p>
<!--TOC subsection id="tips-local-inference" Do not annotate local variables unless necessary-->
<h3 id="tips-local-inference" class="subsection">2.4.2&#XA0;&#XA0;Do not annotate local variables unless necessary</h3><!--SEC END --><p>The checker infers annotations for local variables (see
Section&#XA0;<a href="#type-refinement">23.4</a>). Usually, you only need to annotate fields
and method signatures. After doing those, you can add annotations inside
method bodies if the checker is unable to infer the correct annotation, if
you need to suppress a warning (see Section&#XA0;<a href="#suppressing-warnings">24</a>),
etc.</p>
<!--TOC subsection id="annotate-normal-behavior" Annotations indicate normal behavior-->
<h3 id="annotate-normal-behavior" class="subsection">2.4.3&#XA0;&#XA0;Annotations indicate normal behavior</h3><!--SEC END --><p>You should use annotations to specify <em>normal</em> behavior. The
annotations indicate all the values that you <em>want</em> to flow to a
reference &#X2014; not every value that might possibly flow there if your
program has a bug.</p><p>Many methods are guaranteed to throw an exception if they are passed <span style="font-family:monospace">null</span>
as an argument. Examples include</p><pre class="verbatim">  java.lang.Double.valueOf(String)
  java.lang.String.contains(CharSequence)
  org.junit.Assert.assertNotNull(Object)
  com.google.common.base.Preconditions.checkNotNull(Object)
</pre><p><a href="api/org/checkerframework/checker/nullness/qual/Nullable.html"><span style="font-family:monospace">@Nullable</span></a> (see Section&#XA0;<a href="#nullness-annotations">3.2</a>)
might seem like a reasonable annotation for the parameter,
for two reasons. First, <span style="font-family:monospace">null</span> is a legal argument with a
well-defined semantics: throw an exception. Second, <span style="font-family:monospace">@Nullable</span>
describes a possible program execution: it might be possible for
<span style="font-family:monospace">null</span> to flow there, if your program has a bug.</p><p>However, it is never useful for a programmer to pass <span style="font-family:monospace">null</span>. It is
the programmer&#X2019;s intention that <span style="font-family:monospace">null</span> never flows there. If
<span style="font-family:monospace">null</span> does flow there, the program will not continue normally
(whether or not it throws a NullPointerException).</p><p>Therefore, you should mark such parameters as
<a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a>, indicating
the intended use of the method. When you use the <span style="font-family:monospace">@NonNull</span>
annotation, the checker is able to issue compile-time warnings about
possible run-time exceptions, which is its purpose. Marking the parameter
as <span style="font-family:monospace">@Nullable</span> would suppress such warnings, which is undesirable.</p><p>If a method can possibly throw exception because its parameter
is <span style="font-family:monospace">null</span>, then that parameter&#X2019;s type should be <span style="font-family:monospace">@NonNull</span>, which
guarantees that the type-checker will issue a warning for every client
use that has the potential to cause an exception. Don&#X2019;t write
<span style="font-family:monospace">@Nullable</span> on the parameter just because there exist some executions that
don&#X2019;t necessarily throw an exception.</p>
<!--TOC subsection id="annotations-are-a-contract" Subclasses must respect superclass annotations-->
<h3 id="annotations-are-a-contract" class="subsection">2.4.4&#XA0;&#XA0;Subclasses must respect superclass annotations</h3><!--SEC END --><p>An annotation indicates a guarantee that a client can depend upon. A subclass
is not permitted to <em>weaken</em> the contract; for example,
if a method accepts <span style="font-family:monospace">null</span> as an argument, then every overriding
definition must also accept <span style="font-family:monospace">null</span>.
A subclass is permitted to <em>strengthen</em> the contract; for example,
if a method does <em>not</em> accept <span style="font-family:monospace">null</span> as an argument, then an
overriding definition is permitted to accept <span style="font-family:monospace">null</span>.</p><p>
As a bad example, consider an erroneous <span style="font-family:monospace">@Nullable</span> annotation in
<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Multiset.java#L129"><span style="font-family:monospace">com/google/common/collect/Multiset.java</span></a>:
</p><pre class="verbatim">101  public interface Multiset&lt;E&gt; extends Collection&lt;E&gt; {
...
122    /**
123     * Adds a number of occurrences of an element to this multiset.
...
129     * @param element the element to add occurrences of; may be {@code null} only
130     *     if explicitly allowed by the implementation
...
137     * @throws NullPointerException if {@code element} is null and this
138     *     implementation does not permit null elements. Note that if {@code
139     *     occurrences} is zero, the implementation may opt to return normally.
140     */
141    int add(@Nullable E element, int occurrences);
</pre><p>There exist implementations of Multiset that permit <span style="font-family:monospace">null</span> elements,
and implementations of Multiset that do not permit <span style="font-family:monospace">null</span> elements. A
client with a variable <span style="font-family:monospace">Multiset ms</span> does not know which variety of
Multiset <span style="font-family:monospace">ms</span> refers to. However, the <span style="font-family:monospace">@Nullable</span> annotation
promises that <span style="font-family:monospace">ms.add(null, 1)</span> is permissible. (Recall from
Section&#XA0;<a href="#annotate-normal-behavior">2.4.3</a> that annotations should indicate
normal behavior.)</p><p>If parameter <span style="font-family:monospace">element</span> on line 141 were to be annotated, the correct
annotation would be <span style="font-family:monospace">@NonNull</span>. Suppose a client has a reference to
same Multiset <span style="font-family:monospace">ms</span>. The only way the client can be sure not to throw an exception is to pass
only non-<span style="font-family:monospace">null</span> elements to <span style="font-family:monospace">ms.add()</span>. A particular class
that implements Multiset could declare <span style="font-family:monospace">add</span> to take a
<span style="font-family:monospace">@Nullable</span> parameter. That still satisfies the original contract.
It strengthens the contract by promising even more: a client with such a
reference can pass any non-<span style="font-family:monospace">null</span> value to <span style="font-family:monospace">add()</span>, and may also
pass <span style="font-family:monospace">null</span>.</p><p><span style="font-weight:bold">However</span>, the best annotation for line 141 is no annotation at all.
The reason is that each implementation of the Multiset interface should
specify its own nullness properties when it specifies the type parameter
for Multiset. For example, two clients could be written as</p><pre class="verbatim">  class MyNullPermittingMultiset implements Multiset&lt;@Nullable Object&gt; { ... }
  class MyNullProhibitingMultiset implements Multiset&lt;@NonNull Object&gt; { ... }
</pre><p>or, more generally, as</p><pre class="verbatim">  class MyNullPermittingMultiset&lt;E extends @Nullable Object&gt; implements Multiset&lt;E&gt; { ... }
  class MyNullProhibitingMultiset&lt;E extends @NonNull Object&gt; implements Multiset&lt;E&gt; { ... }
</pre><p>Then, the specification is more informative, and the Checker Framework is
able to do more precise checking, than if line 141 has an annotation.</p><p>It is a pleasant feature of the Checker Framework that in many cases, no
annotations at all are needed on type parameters such as <span style="font-family:monospace">E</span> in <span style="font-family:monospace">MultiSet</span>.</p>
<!--TOC subsection id="annotations-on-constructor-invocations" Annotations on constructor invocations-->
<h3 id="annotations-on-constructor-invocations" class="subsection">2.4.5&#XA0;&#XA0;Annotations on constructor invocations</h3><!--SEC END --><p>In the checkers distributed with the Checker Framework, an annotation on a
constructor invocation is equivalent to a cast on a constructor result.
That is, the following two expressions have identical semantics: one is
just shorthand for the other.</p><pre class="verbatim">  new @Untainted Date()
  (@Untainted Date) new Date()
</pre><p>However, you should rarely have to use this. The Checker Framework will
determine the qualifier on the result, based on the &#X201C;return value&#X201D;
annotation on the constructor definition. The &#X201C;return value&#X201D; annotation
appears before the constructor name, for example:</p><pre class="verbatim">  class MyClass {
    @Untainted MyClass() { ... }
  }
</pre><p>In general, you should only use an annotation on a constructor invocation
when you know that the cast is
guaranteed to succeed.</p>
<!--TOC subsection id="handling-warnings" What to do if a checker issues a warning about your code-->
<h3 id="handling-warnings" class="subsection">2.4.6&#XA0;&#XA0;What to do if a checker issues a warning about your code</h3><!--SEC END --><p>When you first run a type-checker on your code, it is likely to issue
warnings or errors. For each warning, try to understand why the checker
issues it. (If you think the warning is wrong, then formulate an argument
about why your code is actually correct; also see Section&#XA0;<a href="#common-problems-typechecking">31.1.2</a>.) For example, if you are using the
<a href="#nullness-checker">Nullness Checker</a>
(Chapter&#XA0;<a href="#nullness-checker">3</a>), try to understand why it cannot prove
that no null pointer exception ever occurs. There are three general
reasons, listed below. You will need to
examine your code, and possibly write test cases, to understand the reason.</p><ol class="enumerate" type=1><li class="li-enumerate">
There is a bug in your code, such as an actual possible null dereference.
Fix your code to prevent that crash.</li><li class="li-enumerate">There is a weakness in the annotations. Improve the annotations.
For example, continuing the Nullness Checker example, if a particular
variable is annotated as <a href="api/org/checkerframework/checker/nullness/qual/Nullable.html"><span style="font-family:monospace">@Nullable</span></a> but it
actually never contains <span style="font-family:monospace">null</span> at run time, then change the annotation to
<a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a>. The weakness might be in the
annotations in your code, or in the annotations in a library that your code
calls. Another possible problem is that a library is unannotated (see
Chapter&#XA0;<a href="#annotating-libraries">27</a>).</li><li class="li-enumerate">There is a weakness in the type-checker. Then your code is safe &#X2014; it never
suffers the error at run time &#X2014; but the checker cannot prove this
fact. The checker is not omniscient, and some
tricky coding paradigms are beyond its analysis capabilities. In this
case, you should suppress the warning; see
Chapter&#XA0;<a href="#suppressing-warnings">24</a>. (Alternatively, if the weakness is
a bug in the checker, then please report the bug; see
Chapter&#XA0;<a href="#reporting-bugs">31.2</a>.)
</li></ol><p>If you have trouble understanding a Checker Framework warning message, you
can search for its text in this manual.
Oftentimes there is an explanation of what to do.</p><p>Also see Chapter&#XA0;<a href="#troubleshooting">31</a>, Troubleshooting.</p><hr>
<!--TOC chapter id="nullness-checker" Nullness Checker-->
<h1 id="nullness-checker" class="chapter">Chapter&#XA0;3&#XA0;&#XA0;Nullness Checker</h1><!--SEC END --><p>If the Nullness Checker issues no warnings for a given program, then
running that program will never throw a null pointer exception. This
guarantee enables a programmer to prevent errors from occurring when a
program is run. See Section&#XA0;<a href="#nullness-checks">3.1</a> for more details about
the guarantee and what is checked.</p><p>The most important annotations supported by the Nullness Checker are
<a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a> and
<a href="api/org/checkerframework/checker/nullness/qual/Nullable.html"><span style="font-family:monospace">@Nullable</span></a>.
<a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a> is rarely written, because it is
the default. All of the annotations are explained in
Section&#XA0;<a href="#nullness-annotations">3.2</a>.</p><p>To run the Nullness Checker, supply the
<span style="font-family:monospace">-processor org.checkerframework.checker.nullness.NullnessChecker</span>
command-line option to javac. For
examples, see Section&#XA0;<a href="#nullness-example">3.5</a>.</p><p>The NullnessChecker is actually an ensemble of three pluggable
type-checkers that work together: the Nullness Checker proper (which is the
main focus of this chapter), the Initialization Checker
(Section&#XA0;<a href="#initialization-checker">3.8</a>), and the Map Key Checker
(Chapter&#XA0;<a href="#map-key-checker">4</a>).
Their type hierarchies are completely independent, but they work together
to provide precise nullness checking.</p>
<!--TOC section id="nullness-checks" What the Nullness Checker checks-->
<h2 id="nullness-checks" class="section">3.1&#XA0;&#XA0;What the Nullness Checker checks</h2><!--SEC END --><p>The checker issues a warning in these cases:</p><ol class="enumerate" type=1><li class="li-enumerate">When an expression of non-<a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a> type
is dereferenced, because it might cause a null pointer exception.
Dereferences occur not only when a field is accessed, but when an array
is indexed, an exception is thrown, a lock is taken in a synchronized
block, and more. For a complete description of all checks performed by
the Nullness Checker, see the Javadoc for
<a href="api/org/checkerframework/checker/nullness/NullnessVisitor.html"><span style="font-family:monospace">NullnessVisitor</span></a>.</li><li class="li-enumerate">When an expression of <a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a> type
might become null, because it
is a misuse of the type: the null value could flow to a dereference that
the checker does not warn about.<p>As a special case of an of <a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a>
type becoming null, the checker also warns whenever a field of
<a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a> type is not initialized in a
constructor. Also see the discussion of the <span style="font-family:monospace">-Alint=uninitialized</span>
command-line option below.</p></li></ol><p>This example illustrates the programming errors that the checker detects:</p><pre class="verbatim">  @Nullable Object   obj;  // might be null
  @NonNull  Object nnobj;  // never null
  ...
  obj.toString()         // checker warning:  dereference might cause null pointer exception
  nnobj = obj;           // checker warning:  nnobj may become null
  if (nnobj == null)     // checker warning:  redundant test
</pre><p>Parameter passing and return values are checked analogously to assignments.</p><p>The Nullness Checker also checks the correctness, and correct use, of
rawness annotations for checking initialization (see
Section&#XA0;<a href="#initialization-rawness-checker">3.8.7</a>) and of map key annotations (see
Chapter&#XA0;<a href="#map-key-checker">4</a>).</p><p>The checker performs additional checks if certain <span style="font-family:monospace">-Alint</span>
command-line options are provided. (See
Section&#XA0;<a href="#alint">24.6</a> for more details about the <span style="font-family:monospace">-Alint</span>
command-line option.)</p><p><a id="lint-nulltest-section"></a><a id="lint-uninitialized-section"></a>
</p><ol class="enumerate" type=1><li class="li-enumerate">
<a id="lint-nulltest-item"></a>If you supply the <span style="font-family:monospace">-Alint=redundantNullComparison</span> command-line option, then the
checker warns when a null check is performed against a value that is
guaranteed to be non-null, as in <span style="font-family:monospace">("m" == null)</span>. Such a check is
unnecessary and might indicate a programmer error or misunderstanding.
The lint option is disabled by default because sometimes such checks are
part of ordinary defensive programming.</li><li class="li-enumerate"><a id="lint-uninitialized-item"></a>If you supply the <span style="font-family:monospace">-Alint=uninitialized</span> command-line option, then
the checker warns if a constructor fails to initialize any field,
including <a href="api/org/checkerframework/checker/nullness/qual/Nullable.html"><span style="font-family:monospace">@Nullable</span></a> types and primitive
types. Such a warning is unrelated to whether your code might throw a
null pointer exception. However, you might want to enable this warning
because it is better code style to supply an explicit initializer, even
if there is a default value such as <span style="font-family:monospace">0</span> or <span style="font-family:monospace">false</span>.
This command-line option does not affect the Nullness Checker&#X2019;s tests
that fields of <a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a> type are
initialized &#X2014; such initialization is mandatory, not optional.</li><li class="li-enumerate"><a id="lint-nonnullarraycomponents-item"></a>If you supply the <span style="font-family:monospace">-Alint=forbidnonnullarraycomponents</span> command-line
option, then the checker warns if it encounters an array creation
with a non-null component type.
See Section&#XA0;<a href="#nullness-arrays">3.3.4</a> for a discussion.
</li></ol>
<!--TOC section id="nullness-annotations" Nullness annotations-->
<h2 id="nullness-annotations" class="section">3.2&#XA0;&#XA0;Nullness annotations</h2><!--SEC END --><p>The Nullness Checker uses three separate type hierarchies: one for nullness,
one for rawness (Section&#XA0;<a href="#initialization-rawness-checker">3.8.7</a>),
and one for map keys (Chapter&#XA0;<a href="#map-key-checker">4</a>)
The Nullness Checker has four varieties of annotations: nullness
type qualifiers, nullness method annotations, rawness type qualifiers, and
map key type
qualifiers.</p>
<!--TOC subsection id="nullness-qualifiers" Nullness qualifiers-->
<h3 id="nullness-qualifiers" class="subsection">3.2.1&#XA0;&#XA0;Nullness qualifiers</h3><!--SEC END --><p>The nullness hierarchy contains these qualifiers:</p><dl class="description"><dt class="dt-description"><a href="api/org/checkerframework/checker/nullness/qual/Nullable.html"><span style="font-weight:bold"><span style="font-family:monospace">@Nullable</span></span></a></dt><dd class="dd-description">
indicates a type that includes the null value. For example, the type <span style="font-family:monospace">Boolean</span>
is nullable: a variable of type <span style="font-family:monospace">Boolean</span> always has one of the
values <span style="font-family:monospace">TRUE</span>, <span style="font-family:monospace">FALSE</span>, or <span style="font-family:monospace">null</span>.</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-weight:bold"><span style="font-family:monospace">@NonNull</span></span></a></dt><dd class="dd-description">
indicates a type that does not include the null value. The type
<span style="font-family:monospace">boolean</span> is non-null; a variable of type <span style="font-family:monospace">boolean</span> always has
one of the values <span style="font-family:monospace">true</span> or <span style="font-family:monospace">false</span>. The type <span style="font-family:monospace">@NonNull
Boolean</span> is also non-null: a variable of type <span style="font-family:monospace">@NonNull Boolean</span>
always has one of the values <span style="font-family:monospace">TRUE</span> or <span style="font-family:monospace">FALSE</span> &#X2014; never
<span style="font-family:monospace">null</span>. Dereferencing an expression of non-null type can never cause
a null pointer exception.<p>The <span style="font-family:monospace">@NonNull</span> annotation is rarely written in a program, because it is
the default (see Section&#XA0;<a href="#null-defaults">3.3.2</a>).</p></dd><dt class="dt-description"><a href="api/org/checkerframework/checker/nullness/qual/PolyNull.html"><span style="font-weight:bold"><span style="font-family:monospace">@PolyNull</span></span></a></dt><dd class="dd-description">
indicates qualifier polymorphism. For a description of
<a href="api/org/checkerframework/checker/nullness/qual/PolyNull.html"><span style="font-family:monospace">@PolyNull</span></a>, see
Section&#XA0;<a href="#qualifier-polymorphism">22.2</a>.</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/nullness/qual/MonotonicNonNull.html"><span style="font-weight:bold"><span style="font-family:monospace">@MonotonicNonNull</span></span></a></dt><dd class="dd-description">
indicates a reference that may be <span style="font-family:monospace">null</span>, but if it ever becomes
non-<span style="font-family:monospace">null</span>, then it never becomes <span style="font-family:monospace">null</span> again. This is
appropriate for lazily-initialized fields, among other uses. When the
variable is read, its type is treated as
<a href="api/org/checkerframework/checker/nullness/qual/Nullable.html"><span style="font-family:monospace">@Nullable</span></a>, but when the variable is
assigned, its type is treated as
<a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a>.<p>
Because the Nullness Checker works intraprocedurally (it analyzes one
method at a time), when a <span style="font-family:monospace">MonotonicNonNull</span> field is first read within a
method, the field cannot be assumed to be non-null. The benefit of
MonotonicNonNull over Nullable is its different interaction with
flow-sensitive type qualifier refinement (Section&#XA0;<a href="#type-refinement">23.4</a>).
After a check of a MonotonicNonNull
field, all subsequent accesses <em>within that method</em> can be assumed
to be NonNull, even after arbitrary external method calls that have
access to the given field.
</p><p>It is permitted to initialize a MonotonicNonNull field to null, but the
field may not be assigned to null anywhere else in the program. If you
supply the <span style="font-family:monospace">noInitForMonotonicNonNull</span> lint flag (for example, supply
<span style="font-family:monospace">-Alint=noInitForMonotonicNonNull</span> on the command line), then
@MonotonicNonNull fields are not allowed to have initializers.</p><p>Use of <span style="font-family:monospace">@MonotonicNonNull</span> on a static field is a code smell: it may
indicate poor design. You should consider whether it is possible to make
the field a member field that is set in the constructor.</p></dd></dl><p>Figure&#XA0;<a href="#fig-nullness-hierarchy">3.1</a> shows part of the type hierarchy for the
Nullness type system.
(The annotations exist only at compile time; at run time, Java has no
multiple inheritance.)</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<img src="nullness.svg">
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 3.1: Partial type hierarchy for the Nullness type system.
Java&#X2019;s <span style="font-family:monospace">Object</span> is expressed as <span style="font-family:monospace">@Nullable Object</span>. Programmers can omit
most type qualifiers, because the default annotation
(Section&#XA0;<a href="#null-defaults">3.3.2</a>) is usually correct.
The Nullness Checker verifies three type hierarchies: this one for
nullness, one for initialization (Section&#XA0;<a href="#initialization-checker">3.8</a>),
and one for map keys (Chapter&#XA0;<a href="#map-key-checker">4</a>).</td></tr>
</table></div>
<a id="fig-nullness-hierarchy"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote>
<!--TOC subsection id="nullness-method-annotations" Nullness method annotations-->
<h3 id="nullness-method-annotations" class="subsection">3.2.2&#XA0;&#XA0;Nullness method annotations</h3><!--SEC END --><p>The Nullness Checker supports several annotations that specify method
behavior. These are declaration annotations, not type annotations: they
apply to the method itself rather than to some particular type.</p><dl class="description"><dt class="dt-description"><a href="api/org/checkerframework/checker/nullness/qual/RequiresNonNull.html"><span style="font-weight:bold"><span style="font-family:monospace">@RequiresNonNull</span></span></a></dt><dd class="dd-description">
indicates a method precondition: The annotated method expects the
specified variables (typically field references) to be non-null when the
method is invoked.</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/nullness/qual/EnsuresNonNull.html"><span style="font-weight:bold"><span style="font-family:monospace">@EnsuresNonNull</span></span></a></dt><dd class="dd-description">
</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/nullness/qual/EnsuresNonNullIf.html"><span style="font-weight:bold"><span style="font-family:monospace">@EnsuresNonNullIf</span></span></a></dt><dd class="dd-description">
indicates a method postcondition. With <span style="font-family:monospace">@EnsuresNonNull</span>, the given
expressions are non-null after the method returns; this is useful for a
method that initializes a field, for example. With
<span style="font-family:monospace">@EnsuresNonNullIf</span>, if the annotated
method returns the given boolean value (true or false), then the given
expressions are non-null. See Section&#XA0;<a href="#conditional-nullness">3.3.3</a> and the
Javadoc for examples of their use.</dd></dl>
<!--TOC subsection id="initialization-qualifiers-overview" Initialization qualifiers-->
<h3 id="initialization-qualifiers-overview" class="subsection">3.2.3&#XA0;&#XA0;Initialization qualifiers</h3><!--SEC END --><p>The Nullness Checker invokes an Initialization Checker, whose annotations indicate whether
an object is fully initialized &#X2014; that is, whether all of its fields have
been assigned.</p><dl class="description"><dt class="dt-description">
<a href="api/org/checkerframework/checker/initialization/qual/Initialized.html"><span style="font-weight:bold"><span style="font-family:monospace">@Initialized</span></span></a></dt><dd class="dd-description">
</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/initialization/qual/UnknownInitialization.html"><span style="font-weight:bold"><span style="font-family:monospace">@UnknownInitialization</span></span></a></dt><dd class="dd-description">
</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/initialization/qual/UnderInitialization.html"><span style="font-weight:bold"><span style="font-family:monospace">@UnderInitialization</span></span></a></dt><dd class="dd-description">
</dd></dl><p>Use of these annotations can help you to type-check more
code. Figure&#XA0;<a href="#fig-initialization-hierarchy">3.3</a> shows its type hierarchy. For
details, see Section&#XA0;<a href="#initialization-checker">3.8</a>.</p><p>A slightly simpler variant, called the Rawness Initialization Checker, is also available:</p><dl class="description"><dt class="dt-description">
<a href="api/org/checkerframework/checker/nullness/qual/Raw.html"><span style="font-weight:bold"><span style="font-family:monospace">@Raw</span></span></a></dt><dd class="dd-description">
</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/nullness/qual/NonRaw.html"><span style="font-weight:bold"><span style="font-family:monospace">@NonRaw</span></span></a></dt><dd class="dd-description">
</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/nullness/qual/PolyRaw.html"><span style="font-weight:bold"><span style="font-family:monospace">@PolyRaw</span></span></a></dt><dd class="dd-description">
</dd></dl><p>Figure&#XA0;<a href="#fig-rawness-hierarchy">3.7</a> shows its type hierarchy. For
details, see Section&#XA0;<a href="#initialization-rawness-checker">3.8.7</a>.</p>
<!--TOC subsection id="map-key-qualifiers" Map key qualifiers-->
<h3 id="map-key-qualifiers" class="subsection">3.2.4&#XA0;&#XA0;Map key qualifiers</h3><!--SEC END --><dl class="description"><dt class="dt-description">
<a href="api/org/checkerframework/checker/nullness/qual/KeyFor.html"><span style="font-weight:bold"><span style="font-family:monospace">@KeyFor</span></span></a></dt><dd class="dd-description">
</dd></dl><p>
indicates that a value is a key for a given map &#X2014; that is, indicates
whether <span style="font-family:monospace">map.containsKey(value)</span> would evaluate to <span style="font-family:monospace">true</span>.</p><p>This annotation is checked by a Map Key Checker
(Chapter&#XA0;<a href="#map-key-checker">4</a>) that the Nullness Checker
invokes. The <a href="api/org/checkerframework/checker/nullness/qual/KeyFor.html"><span style="font-family:monospace">@KeyFor</span></a> annotation enables
the Nullness Checker to treat calls to
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Map.html#get-java.lang.Object-"><span style="font-family:monospace">Map.get</span></a>
precisely rather than assuming it may always return null. In particular,
a call <span style="font-family:monospace">mymap.get(mykey)</span> returns a non-<span style="font-family:monospace">null</span> value if two conditions
are satisfied:
</p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">mymap</span>&#X2019;s values are all non-<span style="font-family:monospace">null</span>; that is, <span style="font-family:monospace">mymap</span> was
declared as <span style="font-family:monospace">Map&lt;</span><span style="font-family:monospace"><em>KeyType</em></span><span style="font-family:monospace">, @NonNull </span><span style="font-family:monospace"><em>ValueType</em></span><span style="font-family:monospace">&gt;</span>. Note
that <span style="font-family:monospace">@NonNull</span> is the default type, so it need not be written explicitly.
</li><li class="li-enumerate"><span style="font-family:monospace">mykey</span> is a key in <span style="font-family:monospace">mymap</span>; that is, <span style="font-family:monospace">mymap.containsKey(mykey)</span>
returns <span style="font-family:monospace">true</span>. You express this fact to the Nullness Checker by
declaring <span style="font-family:monospace">mykey</span> as <span style="font-family:monospace">@KeyFor("mymap") </span><span style="font-family:monospace"><em>KeyType</em></span><span style="font-family:monospace"> mykey</span>. For a
local variable, you generally do not need to write the
<span style="font-family:monospace">@KeyFor("mymap")</span> type qualifier, because it can be inferred.
</li></ol><p>
If either of these two conditions is violated, then <span style="font-family:monospace">mymap.get(mykey)</span> has
the possibility of returning <span style="font-family:monospace">null</span>.</p>
<!--TOC section id="writing-nullness-annotations" Writing nullness annotations-->
<h2 id="writing-nullness-annotations" class="section">3.3&#XA0;&#XA0;Writing nullness annotations</h2><!--SEC END -->
<!--TOC subsection id="nullness-implicit-qualifiers" Implicit qualifiers-->
<h3 id="nullness-implicit-qualifiers" class="subsection">3.3.1&#XA0;&#XA0;Implicit qualifiers</h3><!--SEC END --><p>As described in Section&#XA0;<a href="#effective-qualifier">23.3</a>, the Nullness Checker
adds implicit qualifiers, reducing the number of annotations that must
appear in your code.
For example, enum types are implicitly non-null, so you never need to write
<span style="font-family:monospace">@NonNull MyEnumType</span>.</p><p>For a complete description of all implicit nullness qualifiers, see the
Javadoc for <a href="api/org/checkerframework/checker/nullness/NullnessAnnotatedTypeFactory.html"><span style="font-family:monospace">NullnessAnnotatedTypeFactory</span></a>.</p>
<!--TOC subsection id="null-defaults" Default annotation-->
<h3 id="null-defaults" class="subsection">3.3.2&#XA0;&#XA0;Default annotation</h3><!--SEC END --><p>Unannotated references are treated as if they had a default annotation.
The standard defaulting rule is CLIMB-to-top, described in
Section&#XA0;<a href="#climb-to-top">23.3.2</a>. Its effect is to default all types to
<span style="font-family:monospace">@NonNull</span>, except that <span style="font-family:monospace">@Nullable</span> is used for casts, locals,
instanceof, and implicit bounds. A user can choose a different defaulting
rule.</p>
<!--TOC subsection id="conditional-nullness" Conditional nullness-->
<h3 id="conditional-nullness" class="subsection">3.3.3&#XA0;&#XA0;Conditional nullness</h3><!--SEC END --><p>The Nullness Checker supports a form of conditional nullness types, via the
<a href="api/org/checkerframework/checker/nullness/qual/EnsuresNonNullIf.html"><span style="font-family:monospace">@EnsuresNonNullIf</span></a> method annotations.
The annotation on a method declares that some expressions are non-null, if
the method returns true (false, respectively).</p><p>Consider <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><span style="font-family:monospace">java.lang.Class</span></a>.
Method
<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getComponentType--"><span style="font-family:monospace">Class.getComponentType()</span></a>
may return null, but it is specified to return a non-null value if
<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#isArray--"><span style="font-family:monospace">Class.isArray()</span></a> is
true.
You could declare this relationship in the following way (this particular
example is already
done for you in the annotated JDK that comes with the Checker Framework):</p><pre class="verbatim">  class Class {
    @EnsuresNonNullIf(expression="getComponentType()", result=true)
    public native boolean isArray();

    public native @Nullable Class&lt;?&gt; getComponentType();
  }
</pre><p>A client that checks that a <span style="font-family:monospace">Class</span> reference is indeed that of an array,
can then de-reference the result of <span style="font-family:monospace">Class.getComponentType</span> safely
without any nullness check. The Checker Framework source code itself
uses such a pattern:</p><pre class="verbatim">    if (clazz.isArray()) {
      // no possible null dereference on the following line
      TypeMirror componentType = typeFromClass(clazz.getComponentType());
      ...
    }
</pre><p>Another example is <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Queue.html#peek--"><span style="font-family:monospace">Queue.peek</span></a>
and <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Queue.html#poll--"><span style="font-family:monospace">Queue.poll</span></a>, which return
non-null if <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#isEmpty--"><span style="font-family:monospace">isEmpty</span></a>
returns false.</p><p>The argument to <span style="font-family:monospace">@EnsuresNonNullIf</span> is a Java expression, including method calls
(as shown above), method formal parameters, fields, etc.; for details, see
Section&#XA0;<a href="#java-expressions-as-arguments">23.5</a>.
More examples of the use of these annotations appear in the Javadoc for
<a href="api/org/checkerframework/checker/nullness/qual/EnsuresNonNullIf.html"><span style="font-family:monospace">@EnsuresNonNullIf</span></a>.</p>
<!--TOC subsection id="nullness-arrays" Nullness and arrays-->
<h3 id="nullness-arrays" class="subsection">3.3.4&#XA0;&#XA0;Nullness and arrays</h3><!--SEC END --><p>The components of a newly created object of reference type are all
null. Only after initialization can the array actually be considered
to contain non-null components.
Therefore, the following is not allowed:</p><pre class="verbatim">  @NonNull Object [] oa = new @NonNull Object[10]; // error
</pre><p>Instead, one creates a nullable or lazy-nonnull array, initializes
each component, and then assigns the result to a non-null array:</p><pre class="verbatim">  @MonotonicNonNull Object [] temp = new @MonotonicNonNull Object[10];
  for (int i = 0; i &lt; temp.length; ++i) {
    temp[i] = new Object();
  }
  @SuppressWarnings("nullness") // temp array is now fully initialized
  @NonNull Object [] oa = temp;
</pre><p>Note that the checker is currently not powerful enough to ensure that
each array component was initialized. Therefore, the last assignment
needs to be trusted: that is, a programmer must verify that it is safe,
then write a <span style="font-family:monospace">@SuppressWarnings</span> annotation.</p><p>You need to supply the <span style="font-family:monospace">-Alint=forbidnonnullarraycomponents</span>
command-line option to enable this behavior.
For backwards-compatibility reasons, the default behavior is currently
to unsoundly allow non-null array components.
</p>
<!--TOC subsection id="nullness-runtime-checks" Run-time checks for nullness-->
<h3 id="nullness-runtime-checks" class="subsection">3.3.5&#XA0;&#XA0;Run-time checks for nullness</h3><!--SEC END --><p>When you perform a run-time check for nullness, such as <span style="font-family:monospace">if (x != null)
...</span>, then the Nullness Checker refines the type of <span style="font-family:monospace">x</span> to
<span style="font-family:monospace">@NonNull</span>. The refinement lasts until the end of the scope of the test
or until <span style="font-family:monospace">x</span> may be side-effected. For more details, see
Section&#XA0;<a href="#type-refinement">23.4</a>.</p>
<!--TOC subsection id="nullness-additional-details" Additional details-->
<h3 id="nullness-additional-details" class="subsection">3.3.6&#XA0;&#XA0;Additional details</h3><!--SEC END --><p>The Nullness Checker does some special checks in certain circumstances, in
order to soundly reduce the number of warnings that it produces.</p><p>For example, a call to
<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getProperty-java.lang.String-"><span style="font-family:monospace">System.getProperty(String)</span></a>
can return null in general, but it will not return null if the argument is
one of the built-in-keys listed in the documentation of
<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getProperties--"><span style="font-family:monospace">System.getProperties()</span></a>.
The Nullness Checker is aware of this fact, so you do not have to suppress
a warning for a call like <span style="font-family:monospace">System.getProperty("line.separator")</span>. The
warning is still issued for code like this:</p><pre class="verbatim">  final String s = "line.separator";
  nonNullvar = System.getProperty(s);
</pre><p>though that case could be handled as well, if desired.
(Suppression of the warning is, strictly speaking, not sound, because a
library that your code calls, or your code itself, could perversely change
the system properties; the Nullness Checker assumes this bizarre coding
pattern does not happen.)</p>
<!--TOC subsection id="nullness-inference" Inference of <span style="font-family:monospace">@NonNull</span> and <span style="font-family:monospace">@Nullable</span> annotations-->
<h3 id="nullness-inference" class="subsection">3.3.7&#XA0;&#XA0;Inference of <span style="font-family:monospace">@NonNull</span> and <span style="font-family:monospace">@Nullable</span> annotations</h3><!--SEC END --><p>It can be tedious to write annotations in your code. Tools exist that
can automatically infer annotations and insert them in your source code.
(This is different than type qualifier refinement for local variables
(Section&#XA0;<a href="#type-refinement">23.4</a>), which infers a more specific type for
local variables and uses them during type-checking but does not insert them
in your source code. Type qualifier refinement is always enabled, no
matter how annotations on signatures got inserted in your source code.)</p><p>Your choice of tool depends on what default annotation (see
Section&#XA0;<a href="#null-defaults">3.3.2</a>) your code uses. You only need one of these tools.</p><ul class="itemize"><li class="li-itemize">Inference of <a href="api/org/checkerframework/checker/nullness/qual/Nullable.html"><span style="font-family:monospace">@Nullable</span></a>:
If your code uses the standard CLIMB-to-top default (Section&#XA0;<a href="#climb-to-top">23.3.2</a>) or
the NonNull default, then use the
<a href="http://plse.cs.washington.edu/daikon/download/doc/daikon.html#AnnotateNullable">AnnotateNullable</a>
tool of the <a href="http://plse.cs.washington.edu/daikon/">Daikon invariant
detector</a>.</li><li class="li-itemize">Inference of <a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a>:
If your code uses the Nullable default, use one of these tools:
<ul class="itemize"><li class="li-itemize">
<a href="http://www.juliasoft.com/">Julia analyzer</a>,
</li><li class="li-itemize"><a href="http://nit.gforge.inria.fr">Nit: Nullability Inference Tool</a>,
</li><li class="li-itemize"><a href="http://jastadd.org/jastadd-tutorial-examples/non-null-types-for-java/">Non-null
checker and inferencer</a> of the <a href="http://jastadd.org/">JastAdd
Extensible Compiler</a>.
</li></ul></li></ul>
<!--TOC section id="suppressing-warnings-nullness" Suppressing nullness warnings-->
<h2 id="suppressing-warnings-nullness" class="section">3.4&#XA0;&#XA0;Suppressing nullness warnings</h2><!--SEC END --><p>When the Nullness Checker reports a warning, it&#X2019;s best to change the code
or its annotations, to eliminate the warning. Alternately, you can
suppress the warning, which does not change the code but prevents the
Nullness Checker from reporting this particular warning to you.</p><p>
The Checker Framework supplies several ways to suppress warnings, most
notably the <span style="font-family:monospace">@SuppressWarnings("nullness")</span> annotation (see
Section&#XA0;<a href="#suppressing-warnings">24</a>). An example use is
</p><pre class="verbatim">    // might return null
    @Nullable Object getObject(...) { ... }

    void myMethod() {
      @SuppressWarnings("nullness") // with argument x, getObject always returns a non-null value
      @NonNull Object o2 = getObject(x);
</pre><p>The Nullness Checker supports an additional warning suppression key,
<span style="font-family:monospace">nullness:generic.argument</span>.
Use of <span style="font-family:monospace">@SuppressWarnings("nullness:generic.argument")</span> causes the Nullness
Checker to suppress warnings related to misuse of generic type
arguments. One use for this key is when a class is declared to take only
<span style="font-family:monospace">@NonNull</span> type arguments, but you want to instantiate the class with a
<span style="font-family:monospace">@Nullable</span> type argument, as in <span style="font-family:monospace">List&lt;@Nullable Object&gt;</span>. For a more
complete explanation of this example, see
Section&#XA0;<a href="#faq-list-map-nonnull-typeargs">30.6.1</a>.</p><p>The Nullness Checker also permits you to use assertions or method calls to
suppress warnings; see below.</p>
<!--TOC subsection id="suppressing-warnings-with-assertions" Suppressing warnings with assertions and method calls-->
<h3 id="suppressing-warnings-with-assertions" class="subsection">3.4.1&#XA0;&#XA0;Suppressing warnings with assertions and method calls</h3><!--SEC END --><p>Occasionally, it is inconvenient or
verbose to use the <span style="font-family:monospace">@SuppressWarnings</span> annotation. For example, Java does
not permit annotations such as <span style="font-family:monospace">@SuppressWarnings</span> to appear on statements.
In such cases, you can use the <span style="font-family:monospace">@AssumeAssertion</span> string in
an <span style="font-family:monospace">assert</span> message (see Section&#XA0;<a href="#assumeassertion">24.2</a>).</p><p>If you need to suppress a warning within an expression, then
sometimes writing an assertion is not convenient. In such a case,
you can suppress warnings by writing a call to the
<a href="api/org/checkerframework/checker/nullness/NullnessUtils.html#castNonNull-T-"><span style="font-family:monospace">NullnessUtils.castNonNull</span></a> method.
The rest of this section discusses the <span style="font-family:monospace">castNonNull</span> method.</p><p>The Nullness Checker considers both the return value, and also the
argument, to be non-null after the <span style="font-family:monospace">castNonNull</span> method call.
The Nullness Checker issues no warnings in any of the following
code:</p><pre class="verbatim">  // One way to use castNonNull as a cast:
  @NonNull String s = castNonNull(possiblyNull1);

  // Another way to use castNonNull as a cast:
  castNonNull(possiblyNull2).toString();

  // It is possible, but not recommmended, to use castNonNull as a statement:
  // (It would be better to write an assert statement with @AssumeAssertion
  // in its message, instead.)
  castNonNull(possiblyNull3);
  possiblyNull3.toString();
</pre><p>The <span style="font-family:monospace">castNonNull</span> method throws <span style="font-family:monospace">AssertionError</span> if Java assertions are enabled and
the argument is <span style="font-family:monospace">null</span>. However, it is not intended for general defensive
programming; see Section&#XA0;<a href="#defensive-programming">24.2.1</a>.</p><p>A potential disadvantage of using the <span style="font-family:monospace">castNonNull</span> method is that your
code becomes dependent on the Checker Framework at run time as well as at
compile time. You can avoid this by copying the implementation of
<span style="font-family:monospace">castNonNull</span> into your own code, and possibly renaming it if you do not
like the name. Be sure to retain the documentation that indicates that
your copy is intended for use only to suppress warnings and not for
defensive programming. See Section&#XA0;<a href="#defensive-programming">24.2.1</a> for an
explanation of the distinction.</p><p>
The Nullness Checker introduces a new method, rather than re-using an
existing method such as <span style="font-family:monospace">org.junit.Assert.assertNotNull(Object)</span> or
<span style="font-family:monospace">com.google.common.base.Preconditions.checkNotNull(Object)</span>. Those
methods are commonly used for defensive programming, so it is impossible to
know the programmer&#X2019;s intent when writing them. Therefore, it is important to
have a method call that is used only for warning suppression. See
Section&#XA0;<a href="#defensive-programming">24.2.1</a> for a discussion of
the distinction between warning suppression and defensive programming.
</p>
<!--TOC section id="nullness-example" Examples-->
<h2 id="nullness-example" class="section">3.5&#XA0;&#XA0;Examples</h2><!--SEC END -->
<!--TOC subsection id="nullness-tiny-examples" Tiny examples-->
<h3 id="nullness-tiny-examples" class="subsection">3.5.1&#XA0;&#XA0;Tiny examples</h3><!--SEC END --><p>To try the Nullness Checker on a source file that uses the <a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a> qualifier,
use the following command (where <span style="font-family:monospace">javac</span> is the Checker Framework compiler that
is distributed with the Checker Framework):</p><pre class="verbatim">  javac -processor org.checkerframework.checker.nullness.NullnessChecker examples/NullnessExample.java
</pre><p>Compilation will complete without warnings.</p><p>To see the checker warn about incorrect usage of annotations (and therefore the
possibility of a null pointer exception at run time), use the following command:</p><div style="font-size:small;">
<pre class="verbatim">  javac -processor org.checkerframework.checker.nullness.NullnessChecker examples/NullnessExampleWithWarnings.java
</pre></div><p>The compiler will issue two warnings regarding violation of the semantics of
<a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a>.
</p>
<!--TOC subsection id="nullness-annotated-library" Example annotated source code-->
<h3 id="nullness-annotated-library" class="subsection">3.5.2&#XA0;&#XA0;Example annotated source code</h3><!--SEC END --><p>Some libraries that are annotated with nullness qualifiers are:</p><ul class="itemize"><li class="li-itemize">
The Nullness Checker itself.</li><li class="li-itemize">The
<a href="http://mernst.github.io/plume-lib/">Plume-lib library</a>.
Run the command <span style="font-family:monospace">make check-nullness</span>.</li><li class="li-itemize">The
<a href="http://plse.cs.washington.edu/daikon/">Daikon invariant detector</a>.
Run the command <span style="font-family:monospace">make check-nullness</span>.</li></ul>
<!--TOC section id="nullness-getting-started" Tips for getting started-->
<h2 id="nullness-getting-started" class="section">3.6&#XA0;&#XA0;Tips for getting started</h2><!--SEC END --><p>Here are some tips about getting started using the Nullness Checker on a
legacy codebase. For more generic advice (not specific to the Nullness
Checker), see Section&#XA0;<a href="#get-started-with-legacy-code">2.4.1</a>.</p><p>Your goal is to add <a href="api/org/checkerframework/checker/nullness/qual/Nullable.html"><span style="font-family:monospace">@Nullable</span></a> annotations
to the types of any variables that can be null. (The default is to assume
that a variable is non-null unless it has a <span style="font-family:monospace">@Nullable</span> annotation.)
Then, you will run the Nullness Checker. Each of its errors indicates
either a possible null pointer exception, or a wrong/missing annotation.
When there are no more warnings from the checker, you are done!</p><p>We recommend that you start by searching the code for occurrences of
<span style="font-family:monospace">null</span> in the following locations; when you find one, write the
corresponding annotation:</p><ul class="itemize"><li class="li-itemize">
in Javadoc: add <span style="font-family:monospace">@Nullable</span> annotations to method signatures (parameters and return types).
</li><li class="li-itemize"><span style="font-family:monospace">return null</span>: add a <span style="font-family:monospace">@Nullable</span> annotation to the return type
of the given method.
</li><li class="li-itemize"><span style="font-family:monospace"><em>param</em></span><span style="font-family:monospace"> == null</span>: when a formal parameter is compared to
<span style="font-family:monospace">null</span>, then in most cases you can add a <span style="font-family:monospace">@Nullable</span> annotation
to the formal parameter&#X2019;s type
</li><li class="li-itemize"><span style="font-family:monospace"><em>TypeName</em></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><em>field</em></span><span style="font-family:monospace"> = null;</span>: when a field is initialized to
<span style="font-family:monospace">null</span> in its declaration, then it needs either a
<a href="api/org/checkerframework/checker/nullness/qual/Nullable.html"><span style="font-family:monospace">@Nullable</span></a> or a
<a href="api/org/checkerframework/checker/nullness/qual/MonotonicNonNull.html"><span style="font-family:monospace">@MonotonicNonNull</span></a> annotation. If the field
is always set to a non-null value in the constructor, then you can just
change the declaration to <span style="font-family:monospace"><em>Type</em></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><em>field</em></span><span style="font-family:monospace">;</span>, without an
initializer, and write no type annotation (because the default is
<span style="font-family:monospace">@NonNull</span>).
</li><li class="li-itemize">declarations of <span style="font-family:monospace">contains</span>, <span style="font-family:monospace">containsKey</span>, <span style="font-family:monospace">containsValue</span>, <span style="font-family:monospace">equals</span>,
<span style="font-family:monospace">get</span>, <span style="font-family:monospace">indexOf</span>, <span style="font-family:monospace">lastIndexOf</span>, and <span style="font-family:monospace">remove</span> (with <span style="font-family:monospace">Object</span> as the
argument type):
change the argument type to <span style="font-family:monospace">@Nullable Object</span>; for <span style="font-family:monospace">remove</span>, also change
the return type to <span style="font-family:monospace">@Nullable Object</span>.
</li></ul><p>You should ignore all other occurrences of <span style="font-family:monospace">null</span> within a method
body. In particular, you (almost) never need to annotate local variables.</p><p>Only after this step should you run <span style="font-family:monospace">ant</span> to invoke
the Nullness Checker. The reason is that it is quicker to search for
places to change than to repeatedly run the checker and fix the errors it
tells you about, one at a time.</p><p>Here are some other tips:
</p><ul class="itemize"><li class="li-itemize">

In any file where you write an annotation such as <span style="font-family:monospace">@Nullable</span>,
don&#X2019;t forget to add <span style="font-family:monospace">import org.checkerframework.checker.nullness.qual.*;</span>.

</li><li class="li-itemize">To indicate an array that can be null, write, for example: <span style="font-family:monospace">int
@Nullable []</span>. <br>
 By contrast, <span style="font-family:monospace">@Nullable Object []</span> means a non-null array that
contains possibly-null objects.
</li><li class="li-itemize">If you know that a particular variable is definitely not null, but the
Nullness Checker estimates that the variable might be null, then you can
make the Nullness Checker trust your judgment by writing
an assertion (see Section&#XA0;<a href="#assumeassertion">24.2</a>):
<pre class="verbatim">assert var != null : "@AssumeAssertion(nullness)";
</pre></li><li class="li-itemize">To indicate that a routine returns the same value every time it is
called, use <a href="api/org/checkerframework/dataflow/qual/Pure.html"><span style="font-family:monospace">@Pure</span></a> (see Section&#XA0;<a href="#type-refinement-purity">23.4.5</a>).
</li><li class="li-itemize">To indicate a method precondition (a contract stating the conditions
under which a client is allowed to call it), you can use annotations
such as <a href="api/org/checkerframework/checker/nullness/qual/RequiresNonNull.html"><span style="font-family:monospace">@RequiresNonNull</span></a> (see Section&#XA0;<a href="#nullness-method-annotations">3.2.2</a>).
</li></ul>
<!--TOC section id="nullness-related-work" Other tools for nullness checking-->
<h2 id="nullness-related-work" class="section">3.7&#XA0;&#XA0;Other tools for nullness checking</h2><!--SEC END --><p>The Checker Framework&#X2019;s nullness annotations are similar to annotations used
in IntelliJ IDEA, FindBugs, JML, the JSR 305 proposal, NetBeans, and other tools. Also
see Section&#XA0;<a href="#other-tools">31.5</a> for a comparison to other tools.</p><p>You might prefer to use the Checker Framework because it has a more
powerful analysis that can warn you about more null pointer errors in your
code.</p><p>If your code is already annotated with a different nullness
annotation, you can reuse that effort. The Checker Framework comes with
cleanroom re-implementations of annotations from other tools. It treats
them exactly as if you had written the corresponding annotation from the
Nullness Checker, as described in Figure&#XA0;<a href="#fig-nullness-refactoring">3.2</a>.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;android.annotation.NonNull&#XA0; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;android.support.annotation.NonNull&#XA0; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;com.sun.istack.internal.NotNull&#XA0; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;edu.umd.cs.findbugs.annotations.NonNull&#XA0; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;javax.annotation.Nonnull&#XA0; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;javax.validation.constraints.NotNull&#XA0; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;lombok.NonNull&#XA0; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;org.eclipse.jdt.annotation.NonNull&#XA0; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;org.eclipse.jgit.annotations.NonNull&#XA0; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;org.jetbrains.annotations.NotNull&#XA0; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;org.jmlspecs.annotation.NonNull&#XA0; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;org.netbeans.api.annotations.common.NonNull&#XA0; </td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >&#X21D2;
&#XA0;org.checkerframework.checker.nullness.qual.NonNull&#XA0;
</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;android.annotation.Nullable&#XA0; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;android.support.annotation.Nullable&#XA0; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;com.sun.istack.internal.Nullable&#XA0; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;edu.umd.cs.findbugs.annotations.Nullable&#XA0; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;edu.umd.cs.findbugs.annotations.CheckForNull&#XA0; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;edu.umd.cs.findbugs.annotations.UnknownNullness&#XA0; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;javax.annotation.Nullable&#XA0; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;javax.annotation.CheckForNull&#XA0; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;org.eclipse.jdt.annotation.Nullable&#XA0; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;org.eclipse.jgit.annotations.Nullable&#XA0; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;org.jetbrains.annotations.Nullable&#XA0; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;org.jmlspecs.annotation.Nullable&#XA0; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;org.netbeans.api.annotations.common.NullAllowed&#XA0; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;org.netbeans.api.annotations.common.CheckForNull&#XA0; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;org.netbeans.api.annotations.common.NullUnknown&#XA0; </td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >&#X21D2;
&#XA0;org.checkerframework.checker.nullness.qual.Nullable&#XA0;
</td></tr>
</table>
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 3.2: Correspondence between other nullness annotations and the
Checker Framework&#X2019;s annotations.</td></tr>
</table></div>
<a id="fig-nullness-refactoring"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p>Alternately, the Checker Framework can process those other annotations (as
well as its own, if they also appear in your program). The Checker
Framework has its own definition of the annotations on the left side of
Figure&#XA0;<a href="#fig-nullness-refactoring">3.2</a>, so that they can be used as type
qualifiers. The Checker Framework interprets them according to the right
side of Figure&#XA0;<a href="#fig-nullness-refactoring">3.2</a>.</p><p>The Checker Framework may issue more or fewer errors than another tool.
This is expected, since each tool uses a different analysis. Remember that
the Checker Framework aims at soundness: it aims to never miss a possible
null dereference, while at the same time limiting false reports. Also,
note FindBugs&#X2019;s non-standard meaning for <span style="font-family:monospace">@Nullable</span>
(Section&#XA0;<a href="#findbugs-nullable">3.7.2</a>).</p><p>Java permits you to import at most one annotation of a given name. For
example, if you use both <span style="font-family:monospace">android.annotation.NonNull</span> and
<span style="font-family:monospace">lombok.NonNull</span> in your source code, then you must write at least one of
them in fully-qualified form, as <span style="font-family:monospace">@android.annotation.NonNull</span> rather than
as <span style="font-family:monospace">@NonNull</span>.</p><p>Note that some older tools interpret array and varargs declarations
inconsistently with the Java specification. For example, they might
interpret <span style="font-family:monospace">@NonNull Object []</span> as &#X201C;non-null array of objects&#X201D;, rather
than as &#X201C;array of non-null objects&#X201D; which is the correct Java
interpretation. Such an interpretation is unfortunate and confusing. See
Section&#XA0;<a href="#faq-array-syntax-meaning">30.5.3</a> for some more details about this
issue.</p>
<!--TOC subsection id="choosing-nullness-tool" Which tool is right for you?-->
<h3 id="choosing-nullness-tool" class="subsection">3.7.1&#XA0;&#XA0;Which tool is right for you?</h3><!--SEC END --><p>Different tools are appropriate in different circumstances. Here is a
brief comparison with FindBugs, but similar points apply to other tools.</p><p>The Checker Framework has a more powerful nullness analysis; FindBugs misses
some real
errors. However, FindBugs does not require you to annotate your code as
thoroughly as the Checker Framework does. Depending on the importance of
your code, you may desire: no nullness checking, the cursory checking of
FindBugs, or the thorough checking of the Checker Framework. You might
even want to ensure that both tools run, for example if your coworkers or
some other organization are still using FindBugs. If you know that you
will eventually want to use the Checker Framework, there is no point using
FindBugs first; it is easier to go straight to using the Checker Framework.</p><p>FindBugs can find other errors in addition to nullness errors; here
we focus on its nullness checks. Even if you use FindBugs for its other
features, you may want to use the Checker Framework for analyses that can
be expressed as pluggable type-checking, such as detecting nullness errors.</p><p>Regardless of whether you wish to use the FindBugs nullness analysis, you
may continue running all of the other FindBugs analyses at the same time as
the Checker Framework; there are no interactions among them.</p><p>If FindBugs (or any other tool) discovers a nullness error that the Checker
Framework does not, please report it to us (see
Section&#XA0;<a href="#reporting-bugs">31.2</a>) so that we can enhance the Checker Framework.</p>
<!--TOC subsection id="findbugs-nullable" Incompatibility note about FindBugs <span style="font-family:monospace">@Nullable</span>-->
<h3 id="findbugs-nullable" class="subsection">3.7.2&#XA0;&#XA0;Incompatibility note about FindBugs <span style="font-family:monospace">@Nullable</span></h3><!--SEC END --><p>FindBugs has a non-standard definition of <span style="font-family:monospace">@Nullable</span>. FindBugs&#X2019;s treatment is not
documented in its own
<a href="http://findbugs.sourceforge.net/api/edu/umd/cs/findbugs/annotations/Nullable.html">Javadoc</a>;
it is different from the definition of <span style="font-family:monospace">@Nullable</span> in every other tool for
nullness analysis; it means the same thing as <span style="font-family:monospace">@NonNull</span> when applied to a
formal parameter; and it invariably surprises programmers. Thus, FindBugs&#X2019;s
<span style="font-family:monospace">@Nullable</span> is detrimental rather than useful as documentation.
In practice, your best bet is to not rely on FindBugs for nullness analysis,
even if you find FindBugs useful for other purposes.</p><p>You can skip the rest of this section unless you wish to learn more details.</p><p>FindBugs suppresses all warnings at uses of a <span style="font-family:monospace">@Nullable</span> variable.
(You have to use <span style="font-family:monospace">@CheckForNull</span> to
indicate a nullable variable that FindBugs should check.) For example:</p><pre class="verbatim">     // declare getObject() to possibly return null
     @Nullable Object getObject() { ... }

     void myMethod() {
       @Nullable Object o = getObject();
       // FindBugs issues no warning about calling toString on a possibly-null reference!
       o.toString();
     }
</pre><p>The Checker Framework does not emulate this non-standard behavior of
FindBugs, even if the code uses FindBugs annotations.</p><p>With FindBugs, you annotate a declaration, which suppresses checking at
<em>all</em> client uses, even the places that you want to check.
It is better to suppress warnings at only the specific client uses
where the value is known to be non-null; the Checker Framework supports
this, if you write <span style="font-family:monospace">@SuppressWarnings</span> at the client uses.
The Checker Framework also supports suppressing checking at all client uses,
by writing a <span style="font-family:monospace">@SuppressWarnings</span> annotation at the declaration site.
Thus, the Checker Framework supports both use cases, whereas FindBugs
supports only one and gives the programmer less flexibility.</p><p>In general, the Checker Framework will issue more warnings than FindBugs,
and some of them may be about real bugs in your program.
See Section&#XA0;<a href="#suppressing-warnings-nullness">3.4</a> for information about
suppressing nullness warnings.</p><p>(FindBugs made a poor choice of names. The choice of names should make a
clear distinction between annotations that specify whether a reference is
null, and annotations that suppress false warnings. The choice of names
should also have been consistent for other tools, and intuitively clear to
programmers. The FindBugs choices make the FindBugs annotations less
helpful to people, and much less useful for other tools. As a separate
issue, the FindBugs
analysis is also very imprecise. For type-related analyses, it is best to
stay away from the FindBugs nullness annotations, and use a more capable
tool like the Checker Framework.)</p>
<!--TOC subsection id="nullness-vs-optional" Relationship to <span style="font-family:monospace">Optional&lt;T&gt;</span>-->
<h3 id="nullness-vs-optional" class="subsection">3.7.3&#XA0;&#XA0;Relationship to <span style="font-family:monospace">Optional&lt;T&gt;</span></h3><!--SEC END --><p>Many null pointer exceptions occur because the programmer forgets to check
whether a reference is null before dereferencing it. Java 8&#X2019;s
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html"><span style="font-family:monospace">Optional&lt;T&gt;</span></a>
class provides a partial solution: you cannot
dereference the contained value without calling the <span style="font-family:monospace">get</span> method.</p><p>However, the use of <span style="font-family:monospace">Optional</span> for this purpose is unsatisfactory.
First, it adds syntactic complexity, making your code longer and harder to
read. (The <span style="font-family:monospace">Optional</span> class provides some operations, such as <span style="font-family:monospace">map</span>
and <span style="font-family:monospace">orElse</span>, that you would otherwise have to write; without these its
code bloat would be even worse.) Second, there is no guarantee that the
programmer remembers to call <span style="font-family:monospace">isPresent</span> before calling <span style="font-family:monospace">get</span>. Thus, use
of <span style="font-family:monospace">Optional</span> doesn&#X2019;t solve the underlying problem &#X2014; it merely
converts a <span style="font-family:monospace">NullPointerException</span> into a
<span style="font-family:monospace">NoSuchElementException</span> exception, and in either case your code
crashes.</p><p>The Nullness Checker does not suffer these limitations. It works with
existing code and types, it ensures that you check for null wherever
necessary, and it infers when the check for null is not necessary based on
previous statements in the method.</p>
<!--TOC section id="initialization-checker" Initialization Checker-->
<h2 id="initialization-checker" class="section">3.8&#XA0;&#XA0;Initialization Checker</h2><!--SEC END --><p>Every object&#X2019;s fields start out as null. By the time the constructor
finishes executing, the <span style="font-family:monospace">@NonNull</span> fields have been set to a different
value. Your code can suffer a NullPointerException when using a
<span style="font-family:monospace">@NonNull</span> field, if your code uses the field during initialization.
The Nullness Checker prevents this problem by warning you anytime that you
may be accessing an uninitialized field. This check is useful because it
prevents errors in your code. However, the analysis can be confusing to
understand. If you wish to disable the initialization checks, pass the
command-line argument <span style="font-family:monospace">-AsuppressWarnings=uninitialized</span> when running the
Nullness Checker. You will no longer get a guarantee of no null pointer
exceptions, but you can still use the Nullness Checker to find most of the
null pointer problems in your code.</p><p>An object is partially initialized from the time that its constructor starts until its constructor
finishes. This is relevant to the Nullness Checker because while the
constructor is executing &#X2014; that is, before initialization completes &#X2014;
a <span style="font-family:monospace">@NonNull</span>
field may be observed to be null, until that field is set. In
particular, the Nullness Checker issues a warning for code like this:</p><pre class="verbatim">  public class MyClass {
    private @NonNull Object f;
    public MyClass(int x, int y) {
      // Error because constructor contains no assignment to this.f.
      // By the time the constructor exits, f must be initialized to a non-null value.
    }
    public MyClass(int x) {
      // Error because this.f is accessed before f is initialized.
      // At the beginning of the constructor's execution, accessing this.f
      // yields null, even though field f has a non-null type.
      this.f.toString();
    }
    public MyClass(int x, int y, int z) {
      m();
    }
    public void m() {
      // Error because this.f is accessed before f is initialized,
      // even though the access is not in a constructor.
      // When m is called from the constructor, accessing f yields null,
      // even though field f has a non-null type.
      this.f.toString();
    }
</pre><p>When a field <span style="font-family:monospace">f</span> is declared with a <a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a>
type, then code can depend on the fact that the field is not <span style="font-family:monospace">null</span>.
However, this guarantee does not hold for a partially-initialized object.</p><p>The Nullness Checker uses three annotations to indicate whether an object
is initialized (all its <span style="font-family:monospace">@NonNull</span> fields have been assigned), under
initialization (its constructor is currently executing), or its
initialization state is unknown.</p><p>These distinctions are mostly relevant within the constructor, or for
references to <span style="font-family:monospace">this</span> that escape the constructor (say, by being stored
in a field or passed to a method before initialization is complete).
Use of initialization annotations is rare in most code.</p><p>The most common use for the <span style="font-family:monospace">@UnderInitialization</span> annotation is for a
helper routine that is called by constructor. For example:</p><pre class="verbatim">  class MyClass {
    Object field1;
    Object field2;
    Object field3;

    public MyClass(String arg1) {
      this.field1 = arg1;
      init_other_fields();
    }

    // A helper routine that initializes all the fields other than field1.
    @EnsuresNonNull({"field2", "field3"})
    private void init_other_fields(@UnderInitialization(MyClass.class) MyClass this) {
      field2 = new Object();
      field3 = new Object();
    }
  }
</pre><p>For compatibility with Java 6 and 7, you can write the receiver
parameter in comments (see Section&#XA0;<a href="#annotations-in-comments">25.2.1</a>):
</p><pre class="verbatim">    private void init_other_fields(/*&gt;&gt;&gt;@UnderInitialization(MyClass.class) MyClass this*/) {
</pre>
<!--TOC subsection id="initialization-qualifiers" Initialization qualifiers-->
<h3 id="initialization-qualifiers" class="subsection">3.8.1&#XA0;&#XA0;Initialization qualifiers</h3><!--SEC END --><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<img src="initialization.svg">
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 3.3: Partial type hierarchy for the Initialization type system.
<span style="font-family:monospace">@UnknownInitialization</span> and <span style="font-family:monospace">@UnderInitialization</span> each take an
optional parameter indicating how far initialization has proceeded, and
the right side of the figure illustrates its type hierarchy in more detail.</td></tr>
</table></div>
<a id="fig-initialization-hierarchy"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p>The initialization hierarchy is shown in Figure&#XA0;<a href="#fig-initialization-hierarchy">3.3</a>.
The initialization hierarchy contains these qualifiers:</p><dl class="description"><dt class="dt-description"><a href="api/org/checkerframework/checker/initialization/qual/Initialized.html"><span style="font-weight:bold"><span style="font-family:monospace">@Initialized</span></span></a></dt><dd class="dd-description">
indicates a type that contains a fully-initialized object. <span style="font-family:monospace">Initialized</span>
is the default, so there is little need for a programmer to write this
explicitly.</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/initialization/qual/UnknownInitialization.html"><span style="font-weight:bold"><span style="font-family:monospace">@UnknownInitialization</span></span></a></dt><dd class="dd-description">
indicates a type that may contain a partially-initialized object. In a
partially-initialized object, fields that are annotated as
<a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a> may be null because the field
has not yet been assigned.<p><span style="font-family:monospace">@UnknownInitialization</span> takes a parameter that is the class the object
is definitely initialized up to. For instance, the type
<span style="font-family:monospace">@UnknownInitialization(Foo.class)</span> denotes an object in which every
fields declared in <span style="font-family:monospace">Foo</span> or its superclasses is initialized, but other
fields might not be.
Just <span style="font-family:monospace">@UnknownInitialization</span> is equivalent to
<span style="font-family:monospace">@UnknownInitialization(Object.class)</span>.</p></dd><dt class="dt-description"><a href="api/org/checkerframework/checker/initialization/qual/UnderInitialization.html"><span style="font-weight:bold"><span style="font-family:monospace">@UnderInitialization</span></span></a></dt><dd class="dd-description">
indicates a type that contains a partially-initialized object that is
under initialization &#X2014; that is, its constructor is currently executing.
It is otherwise the same as <span style="font-family:monospace">@UnknownInitialization</span>. Within the
constructor, <span style="font-family:monospace">this</span> has
<a href="api/org/checkerframework/checker/initialization/qual/UnderInitialization.html"><span style="font-family:monospace">@UnderInitialization</span></a> type until
all the <span style="font-family:monospace">@NonNull</span> fields have been assigned.</dd></dl><p>A partially-initialized object (<span style="font-family:monospace">this</span> in a constructor) may be
passed to a helper method or stored in a variable; if so, the method
receiver, or the field, would have to be annotated as
<span style="font-family:monospace">@UnknownInitialization</span> or as <span style="font-family:monospace">@UnderInitialization</span>.</p><p>If a reference has
<span style="font-family:monospace">@UnknownInitialization</span> or <span style="font-family:monospace">@UnderInitialization</span> type, then all of its <span style="font-family:monospace">@NonNull</span> fields are treated as
<a href="api/org/checkerframework/checker/nullness/qual/MonotonicNonNull.html"><span style="font-family:monospace">@MonotonicNonNull</span></a>: when read, they are
treated as being <a href="api/org/checkerframework/checker/nullness/qual/Nullable.html"><span style="font-family:monospace">@Nullable</span></a>, but when
written, they are treated as being
<a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a>.</p><p>
The initialization hierarchy is orthogonal to the nullness hierarchy. It
is legal for a reference to be <span style="font-family:monospace">@NonNull @UnderInitialization</span>, <span style="font-family:monospace">@Nullable @UnderInitialization</span>,
<span style="font-family:monospace">@NonNull @Initialized</span>, or <span style="font-family:monospace">@Nullable @Initialized</span>. The nullness hierarchy tells
you about the reference itself: might the reference be null? The initialization
hierarchy tells you about the <span style="font-family:monospace">@NonNull</span> fields in the referred-to object:
might those fields be temporarily null in contravention of their
type annotation?
Figure&#XA0;<a href="#fig-initialization-examples">3.4</a> contains some examples.
</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >Declarations</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >Expression</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >Expression&#X2019;s nullness type, or checker error </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><div class="minipage">
<pre class="verbatim">class C {
  @NonNull Object f;
  @Nullable Object g;
  ...
}
</pre></div></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@NonNull @Initialized C a;</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">a</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@NonNull</span> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">a.f</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@NonNull</span> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">a.g</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@Nullable</span> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@NonNull @UnderInitialization C b;</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">b</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@NonNull</span> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">b.f</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@MonotonicNonNull</span> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">b.g</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@Nullable</span> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@Nullable @Initialized C c;</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">c</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@Nullable</span> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">c.f</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >error: deref of nullable </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">c.g</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >error: deref of nullable </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@Nullable @UnderInitialization C d;</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">d</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@Nullable</span> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">d.f</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >error: deref of nullable </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">d.g</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >error: deref of nullable </td></tr>
</table>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 3.4: Examples of the interaction between nullness and initialization.
Declarations are shown at the left for reference, but the focus of the
table is the expressions and their nullness type or error.</td></tr>
</table></div>
<a id="fig-initialization-examples"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote>
<!--TOC subsection id="becoming-initialized" How an object becomes initialized-->
<h3 id="becoming-initialized" class="subsection">3.8.2&#XA0;&#XA0;How an object becomes initialized</h3><!--SEC END --><p>Within the constructor,
<span style="font-family:monospace">this</span> starts out with <a href="api/org/checkerframework/checker/initialization/qual/UnderInitialization.html"><span style="font-family:monospace">@UnderInitialization</span></a> type.
As soon as all of the <a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a> fields
have been initialized, then <span style="font-family:monospace">this</span> is treated as initialized.
(See
Section&#XA0;<a href="#becoming-initialized-clarification">3.8.3</a> for a slight clarification of
this rule.)</p><p>The Initialization Checker issues an error if the constructor fails to initialize
any <span style="font-family:monospace">@NonNull</span> field. This ensures that the object is in a legal (initialized)
state by the time that the constructor exits.
This is different than Java&#X2019;s test for definite assignment (see
<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-16.html">JLS ch.16</a>),
which does not apply to fields (except blank final ones, defined in
<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.12.4">JLS &#XA7;4.12.4</a>) because fields
have a default value of null.</p><p>All <span style="font-family:monospace">@NonNull</span> fields must either have a
default in the field declaration, or be assigned in the constructor or in a
helper method that the constructor calls. If
your code initializes (some) fields in a helper method, you will need to
annotate the helper method with an annotation such as
<a href="api/org/checkerframework/checker/nullness/qual/EnsuresNonNull.html"><span style="font-family:monospace">@EnsuresNonNull</span></a><span style="font-family:monospace">({"field1", "field2"})</span>
for all the fields that the helper method assigns.
It&#X2019;s a bit odd, but you use that same annotation, <span style="font-family:monospace">@EnsuresNonNull</span>,
to indicate that a primitive field has its value set in a helper method,
which is relevant when you supply the <span style="font-family:monospace">-Alint=uninitialized</span>
command-line option (see Section&#XA0;<a href="#lint-uninitialized-section">3.1</a>).</p>
<!--TOC subsection id="partial-initialization" Partial initialization-->
<h3 id="partial-initialization" class="subsection">3.8.3&#XA0;&#XA0;Partial initialization</h3><!--SEC END --><p>So far, we have discussed initialization as if it is an all-or-nothing property:
an object is non-initialized until initialization completes, and then it is initialized. The full truth is a bit more complex: during the
initialization process an object can be partially initialized, and as the
object&#X2019;s superclass constructors complete, its initialization status is updated. The
Initialization Checker lets you express such properties when necessary.</p><p>Consider a simple example:</p><pre class="verbatim">class A {
  Object a;
  A() {
    a = new Object();
  }
}
class B extends A {
  Object b;
  B() {
    super();
    b = new Object();
  }
}
</pre><p>Consider what happens during execution of <span style="font-family:monospace">new B()</span>.</p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">B</span>&#X2019;s constructor begins to execute. At this point, neither the
fields of <span style="font-family:monospace">A</span> nor those of <span style="font-family:monospace">B</span> have been initialized yet.
</li><li class="li-enumerate"><span style="font-family:monospace">B</span>&#X2019;s constructor calls <span style="font-family:monospace">A</span>&#X2019;s constructor, which begins to execute.
No fields of <span style="font-family:monospace">A</span> nor of <span style="font-family:monospace">B</span> have been initialized yet.
</li><li class="li-enumerate"><span style="font-family:monospace">A</span>&#X2019;s constructor completes. Now, all the fields of <span style="font-family:monospace">A</span> have been
initialized, and their invariants (such as that field <span style="font-family:monospace">a</span> is non-null) can be
depended on. However, because <span style="font-family:monospace">B</span>&#X2019;s constructor has not yet completed
executing, the object being constructed is not yet fully initialized.
When treated as an <span style="font-family:monospace">A</span> (e.g., if only the <span style="font-family:monospace">A</span> fields are accessed), the
object is initialized, but when treated as a <span style="font-family:monospace">B</span>, the object
is still non-initialized.
</li><li class="li-enumerate"><span style="font-family:monospace">B</span>&#X2019;s constructor completes. The object is initialized when treated
as an <span style="font-family:monospace">A</span> or a <span style="font-family:monospace">B</span>. (And, the object is fully initialized
if <span style="font-family:monospace">B</span>&#X2019;s constructor was invoked via a <span style="font-family:monospace">new B()</span>. But the type system
cannot assume that &#X2013; there might be a <span style="font-family:monospace">class C extends B {
... }</span>, and <span style="font-family:monospace">B</span>&#X2019;s constructor might have been invoked from that.)
</li></ol><p>At any moment during initialization, the superclasses of a given class
can be divided into those that have completed initialization and those that
have not yet completed initialization. More precisely, at any moment there
is a point in the class hierarchy such that all the classes above that
point are fully initialized, and all those below it are not yet
initialized. As initialization proceeds, this dividing line between the
initialized and uninitialized classes moves down the type hierarchy.</p><p>The Nullness Checker lets you indicate where the dividing line is between
the initialized and non-initialized classes.
The <span style="font-family:monospace">@UnderInitialization(</span><span style="font-family:monospace"><em>classliteral</em></span><span style="font-family:monospace">)</span>
indicates the first class that is known to be fully initialized.
When you write <a href="api/org/checkerframework/checker/initialization/qual/UnderInitialization.html"><span style="font-family:monospace">@UnderInitialization</span></a><span style="font-family:monospace">(OtherClass.class) MyClass x;</span>, that
means that variable <span style="font-family:monospace">x</span> is initialized for <span style="font-family:monospace">OtherClass</span> and its
superclasses, and <span style="font-family:monospace">x</span> is (possibly) uninitialized for <span style="font-family:monospace">MyClass</span> and all subclasses.</p><p><a id="becoming-initialized-clarification"></a></p><p>We can now state a clarification of Section&#XA0;<a href="#becoming-initialized">3.8.2</a>&#X2019;s rule
for an object becoming initialized.
As soon as all of the <a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a> fields
in class <span style="font-style:italic">C</span> have been initialized, then <span style="font-family:monospace">this</span> is treated as
<a href="api/org/checkerframework/checker/initialization/qual/UnderInitialization.html"><span style="font-family:monospace">@UnderInitialization</span></a><span style="font-family:monospace">(</span><span style="font-family:monospace"><em>C</em></span><span style="font-family:monospace">)</span>, rather than
treated as simply
<a href="api/org/checkerframework/checker/initialization/qual/Initialized.html"><span style="font-family:monospace">@Initialized</span></a>.</p><p>The example above lists 4 moments during construction. At those moments,
the type of the object being constructed is:</p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">@UnderInitialization B</span>
</li><li class="li-enumerate"><span style="font-family:monospace">@UnderInitialization A</span>
</li><li class="li-enumerate"><span style="font-family:monospace">@UnderInitialization(A.class) A</span>
</li><li class="li-enumerate"><span style="font-family:monospace">@UnderInitialization(B.class) B</span>
</li></ol>
<!--TOC subsection id="circular-initialization" Initialization of circular data structures-->
<h3 id="circular-initialization" class="subsection">3.8.4&#XA0;&#XA0;Initialization of circular data structures</h3><!--SEC END --><p>There is one final aspect of the initialization type system to be considered:
the rules governing reading and writing to objects that are currently under
initialization (both reading from fields of objects under initialization, as well as
writing objects under initialization to fields).
By default, only fully-initialized objects can be stored in a
field of another object. If this was the only option, then it would not be
possible to create circular data structures (such as a doubly-linked list) where
fields have a <a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a> type.
However, the annotation
<a href="api/org/checkerframework/checker/initialization/qual/NotOnlyInitialized.html"><span style="font-family:monospace">@NotOnlyInitialized</span></a> can be used to
indicate that a field can store objects that are currently under initialization.
In this case, the rules for reading and writing to that field become a little
bit more interesting, to soundly support circular structures.</p><p>The rules for reading from a
<a href="api/org/checkerframework/checker/initialization/qual/NotOnlyInitialized.html"><span style="font-family:monospace">@NotOnlyInitialized</span></a> field
are summarized in Figure&#XA0;<a href="#fig-init-read-field">3.5</a>. Essentially, nothing is
known about the initialization status of the value returned unless the receiver
was <a href="api/org/checkerframework/checker/initialization/qual/Initialized.html"><span style="font-family:monospace">@Initialized</span></a>.</p><blockquote class="figure"><div class="center"><div class="center"><hr style="width:80%;height:2"></div>
<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">x.f</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">f</span> is <span style="font-family:monospace">@NonNull</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">f</span> is <span style="font-family:monospace">@Nullable</span></td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">x</span> is <span style="font-family:monospace">@Initialized</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@Initialized @NonNull</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@Initialized @Nullable</span> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">x</span> is <span style="font-family:monospace">@UnderInitialization</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@UnknownInitialization @Nullable</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@UnknownInitialization @Nullable</span> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">x</span> is <span style="font-family:monospace">@UnknownInitialization</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@UnknownInitialization @Nullable</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@UnknownInitialization @Nullable</span> </td></tr>
</table>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 3.5: Initialization rules for reading a <a href="api/org/checkerframework/checker/initialization/qual/NotOnlyInitialized.html"><span style="font-family:monospace">@NotOnlyInitialized</span></a> field <span style="font-family:monospace">f</span>.</td></tr>
</table></div>
<a id="fig-init-read-field"></a>
<div class="center"><hr style="width:80%;height:2"></div></div></blockquote><p>Similarly, Figure&#XA0;<a href="#fig-init-write-field">3.6</a> shows under which conditions
an assignment <span style="font-family:monospace">x.f = y</span> is allowed for a
<a href="api/org/checkerframework/checker/initialization/qual/NotOnlyInitialized.html"><span style="font-family:monospace">@NotOnlyInitialized</span></a> field <span style="font-family:monospace">f</span>.
If the receiver <span style="font-family:monospace">x</span> is
<a href="api/org/checkerframework/checker/initialization/qual/UnderInitialization.html"><span style="font-family:monospace">@UnderInitialization</span></a>, then any
<span style="font-family:monospace">y</span> can be of any initialization state. If <span style="font-family:monospace">y</span> is known to be
fully initialized, then any receiver is allowed. All other assignments
are disallowed.</p><blockquote class="figure"><div class="center"><div class="center"><hr style="width:80%;height:2"></div>
<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">x.f = y</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">y</span> is <span style="font-family:monospace">@Initialized</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">y</span> is <span style="font-family:monospace">@UnderInitialization</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">y</span> is <span style="font-family:monospace">@UnknownInitialization</span></td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">x</span> is <span style="font-family:monospace">@Initialized</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" >yes</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >no</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >no </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">x</span> is <span style="font-family:monospace">@UnderInitialization</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" >yes</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >yes</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >yes </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">x</span> is <span style="font-family:monospace">@UnknownInitialization</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" >yes</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >no</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >no </td></tr>
</table>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 3.6: Rules for deciding when an assignment <span style="font-family:monospace">x.f = y</span> is allowed for a
<a href="api/org/checkerframework/checker/initialization/qual/NotOnlyInitialized.html"><span style="font-family:monospace">@NotOnlyInitialized</span></a> field <span style="font-family:monospace">f</span>.</td></tr>
</table></div>
<a id="fig-init-write-field"></a>
<div class="center"><hr style="width:80%;height:2"></div></div></blockquote><p>These rules allow for the safe initialization of circular structures. For instance,
consider a doubly linked list:</p><pre class="verbatim">  class List&lt;T&gt; {
    @NotOnlyInitialized
    Node&lt;T&gt; sentinel;

    public List() {
      this.sentinel = new Node&lt;T&gt;(this);
    }

    void insert(@Nullable T data) {
      this.sentinel.insertAfter(data);
    }

    public static void main() {
      List&lt;Integer&gt; l = new List&lt;Integer&gt;();
      l.insert(1);
      l.insert(2);
    }
  }

  class Node&lt;T&gt; {
    @NotOnlyInitialized
    Node&lt;T&gt; prev;

    @NotOnlyInitialized
    Node&lt;T&gt; next;

    @NotOnlyInitialized
    List parent;

    @Nullable
    T data;

    // for sentinel construction
    Node(@UnderInitialization List parent) {
      this.parent = parent;
      this.prev = this;
      this.next = this;
    }

    // for data node construction
    Node(Node&lt;T&gt; prev, Node&lt;T&gt; next, @Nullable T data) {
      this.parent = prev.parent;
      this.prev = prev;
      this.next = next;
      this.data = data;
    }

    void insertAfter(@Nullable T data) {
      Node&lt;T&gt; n = new Node&lt;T&gt;(this, this.next, data);
      this.next.prev = n;
      this.next = n;
    }
  }
</pre>
<!--TOC subsection id="initialization-warnings" How to handle warnings-->
<h3 id="initialization-warnings" class="subsection">3.8.5&#XA0;&#XA0;How to handle warnings</h3><!--SEC END --><p>There are several ways to address a warning &#X201C;error: the constructor does
not initialize fields: &#X2026;&#X201D;.
</p><ul class="itemize"><li class="li-itemize">
Declare the field as <a href="api/org/checkerframework/checker/nullness/qual/Nullable.html"><span style="font-family:monospace">@Nullable</span></a>. Recall
that if you did not write an annotation, the field defaults to
<a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a>.
</li><li class="li-itemize">Declare the field as <a href="api/org/checkerframework/checker/nullness/qual/MonotonicNonNull.html"><span style="font-family:monospace">@MonotonicNonNull</span></a>.
This is appropriate if the field starts out as <span style="font-family:monospace">null</span> but is later set
to a non-null value. You may then wish to use the
<a href="api/org/checkerframework/checker/nullness/qual/EnsuresNonNull.html"><span style="font-family:monospace">@EnsuresNonNull</span></a> annotation to indicate
which methods set the field, and the
<a href="api/org/checkerframework/checker/nullness/qual/RequiresNonNull.html"><span style="font-family:monospace">@RequiresNonNull</span></a> annotation to indicate
which methods require the field to be non-null.
</li><li class="li-itemize">Initialize the field in the constructor or in the field&#X2019;s initializer, if
the field should be initialized. (In this case, the Initialization
Checker has found a bug!)<p>Do <em>not</em> initialize the field to an arbitrary non-null value just to
eliminate the warning. Doing so degrades your code: it introduces a
value that will confuse other programmers, and it converts a clear
NullPointerException into a more obscure error.
</p></li></ul><p>If your code calls an instance method from a constructor, you may see a
message such as the following:</p><pre class="verbatim">Foo.java:123: error: call to initHelper() not allowed on the given receiver.
    initHelper();
              ^
  found   : @UnderInitialization(com.google.Bar.class) @NonNull MyClass
  required: @Initialized @NonNull MyClass
</pre><p>The problem is that the current object (<span style="font-family:monospace">this</span>) is under initialization,
but the receiver formal parameter (Section&#XA0;<a href="#faq-receiver">30.5.1</a>) of method
<span style="font-family:monospace">initHelper()</span> is implicitly annotated as
<a href="api/org/checkerframework/checker/initialization/qual/Initialized.html"><span style="font-family:monospace">@Initialized</span></a>. If
<span style="font-family:monospace">initHelper()</span> doesn&#X2019;t depend on its receiver being initialized &#X2014; that
is, it&#X2019;s OK to call <span style="font-family:monospace">x.initHelper</span> even if <span style="font-family:monospace">x</span> is not initialized &#X2014;
then you can indicate that:</p><pre class="verbatim">class MyClass {
  void initHelper(@UnknownInitialization MyClass this, String param1) { ... }
}
</pre><p>If you are using annotations in comments, you would write:</p><pre class="verbatim">class MyClass {
  void initHelper(/*&gt;&gt;&gt;@UnknownInitialization MyClass this,*/ String param1) { ... }
}
</pre><p>You are likely to want to annotate <span style="font-family:monospace">initHelper()</span> with
<a href="api/org/checkerframework/checker/nullness/qual/EnsuresNonNull.html"><span style="font-family:monospace">@EnsuresNonNull</span></a> as well; see
Section&#XA0;<a href="#nullness-method-annotations">3.2.2</a>.</p><p>You may get the &#X201C;call to &#X2026; is not allowed on the given receiver&#X201D;
error even if your constructor has already initialized all the fields.
For this code:</p><pre class="verbatim">public class MyClass {
  @NonNull Object field;
  public MyClass() {
    field = new Object();
    helperMethod();
  }
  private void helperMethod() {
  }
}
</pre><p>the Nullness Checker issues the following warning:</p><pre class="verbatim">MyClass.java:7: error: call to helperMethod() not allowed on the given receiver.
    helperMethod();
                ^
  found   : @UnderInitialization(MyClass.class) @NonNull MyClass
  required: @Initialized @NonNull MyClass
1 error
</pre><p>
The reason is that even though the object under construction has had all
the fields declared in <span style="font-family:monospace">MyClass</span> initialized, there might be a subclass of
<span style="font-family:monospace">MyClass</span>. Thus, the receiver of <span style="font-family:monospace">helperMethod</span> should be declared as
<span style="font-family:monospace">@UnderInitialization(MyClass.class)</span>, which says that initialization has
completed for all the <span style="font-family:monospace">MyClass</span> fields but may not have been completed
overall. If <span style="font-family:monospace">helperMethod</span> had been a public method that could also be called after
initialization was actually complete, then the receiver should have type
<span style="font-family:monospace">@UnknownInitialization</span>, which is the supertype of
<span style="font-family:monospace">@UnknownInitialization</span> and <span style="font-family:monospace">@UnderInitialization</span>.
</p>
<!--TOC subsection id="initialization-checking" More details about initialization checking-->
<h3 id="initialization-checking" class="subsection">3.8.6&#XA0;&#XA0;More details about initialization checking</h3><!--SEC END -->
<!--TOC paragraph id="initialization-checking-suppressing-warnings" Suppressing warnings-->
<h5 id="initialization-checking-suppressing-warnings" class="paragraph">Suppressing warnings</h5><!--SEC END --><p>
You can suppress warnings related to partially-initialized objects with
<span style="font-family:monospace">@SuppressWarnings("initialization")</span>.
This can be placed on a single field; on a constructor; or on a class to
suppress all initialization warnings for all constructors.
</p>
<!--TOC paragraph id="initialization-checking-all-fields" Checking initialization of all fields, not just <span style="font-family:monospace">@NonNull</span> ones-->
<h5 id="initialization-checking-all-fields" class="paragraph">Checking initialization of all fields, not just <span style="font-family:monospace">@NonNull</span> ones</h5><!--SEC END --><p>When the <span style="font-family:monospace">-Alint=uninitialized</span> command-line option is provided, then
an object is considered uninitialized until <em>all</em> its fields are assigned, not
just the <span style="font-family:monospace">@NonNull</span> ones. See Section&#XA0;<a href="#lint-uninitialized-section">3.1</a>.</p>
<!--TOC paragraph id="initialization-checking-method-annotations" Use of method annotations-->
<h5 id="initialization-checking-method-annotations" class="paragraph">Use of method annotations</h5><!--SEC END --><p>A method with a non-initialized receiver may assume that a few fields (but not all
of them) are non-null, and it sometimes sets some more fields to non-null
values. To express these concepts, use the
<a href="api/org/checkerframework/checker/nullness/qual/RequiresNonNull.html"><span style="font-family:monospace">@RequiresNonNull</span></a>,
<a href="api/org/checkerframework/checker/nullness/qual/EnsuresNonNull.html"><span style="font-family:monospace">@EnsuresNonNull</span></a>, and
<a href="api/org/checkerframework/checker/nullness/qual/EnsuresNonNullIf.html"><span style="font-family:monospace">@EnsuresNonNullIf</span></a> method annotations;
see Section&#XA0;<a href="#nullness-method-annotations">3.2.2</a>.</p>
<!--TOC paragraph id="initialization-checking-type-system" Source of the type system-->
<h5 id="initialization-checking-type-system" class="paragraph">Source of the type system</h5><!--SEC END --><p>The type system enforced by the Initialization Checker is known as
&#X201C;Freedom Before Commitment&#X201D;&#XA0;[<a href="#SummersM2011">SM11</a>]. Our implementation
changes its initialization modifiers (&#X201C;committed&#X201D;, &#X201C;free&#X201D;, and
&#X201C;unclassified&#X201D;) to &#X201C;initialized&#X201D;, &#X201C;unknown initialization&#X201D;, and
&#X201C;under initialization&#X201D;. Our implementation also has several
enhancements. For example, it supports partial initialization (the
argument to the <span style="font-family:monospace">@UnknownInitialization</span> and <span style="font-family:monospace">@UnderInitialization</span>
annotations.</p>
<!--TOC subsection id="initialization-rawness-checker" Rawness Initialization Checker-->
<h3 id="initialization-rawness-checker" class="subsection">3.8.7&#XA0;&#XA0;Rawness Initialization Checker</h3><!--SEC END --><p>The Checker Framework supports two different initialization checkers that
are integrated with the Nullness Checker.
You can use whichever one you prefer.</p><p>One (described in most of Section&#XA0;<a href="#initialization-checker">3.8</a>) uses the three annotations
<a href="api/org/checkerframework/checker/initialization/qual/Initialized.html"><span style="font-family:monospace">@Initialized</span></a>,
<a href="api/org/checkerframework/checker/initialization/qual/UnknownInitialization.html"><span style="font-family:monospace">@UnknownInitialization</span></a>, and
<a href="api/org/checkerframework/checker/initialization/qual/UnderInitialization.html"><span style="font-family:monospace">@UnderInitialization</span></a>.
We recommend that you use it.</p><p>The other (described here in Section&#XA0;<a href="#initialization-rawness-checker">3.8.7</a>)
uses the two annotations
<a href="api/org/checkerframework/checker/nullness/qual/Raw.html"><span style="font-family:monospace">@Raw</span></a> and
<a href="api/org/checkerframework/checker/nullness/qual/NonRaw.html"><span style="font-family:monospace">@NonRaw</span></a>.
The rawness type system is slightly easier to use but slightly less
expressive.</p><p>
To run the Nullness Checker with the rawness variant of the Initialization
Checker, invoke the NullnessRawnessChecker rather than the NullnessChecker;
that is, supply the <span style="font-family:monospace">-processor org.checkerframework.checker.nullness.NullnessRawnessChecker</span>
command-line option to javac.
Although <span style="font-family:monospace">@Raw</span> roughly corresponds to <span style="font-family:monospace">@UnknownInitialization</span>
and <span style="font-family:monospace">@NonRaw</span> roughly corresponds to <span style="font-family:monospace">@Initialized</span>, the
annotations are not aliased and you must use the ones that correspond to
the type-checker that you are running.
</p><p>An object is
<em>raw</em> from the time that its constructor starts until its constructor
finishes. This is relevant to the Nullness Checker because while the
constructor is executing &#X2014; that is, before initialization completes &#X2014;
a <span style="font-family:monospace">@NonNull</span>
field may be observed to be null, until that field is set. In
particular, the Nullness Checker issues a warning for code like this:</p><pre class="verbatim">  public class MyClass {
    private @NonNull Object f;
    public MyClass(int x, int y) {
      // Error because constructor contains no assignment to this.f.
      // By the time the constructor exits, f must be initialized to a non-null value.
    }
    public MyClass(int x) {
      // Error because this.f is accessed before f is initialized.
      // At the beginning of the constructor's execution, accessing this.f
      // yields null, even though field f has a non-null type.
      this.f.toString();
    }
    public MyClass(int x, int y, int z) {
      m();
    }
    public void m() {
      // Error because this.f is accessed before f is initialized,
      // even though the access is not in a constructor.
      // When m is called from the constructor, accessing f yields null,
      // even though field f has a non-null type.
      this.f.toString();
    }
</pre><p>In general, code can depend that field <span style="font-family:monospace">f</span> is not <span style="font-family:monospace">null</span>, because the
field is declared with a <a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a> type.
However, this guarantee does not hold for a partially-initialized object.</p><p>The Nullness Checker uses the <a href="api/org/checkerframework/checker/nullness/qual/Raw.html"><span style="font-family:monospace">@Raw</span></a> annotation to indicate that an object
is not yet fully initialized &#X2014; that is, not all its <span style="font-family:monospace">@NonNull</span> fields have been
assigned. Rawness is mostly relevant within the constructor, or for
references to <span style="font-family:monospace">this</span> that escape the constructor (say, by being stored
in a field or passed to a method before initialization is complete).
Use of rawness annotations is rare in most code.</p><p>The most common use for the <span style="font-family:monospace">@Raw</span> annotation is for a helper routine that
is called by constructor. For example:</p><pre class="verbatim">  class MyClass {
    Object field1;
    Object field2;
    Object field3;

    public MyClass(String arg1) {
      this.field1 = arg1;
      init_other_fields();
    }

    // A helper routine that initializes all the fields other than field1
    @EnsuresNonNull({"field2", "field3"})
    private void init_other_fields(@Raw MyClass this) {
      field2 = new Object();
      field3 = new Object();
    }
  }
</pre><p>For compatibility with Java 6 and 7, you can write the receiver
parameter in comments (see Section&#XA0;<a href="#annotations-in-comments">25.2.1</a>):
</p><pre class="verbatim">    private void init_other_fields(/*&gt;&gt;&gt; @Raw MyClass this*/) {
</pre>
<!--TOC subsubsection id="rawness-qualifiers" Rawness qualifiers-->
<h4 id="rawness-qualifiers" class="subsubsection">Rawness qualifiers</h4><!--SEC END --><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<img src="rawness.svg">
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 3.7: Partial type hierarchy for the Rawness Initialization type system.</td></tr>
</table></div>
<a id="fig-rawness-hierarchy"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p>The rawness hierarchy is shown in Figure&#XA0;<a href="#fig-rawness-hierarchy">3.7</a>.
The rawness hierarchy contains these qualifiers:</p><dl class="description"><dt class="dt-description"><a href="api/org/checkerframework/checker/nullness/qual/Raw.html"><span style="font-weight:bold"><span style="font-family:monospace">@Raw</span></span></a></dt><dd class="dd-description">
indicates a type that may contain a partially-initialized object. In a
partially-initialized object, fields that are annotated as
<a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a> may be null because the field
has not yet been assigned. Within the constructor,
<span style="font-family:monospace">this</span> has <a href="api/org/checkerframework/checker/nullness/qual/Raw.html"><span style="font-family:monospace">@Raw</span></a> type until all
the <span style="font-family:monospace">@NonNull</span> fields have been assigned.
A partially-initialized object (<span style="font-family:monospace">this</span> in a constructor) may be
passed to a helper method or stored in a variable; if so, the method
receiver, or the field, would have to be annotated as <span style="font-family:monospace">@Raw</span>.</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/nullness/qual/NonRaw.html"><span style="font-weight:bold"><span style="font-family:monospace">@NonRaw</span></span></a></dt><dd class="dd-description">
indicates a type that contains a fully-initialized object. <span style="font-family:monospace">NonRaw</span>
is the default, so there is little need for a programmer to write this
explicitly.</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/nullness/qual/PolyRaw.html"><span style="font-weight:bold"><span style="font-family:monospace">@PolyRaw</span></span></a></dt><dd class="dd-description">
indicates qualifier polymorphism over rawness (see
Section&#XA0;<a href="#qualifier-polymorphism">22.2</a>).</dd></dl><p>If a reference has
<span style="font-family:monospace">@Raw</span> type, then all of its <span style="font-family:monospace">@NonNull</span> fields are treated as
<a href="api/org/checkerframework/checker/nullness/qual/MonotonicNonNull.html"><span style="font-family:monospace">@MonotonicNonNull</span></a>: when read, they are
treated as being <a href="api/org/checkerframework/checker/nullness/qual/Nullable.html"><span style="font-family:monospace">@Nullable</span></a>, but when
written, they are treated as being
<a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a>.</p><p>The rawness hierarchy is orthogonal to the nullness hierarchy. It
is legal for a reference to be <span style="font-family:monospace">@NonNull @Raw</span>, <span style="font-family:monospace">@Nullable @Raw</span>,
<span style="font-family:monospace">@NonNull @NonRaw</span>, or <span style="font-family:monospace">@Nullable @NonRaw</span>. The nullness hierarchy tells
you about the reference itself: might the reference be null? The rawness
hierarchy tells you about the <span style="font-family:monospace">@NonNull</span> fields in the referred-to object:
might those fields be temporarily null in contravention of their
type annotation?
Figure&#XA0;<a href="#fig-rawness-examples">3.8</a> contains some examples.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >Declarations</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >Expression</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >Expression&#X2019;s nullness type, or checker error </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><div class="minipage">
<pre class="verbatim">class C {
  @NonNull Object f;
  @Nullable Object g;
  ...
}
</pre></div></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@NonNull @NonRaw C a;</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">a</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@NonNull</span> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">a.f</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@NonNull</span> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">a.g</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@Nullable</span> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@NonNull @Raw C b;</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">b</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@NonNull</span> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">b.f</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@MonotonicNonNull</span> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">b.g</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@Nullable</span> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@Nullable @NonRaw C c;</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">c</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@Nullable</span> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">c.f</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >error: deref of nullable </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">c.g</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >error: deref of nullable </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@Nullable @Raw C d;</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">d</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">@Nullable</span> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">d.f</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >error: deref of nullable </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">d.g</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >error: deref of nullable </td></tr>
</table>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 3.8: Examples of the interaction between nullness and rawness.
Declarations are shown at the left for reference, but the focus of the
table is the expressions and their nullness type or error.</td></tr>
</table></div>
<a id="fig-rawness-examples"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote>
<!--TOC subsubsection id="becoming-non-raw" How an object becomes non-raw-->
<h4 id="becoming-non-raw" class="subsubsection">How an object becomes non-raw</h4><!--SEC END --><p>Within the constructor,
<span style="font-family:monospace">this</span> starts out with <a href="api/org/checkerframework/checker/nullness/qual/Raw.html"><span style="font-family:monospace">@Raw</span></a> type.
As soon as all of the <a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a> fields
have been initialized, then <span style="font-family:monospace">this</span> is treated as non-raw.
</p><p>The Nullness Checker issues an error if the constructor fails to initialize
any <span style="font-family:monospace">@NonNull</span> field. This ensures that the object is in a legal (non-raw)
state by the time that the constructor exits.
This is different than Java&#X2019;s test for definite assignment (see
<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-16.html">JLS ch.16</a>),
which does not apply to fields (except blank final ones, defined in
<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.12.4">JLS &#XA7;4.12.4</a>) because fields
have a default value of null.</p><p>All <span style="font-family:monospace">@NonNull</span> fields must either have a
default in the field declaration, or be assigned in the constructor or in a
helper method that the constructor calls. If
your code initializes (some) fields in a helper method, you will need to
annotate the helper method with an annotation such as
<a href="api/org/checkerframework/checker/nullness/qual/EnsuresNonNull.html"><span style="font-family:monospace">@EnsuresNonNull</span></a><span style="font-family:monospace">({"field1", "field2"})</span>
for all the fields that the helper method assigns.
It&#X2019;s a bit odd, but you use that same annotation, <span style="font-family:monospace">@EnsuresNonNull</span>,
to indicate that a primitive field has its value set in a helper method,
which is relevant when you supply the <span style="font-family:monospace">-Alint=uninitialized</span>
command-line option (see Section&#XA0;<a href="#lint-uninitialized-section">3.1</a>).</p>
<!--TOC subsubsection id="rawness-partial-initialization" Partial initialization-->
<h4 id="rawness-partial-initialization" class="subsubsection">Partial initialization</h4><!--SEC END --><p>So far, we have discussed rawness as if it is an all-or-nothing property:
an object is fully raw until initialization completes, and then it is no
longer raw. The full truth is a bit more complex: during the
initialization process, an object can be partially initialized, and as the
object&#X2019;s superclass constructors complete, its rawness changes. The
Nullness Checker lets you express such properties when necessary.</p><p>Consider a simple example:</p><pre class="verbatim">class A {
  Object a;
  A() {
    a = new Object();
  }
}
class B extends A {
  Object b;
  B() {
    super();
    b = new Object();
  }
}
</pre><p>Consider what happens during execution of <span style="font-family:monospace">new B()</span>.</p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">B</span>&#X2019;s constructor begins to execute. At this point, neither the
fields of <span style="font-family:monospace">A</span> nor those of <span style="font-family:monospace">B</span> have been initialized yet.
</li><li class="li-enumerate"><span style="font-family:monospace">B</span>&#X2019;s constructor calls <span style="font-family:monospace">A</span>&#X2019;s constructor, which begins to execute.
No fields of <span style="font-family:monospace">A</span> nor of <span style="font-family:monospace">B</span> have been initialized yet.
</li><li class="li-enumerate"><span style="font-family:monospace">A</span>&#X2019;s constructor completes. Now, all the fields of <span style="font-family:monospace">A</span> have been
initialized, and their invariants (such as that field <span style="font-family:monospace">a</span> is non-null) can be
depended on. However, because <span style="font-family:monospace">B</span>&#X2019;s constructor has not yet completed
executing, the object being constructed is not yet fully initialized.
When treated as an <span style="font-family:monospace">A</span> (e.g., if only the <span style="font-family:monospace">A</span> fields are accessed), the
object is initialized (non-raw), but when treated as a <span style="font-family:monospace">B</span>, the object
is still raw.
</li><li class="li-enumerate"><span style="font-family:monospace">B</span>&#X2019;s constructor completes. The object is fully initialized
(non-raw), if <span style="font-family:monospace">B</span>&#X2019;s constructor was invoked via a <span style="font-family:monospace">new B()</span>
expression. On the other hand, if there was a <span style="font-family:monospace">class C extends B {
... }</span>, and <span style="font-family:monospace">B</span>&#X2019;s constructor had been invoked from that, then the
object currently under construction would <em>not</em> be fully initialized
&#X2014; it would only be initialized when treated as an <span style="font-family:monospace">A</span> or a <span style="font-family:monospace">B</span>, but
not when treated as a <span style="font-family:monospace">C</span>.
</li></ol><p>At any moment during initialization, the superclasses of a given class
can be divided into those that have completed initialization and those that
have not yet completed initialization. More precisely, at any moment there
is a point in the class hierarchy such that all the classes above that
point are fully initialized, and all those below it are not yet
initialized. As initialization proceeds, this dividing line between the
initialized and raw classes moves down the type hierarchy.</p><p>The Nullness Checker lets you indicate where the dividing line is between
the initialized and non-initialized classes.
You have two equivalent ways to indicate the dividing line: <span style="font-family:monospace">@Raw</span>
indicates the first class <em>below</em> the dividing line, or
<span style="font-family:monospace">@NonRaw(</span><span style="font-family:monospace"><em>classliteral</em></span><span style="font-family:monospace">)</span> indicates the first class <em>above</em> the
dividing line.</p><p>When you write <a href="api/org/checkerframework/checker/nullness/qual/Raw.html"><span style="font-family:monospace">@Raw</span></a><span style="font-family:monospace"> MyClass x;</span>, that
means that variable <span style="font-family:monospace">x</span> is initialized for all superclasses of <span style="font-family:monospace">MyClass</span>,
and (possibly) uninitialized for <span style="font-family:monospace">MyClass</span> and all subclasses.</p><p>When you write <a href="api/org/checkerframework/checker/nullness/qual/NonRaw.html"><span style="font-family:monospace">@NonRaw</span></a><span style="font-family:monospace">(Foo.class) MyClass
x;</span>, that means that variable <span style="font-family:monospace">x</span> is initialized for <span style="font-family:monospace">Foo</span> and all its
superclasses, and (possibly) uninitialized for all subclasses of <span style="font-family:monospace">Foo</span>.</p><p>If <span style="font-family:monospace">A</span> is a direct superclass of <span style="font-family:monospace">B</span> (as in the example above), then
<span style="font-family:monospace">@Raw A x;</span> and <span style="font-family:monospace">@NonRaw(B.class) A x;</span> are equivalent declarations.
Neither one is the same as <span style="font-family:monospace">@NonRaw A x;</span>, which indicates that, whatever
the actual class of the object that <span style="font-family:monospace">x</span> refers to, that object is fully
initialized. Since <span style="font-family:monospace">@NonRaw</span> (with no argument) is the default, you will
rarely see it written.</p><p><a id="becoming-non-raw-clarification"></a></p><p>We can now state a clarification of Section&#XA0;<a href="#becoming-non-raw">3.8.7</a>&#X2019;s rule
for an object becoming non-raw.
As soon as all of the <a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a> fields
have been initialized, then <span style="font-family:monospace">this</span> is treated as
<a href="api/org/checkerframework/checker/nullness/qual/NonRaw.html"><span style="font-family:monospace">@NonRaw</span></a><span style="font-family:monospace">(</span><span style="font-family:monospace"><em>typeofthis</em></span><span style="font-family:monospace">)</span>, rather than
treated as simply
<a href="api/org/checkerframework/checker/nullness/qual/NonRaw.html"><span style="font-family:monospace">@NonRaw</span></a>.</p><p>The example above lists 4 moments during construction. At those moments,
the type of the object being constructed is:</p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">@Raw Object</span>
</li><li class="li-enumerate"><span style="font-family:monospace">@Raw Object</span>
</li><li class="li-enumerate"><span style="font-family:monospace">@NonRaw(A.class) A</span>
</li><li class="li-enumerate"><span style="font-family:monospace">@NonRaw(B.class) B</span>
</li></ol>
<!--TOC paragraph id="rawness-partial-initialization-example" Example-->
<h5 id="rawness-partial-initialization-example" class="paragraph">Example</h5><!--SEC END --><p>As another example, consider the following 12 declarations:</p><pre class="verbatim">    @Raw Object rO;
    @NonRaw(Object.class) Object nroO;
    Object o;

    @Raw A rA;
    @NonRaw(Object.class) A nroA;  // same as "@Raw A"
    @NonRaw(A.class) A nraA;
    A a;

    @NonRaw(Object.class) B nroB;
    @Raw B rB;
    @NonRaw(A.class) B nraB;  // same as "@Raw B"
    @NonRaw(B.class) B nrbB;
    B b;
</pre><p>In the following table, the type in cell C1 is a supertype of the type in
cell C2 if: C1 is at least as high and at least as far left in the table
as C2 is. For example, <span style="font-family:monospace">nraA</span>&#X2019;s type is a supertype of those of <span style="font-family:monospace">rB</span>,
<span style="font-family:monospace">nraB</span>, <span style="font-family:monospace">nrbB</span>, <span style="font-family:monospace">a</span>, and <span style="font-family:monospace">b</span>. (The empty cells on the top row are real
types, but are not expressible. The other empty cells are not interesting
types.)</p><table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">@Raw Object rO;</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >
<span style="font-family:monospace">@NonRaw(Object.class) Object nroO;</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><div class="minipage">
<pre class="verbatim">@Raw A rA;
@NonRaw(Object.class) A nroA;
</pre></div></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">@NonRaw(Object.class) B nroB;</span>
</td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">@NonRaw(A.class) A nraA;</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><div class="minipage">
<pre class="verbatim">@Raw B rB;
@NonRaw(A.class) B nraB;
</pre></div>
</td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">@NonRaw(B.class) B nrbB;</span>
</td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >
<span style="font-family:monospace">Object o;</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">A a;</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">B b;</span>
</td></tr>
</table>
<!--TOC subsubsection id="rawness-checking" More details about rawness checking-->
<h4 id="rawness-checking" class="subsubsection">More details about rawness checking</h4><!--SEC END -->
<!--TOC paragraph id="rawness-checking-suppressing-warnings" Suppressing warnings-->
<h5 id="rawness-checking-suppressing-warnings" class="paragraph">Suppressing warnings</h5><!--SEC END --><p>
You can suppress warnings related to partially-initialized objects with
<span style="font-family:monospace">@SuppressWarnings("rawness")</span>. Do not confuse this with the unrelated
<span style="font-family:monospace">@SuppressWarnings("rawtypes")</span> annotation for non-instantiated generic types!
</p>
<!--TOC paragraph id="rawness-checking-checking-all-fields" Checking initialization of all fields, not just <span style="font-family:monospace">@NonNull</span> ones-->
<h5 id="rawness-checking-checking-all-fields" class="paragraph">Checking initialization of all fields, not just <span style="font-family:monospace">@NonNull</span> ones</h5><!--SEC END --><p>When the <span style="font-family:monospace">-Alint=uninitialized</span> command-line option is provided, then
an object is considered raw until <em>all</em> its fields are assigned, not
just the <span style="font-family:monospace">@NonNull</span> ones. See Section&#XA0;<a href="#lint-uninitialized-section">3.1</a>.</p>
<!--TOC paragraph id="rawness-checking-method-annotations" Use of method annotations-->
<h5 id="rawness-checking-method-annotations" class="paragraph">Use of method annotations</h5><!--SEC END --><p>A method with a raw receiver often assumes that a few fields (but not all
of them) are non-null, and sometimes sets some more fields to non-null
values. To express these concepts, use the
<a href="api/org/checkerframework/checker/nullness/qual/RequiresNonNull.html"><span style="font-family:monospace">@RequiresNonNull</span></a>,
<a href="api/org/checkerframework/checker/nullness/qual/EnsuresNonNull.html"><span style="font-family:monospace">@EnsuresNonNull</span></a>, and
<a href="api/org/checkerframework/checker/nullness/qual/EnsuresNonNullIf.html"><span style="font-family:monospace">@EnsuresNonNullIf</span></a> method annotations;
see Section&#XA0;<a href="#nullness-method-annotations">3.2.2</a>.</p>
<!--TOC paragraph id="rawness-checking-terminology-raw" The terminology &#X201C;raw&#X201D;-->
<h5 id="rawness-checking-terminology-raw" class="paragraph">The terminology &#X201C;raw&#X201D;</h5><!--SEC END --><p>The name &#X201C;raw&#X201D; comes from a research paper that proposed this
approach&#XA0;[<a href="#FahndrichL2003">FL03</a>].
A better name might have been &#X201C;not yet initialized&#X201D; or &#X201C;partially
initialized&#X201D;, but the term &#X201C;raw&#X201D; is now well-known.
The <a href="api/org/checkerframework/checker/nullness/qual/Raw.html"><span style="font-family:monospace">@Raw</span></a>
annotation has nothing to do with the raw types of Java Generics.</p><hr>
<!--TOC chapter id="map-key-checker" Map Key Checker-->
<h1 id="map-key-checker" class="chapter">Chapter&#XA0;4&#XA0;&#XA0;Map Key Checker</h1><!--SEC END --><p>The Map Key Checker tracks which values are keys for which maps. If variable
<span style="font-family:monospace">v</span> has type <span style="font-family:monospace">@KeyFor("m")...</span>, then the value of <span style="font-family:monospace">v</span> is a key
in Map <span style="font-family:monospace">m</span>. That is, the expression <span style="font-family:monospace">m.containsKey(v)</span> evaluates to
<span style="font-family:monospace">true</span>.</p><p>Section&#XA0;<a href="#map-key-qualifiers">3.2.4</a> describes how <span style="font-family:monospace">@KeyFor</span> annotations
enable the
Nullness Checker (Chapter&#XA0;<a href="#nullness-checker">3</a>) to treat calls to
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Map.html#get-java.lang.Object-"><span style="font-family:monospace">Map.get</span></a>
more precisely by refining its result to <span style="font-family:monospace">@NonNull</span> in some cases.</p><p>You will not typically run the Map Key Checker. It is automatically run by
other checkers, in particular the Nullness Checker.</p><p>You can suppress warnings related to map keys with
<span style="font-family:monospace">@SuppressWarnings("keyfor")</span>; see Chapter&#XA0;<a href="#suppressing-warnings">24</a>.</p>
<!--TOC section id="map-key-annotations" Map key annotations-->
<h2 id="map-key-annotations" class="section">4.1&#XA0;&#XA0;Map key annotations</h2><!--SEC END --><p>These qualifiers are part of the Map Key type system:</p><dl class="description"><dt class="dt-description"><a href="api/org/checkerframework/checker/nullness/qual/KeyFor.html"><span style="font-weight:bold"><span style="font-family:monospace">@KeyFor</span></span></a><span style="font-weight:bold"><span style="font-family:monospace">(String[] maps)</span></span></dt><dd class="dd-description">
indicates that the value assigned to the annotated variable is a key for at
least the given maps.</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/nullness/qual/UnknownKeyFor.html"><span style="font-weight:bold"><span style="font-family:monospace">@UnknownKeyFor</span></span></a></dt><dd class="dd-description">
is used internally by the type system but should never be written by a
programmer. It indicates that the value assigned to the annotated
variable is not known to be a key for any map. It is the default type
qualifier.</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/nullness/qual/KeyForBottom.html"><span style="font-weight:bold"><span style="font-family:monospace">@KeyForBottom</span></span></a></dt><dd class="dd-description">
is used internally by the type system but should never be written by a
programmer.</dd></dl><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<img src="map-key-keyfor.svg">
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 4.1: The subtyping relationship of the Map Key Checker&#X2019;s qualifiers.
<span style="font-family:monospace">@KeyFor(A)</span> is a supertype of <span style="font-family:monospace">@KeyFor(B)</span> if and only if <span style="font-family:monospace">A</span> is a subset of
<span style="font-family:monospace">B</span>. Qualifiers in gray are used internally by the type system but should
never be written by a programmer.</td></tr>
</table></div>
<a id="fig-map-key-keyfor-hierarchy"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote>
<!--TOC section id="map-key-examples" Examples-->
<h2 id="map-key-examples" class="section">4.2&#XA0;&#XA0;Examples</h2><!--SEC END --><p>The Map Key Checker keeps track of which variables reference keys to
which maps. A variable annotated with <span style="font-family:monospace">@KeyFor(</span><span style="font-family:monospace"><em>mapSet</em></span><span style="font-family:monospace">)</span> can only
contain a value that is a key for all the maps in <em>mapSet</em>. For example:</p><pre class="verbatim">Map&lt;String,Date&gt; m, n;
@KeyFor("m") String km;
@KeyFor("n") String kn;
@KeyFor({"m", "n"}) String kmn;
km = kmn;   // OK - a key for maps m and n is also a key for map m
km = kn;    // error: a key for map n is not necessarily a key for map m
</pre><p>As with any annotation, use of the <span style="font-family:monospace">@KeyFor</span> annotation may force you to
slightly refactor your code. For example, this would be illegal:</p><pre class="verbatim">Map&lt;String,Object&gt; m;
Collection&lt;@KeyFor("m") String&gt; coll;
coll.add(x);   // error: element type is @KeyFor("m") String, but x does not have that type
m.put(x, ...);
</pre><p>The example type-checks if you reorder the two calls:</p><pre class="verbatim">Map&lt;String,Object&gt; m;
Collection&lt;@KeyFor("m") String&gt; coll;
m.put(x, ...);    // after this statement, x has type @KeyFor("m") String
coll.add(x);      // OK
</pre>
<!--TOC section id="map-key-annotations-inference" Inference of @KeyFor annotations-->
<h2 id="map-key-annotations-inference" class="section">4.3&#XA0;&#XA0;Inference of @KeyFor annotations</h2><!--SEC END --><p>Within a method body, you usually do not have to write <span style="font-family:monospace">@KeyFor</span> explicitly,
because the checker infers it based on usage patterns. When the Map Key
Checker encounters a run-time check for map keys, such as
&#X201C;<span style="font-family:monospace">if (m.containsKey(k)) ...</span>&#X201D;, then the Map Key Checker refines the type of
<span style="font-family:monospace">k</span> to <span style="font-family:monospace">@KeyFor("m")</span> within the scope of the test (or until <span style="font-family:monospace">k</span> is
side-effected within that scope). The Map Key Checker also infers <span style="font-family:monospace">@KeyFor</span>
annotations based on iteration over a map&#X2019;s
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Map.html#keySet--">key set</a> or calls to
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Map.html#put-K-V-"><span style="font-family:monospace">put</span></a>
or
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Map.html#containsKey-java.lang.Object-"><span style="font-family:monospace">containsKey</span></a>.
For more details about type refinement, see Section&#XA0;<a href="#type-refinement">23.4</a>.</p><p>Suppose we have these declarations:</p><pre class="verbatim">Map&lt;String,Date&gt; m = new Map&lt;String,Date&gt;();
String k = "key";
@KeyFor("m") String km;
</pre><p>Ordinarily, the following assignment does not type-check:</p><pre class="verbatim">km = k;   // Error since k is not known to be a key for map m.
</pre><p>The following examples show cases where the Map Key Checker
infers a <span style="font-family:monospace">@KeyFor</span> annotation for variable <span style="font-family:monospace">k</span> based on usage patterns,
enabling the <span style="font-family:monospace">km = k</span> assignment to type-check.</p><pre class="verbatim">m.put(k, ...);
// At this point, the type of k is refined to @KeyFor("m") String.
km = k;   // OK


if (m.containsKey(k)) {
    // At this point, the type of k is refined to @KeyFor("m") String.
    km = k;   // OK
    ...
} else {
    km = k;   // Error since k is not known to be a key for map m.
    ...
}
</pre><p>The following example shows a case where the Map Key Checker resets its
assumption about the type of a field used as a key because that field may have
been side-effected.</p><pre class="verbatim">class MyClass {
    private Map&lt;String,Object&gt; m;
    private String k;   // The type of k defaults to @UnknownKeyFor String
    private @KeyFor("m") String km;

    public void myMethod() {
        if (m.containsKey(k)) {
            km = k;   // OK: the type of k is refined to @KeyFor("m") String

            sideEffectFreeMethod();
            km = k;   // OK: the type of k is not affected by the method call
                      // and remains @KeyFor("m") String

            otherMethod();
            km = k;   // error: At this point, the type of k is once again
                      // @UnknownKeyFor String, because otherMethod might have
                      // side-effected k such that it is no longer a key for map m.
        }
    }

    @SideEffectFree
    private void sideEffectFreeMethod() { ... }

    private void otherMethod() { ... }
}
</pre><hr>
<!--TOC chapter id="interning-checker" Interning Checker-->
<h1 id="interning-checker" class="chapter">Chapter&#XA0;5&#XA0;&#XA0;Interning Checker</h1><!--SEC END --><p>If the Interning Checker issues no errors for a given program, then all
reference equality tests (i.e., all uses of &#X201C;<span style="font-family:monospace">==</span>&#X201D;) are proper;
that is,
<span style="font-family:monospace">==</span> is not misused where <span style="font-family:monospace">equals()</span> should have been used instead.</p><p>Interning is a design pattern in which the same object is used whenever two
different objects would be considered equal. Interning is also known as
canonicalization or hash-consing, and it is related to the flyweight design
pattern.
Interning has two benefits: it can save memory, and it can speed up testing for
equality by permitting use of <span style="font-family:monospace">==</span>.</p><p>The Interning Checker prevents two types of errors in your code. First,
<span style="font-family:monospace">==</span> should be used
only on interned values; using <span style="font-family:monospace">==</span> on
non-interned values can result in subtle bugs. For example:</p><pre class="verbatim">  Integer x = new Integer(22);
  Integer y = new Integer(22);
  System.out.println(x == y);  // prints false!
</pre><p>The Interning Checker helps programmers to prevent such bugs.
Second,
the Interning Checker also helps to prevent performance problems that result
from failure to use interning.
(See Section&#XA0;<a href="#checker-guarantees">2.3</a> for caveats to the checker&#X2019;s guarantees.)</p><p>Interning is such an important design pattern that Java builds it in for
these types: <span style="font-family:monospace">String</span>, <span style="font-family:monospace">Boolean</span>, <span style="font-family:monospace">Byte</span>, <span style="font-family:monospace">Character</span>, <span style="font-family:monospace">Integer</span>,
<span style="font-family:monospace">Short</span>. Every string literal in the program is guaranteed to be interned
(<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.5">JLS
&#XA7;3.10.5</a>), and the
<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#intern--"><span style="font-family:monospace">String.intern()</span></a> method
performs interning for strings that are computed at run time.
The <span style="font-family:monospace">valueOf</span> methods in wrapper classes always (<span style="font-family:monospace">Boolean</span>, <span style="font-family:monospace">Byte</span>) or
sometimes (<span style="font-family:monospace">Character</span>, <span style="font-family:monospace">Integer</span>, <span style="font-family:monospace">Short</span>) return an interned result
(<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.7">JLS &#XA7;5.1.7</a>).
Users can also write their own interning methods for other types.</p><p>It is a proper optimization to use <span style="font-family:monospace">==</span>, rather than <span style="font-family:monospace">equals()</span>,
whenever the comparison is guaranteed to produce the same result &#X2014; that
is, whenever the comparison is never provided with two different objects
for which <span style="font-family:monospace">equals()</span> would return true. Here are three reasons that
this property could hold:</p><ol class="enumerate" type=1><li class="li-enumerate">
Interning. A factory method ensures that, globally, no two different
interned objects are <span style="font-family:monospace">equals()</span> to one another. (In some cases
other, non-interned objects of the class might be <span style="font-family:monospace">equals()</span> to one
another; in other cases, every object of the class is interned.)
Interned objects should always be immutable.
</li><li class="li-enumerate">Global control flow. The program&#X2019;s control flow is such that the
constructor for class <span style="font-style:italic">C</span> is called a limited number of times, and with
specific values that ensure the results are not <span style="font-family:monospace">equals()</span> to one
another. Objects of class <span style="font-style:italic">C</span> can always be compared with <span style="font-family:monospace">==</span>.
Such objects may be mutable or immutable.
</li><li class="li-enumerate">Local control flow. Even though not all objects of the given type may be
compared with <span style="font-family:monospace">==</span>, the specific objects that can reach a given
comparison may be. For example, suppose that an array contains no
duplicates. Then testing to find the index of a given element that is
known to be in the array can use <span style="font-family:monospace">==</span>.
</li></ol><p>To eliminate Interning Checker errors, you will need to annotate the
declarations of any expression used as an argument to <span style="font-family:monospace">==</span>.
Thus, the Interning Checker
could also have been called the Reference Equality Checker. In the
future, the checker will include annotations that target the non-interning
cases above, but for now you need to use <span style="font-family:monospace">@Interned</span>, <span style="font-family:monospace">@UsesObjectEquals</span>
(which handles a surprising number of cases), and/or
<span style="font-family:monospace">@SuppressWarnings</span>.</p><p>
To run the Interning Checker, supply the
<span style="font-family:monospace">-processor org.checkerframework.checker.interning.InterningChecker</span>
command-line option to javac. For examples, see Section&#XA0;<a href="#interning-example">5.4</a>.
</p>
<!--TOC section id="interning-annotations" Interning annotations-->
<h2 id="interning-annotations" class="section">5.1&#XA0;&#XA0;Interning annotations</h2><!--SEC END --><p>These qualifiers are part of the Interning type system:</p><dl class="description"><dt class="dt-description"><a href="api/org/checkerframework/checker/interning/qual/Interned.html"><span style="font-weight:bold"><span style="font-family:monospace">@Interned</span></span></a></dt><dd class="dd-description">
indicates a type that includes only interned values (no non-interned
values).</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/interning/qual/PolyInterned.html"><span style="font-weight:bold"><span style="font-family:monospace">@PolyInterned</span></span></a></dt><dd class="dd-description">
indicates qualifier polymorphism (see
Section&#XA0;<a href="#qualifier-polymorphism">22.2</a>).</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/interning/qual/UsesObjectEquals.html"><span style="font-weight:bold"><span style="font-family:monospace">@UsesObjectEquals</span></span></a></dt><dd class="dd-description">
is a class (not type) annotation that indicates that this class&#X2019;s
<span style="font-family:monospace">equals</span> method is the same as that of <span style="font-family:monospace">Object</span>. In other words,
neither this class nor any of its superclasses overrides the <span style="font-family:monospace">equals</span>
method. Since <span style="font-family:monospace">Object.equals</span> uses reference equality, this means that
for such a class, <span style="font-family:monospace">==</span> and <span style="font-family:monospace">equals</span> are equivalent, and so the
Interning Checker does not issue errors or warnings for either one.</dd></dl>
<!--TOC section id="annotating-with-interned" Annotating your code with <span style="font-family:monospace">@Interned</span>-->
<h2 id="annotating-with-interned" class="section">5.2&#XA0;&#XA0;Annotating your code with <span style="font-family:monospace">@Interned</span></h2><!--SEC END --><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<img src="interning.svg">
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 5.1: Type hierarchy for the Interning type system.</td></tr>
</table></div>
<a id="fig-interning-hierarchy"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p>In order to perform checking, you must annotate your code with the <a href="api/org/checkerframework/checker/interning/qual/Interned.html"><span style="font-family:monospace">@Interned</span></a>
type annotation, which indicates a type for the canonical representation of an
object:</p><pre class="verbatim">            String s1 = ...;  // type is (uninterned) "String"
  @Interned String s2 = ...;  // Java type is "String", but checker treats it as "@Interned String"
</pre><p>The type system enforced by the checker plugin ensures that only interned
values can be assigned to <span style="font-family:monospace">s2</span>.</p><p>To specify that <em>all</em> objects of a given type are interned, annotate the
class declaration:</p><pre class="verbatim">  public @Interned class MyInternedClass { ... }
</pre><p>This is equivalent to annotating every use of <span style="font-family:monospace">MyInternedClass</span>, in a
declaration or elsewhere. For example, <span style="font-family:monospace">enum</span> classes are implicitly
so annotated.</p>
<!--TOC subsection id="interning-implicit-qualifiers" Implicit qualifiers-->
<h3 id="interning-implicit-qualifiers" class="subsection">5.2.1&#XA0;&#XA0;Implicit qualifiers</h3><!--SEC END --><p>As described in Section&#XA0;<a href="#effective-qualifier">23.3</a>, the Interning Checker
adds implicit qualifiers, reducing the number of annotations that must
appear in your code.
For example, String literals and the <span style="font-family:monospace">null</span> literal are always considered interned, and
object creation expressions (using <span style="font-family:monospace">new</span>) are never considered
<a href="api/org/checkerframework/checker/interning/qual/Interned.html"><span style="font-family:monospace">@Interned</span></a> unless they are annotated as such, as in</p><pre class="verbatim">@Interned Double internedDoubleZero = new @Interned Double(0); // canonical representation for Double zero
</pre><p>For a complete description of all implicit interning qualifiers, see the
Javadoc for <a href="api/org/checkerframework/checker/interning/InterningAnnotatedTypeFactory.html"><span style="font-family:monospace">InterningAnnotatedTypeFactory</span></a>.</p>
<!--TOC section id="interning-checks" What the Interning Checker checks-->
<h2 id="interning-checks" class="section">5.3&#XA0;&#XA0;What the Interning Checker checks</h2><!--SEC END --><p>Objects of an <a href="api/org/checkerframework/checker/interning/qual/Interned.html"><span style="font-family:monospace">@Interned</span></a> type may be safely compared using the &#X201C;<span style="font-family:monospace">==</span>&#X201D;
operator.</p><p>The checker issues an error in two cases:</p><ol class="enumerate" type=1><li class="li-enumerate">When a reference (in)equality operator (&#X201C;<span style="font-family:monospace">==</span>&#X201D; or &#X201C;<span style="font-family:monospace">!=</span>&#X201D;)
has an operand of non-<a href="api/org/checkerframework/checker/interning/qual/Interned.html"><span style="font-family:monospace">@Interned</span></a> type.</li><li class="li-enumerate">When a non-<a href="api/org/checkerframework/checker/interning/qual/Interned.html"><span style="font-family:monospace">@Interned</span></a> type is used where an <a href="api/org/checkerframework/checker/interning/qual/Interned.html"><span style="font-family:monospace">@Interned</span></a> type
is expected.</li></ol><p>This example shows both sorts of problems:</p><pre class="verbatim">            Date  date;
  @Interned Date idate;
  ...
  if (date == idate) { ... }  // error: reference equality test is unsafe
  idate = date;               // error: idate's referent may no longer be interned
</pre><p><a id="lint-dotequals"></a></p><p>The checker also issues a warning when <span style="font-family:monospace">.equals</span> is used where
<span style="font-family:monospace">==</span> could be safely used. You can disable this behavior via the
javac <span style="font-family:monospace">-Alint</span> command-line option, like so: <span style="font-family:monospace">-Alint=-dotequals</span>.</p><p>For a complete description of all checks performed by
the checker, see the Javadoc for
<a href="api/org/checkerframework/checker/interning/InterningVisitor.html"><span style="font-family:monospace">InterningVisitor</span></a>.</p><p><a id="checking-class"></a>
You can also restrict which types the checker should examine and type-check,
using the <span style="font-family:monospace">-Acheckclass</span> option. For example, to find only the
interning errors related to uses of <span style="font-family:monospace">String</span>, you can pass
<span style="font-family:monospace">-Acheckclass=java.lang.String</span>. The Interning Checker always checks all
subclasses and superclasses of the given class.</p>
<!--TOC subsection id="interning-limitations" Limitations of the Interning Checker-->
<h3 id="interning-limitations" class="subsection">5.3.1&#XA0;&#XA0;Limitations of the Interning Checker</h3><!--SEC END --><p>The Interning Checker conservatively assumes that the <span style="font-family:monospace">Character</span>, <span style="font-family:monospace">Integer</span>,
and <span style="font-family:monospace">Short</span> <span style="font-family:monospace">valueOf</span> methods return a non-interned value. In fact, these
methods sometimes return an interned value and sometimes a non-interned
value, depending on the run-time argument (<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.7">JLS
&#XA7;5.1.7</a>). If you know that the run-time argument to <span style="font-family:monospace">valueOf</span> implies that
the result is interned, then you will need to suppress an error. (An
alternative would be to enhance the Interning Checker to estimate the upper
and lower bounds on char, int, and short values so that it can more
precisely determine whether the result of a given <span style="font-family:monospace">valueOf</span> call is
interned.)</p>
<!--TOC section id="interning-example" Examples-->
<h2 id="interning-example" class="section">5.4&#XA0;&#XA0;Examples</h2><!--SEC END --><p>To try the Interning Checker on a source file that uses the <a href="api/org/checkerframework/checker/interning/qual/Interned.html"><span style="font-family:monospace">@Interned</span></a> qualifier,
use the following command (where <span style="font-family:monospace">javac</span> is the Checker Framework compiler that
is distributed with the Checker Framework):</p><div style="font-size:small;">
<pre class="verbatim">  javac -processor org.checkerframework.checker.interning.InterningChecker examples/InterningExample.java
</pre></div><p>Compilation will complete without errors or warnings.</p><p>To see the checker warn about incorrect usage of annotations, use the following
command:</p><div style="font-size:small;">
<pre class="verbatim">  javac -processor org.checkerframework.checker.interning.InterningChecker examples/InterningExampleWithWarnings.java
</pre></div><p>The compiler will issue an error regarding violation of the semantics of
<a href="api/org/checkerframework/checker/interning/qual/Interned.html"><span style="font-family:monospace">@Interned</span></a>.
</p><p>The Daikon invariant detector
(<a href="http://plse.cs.washington.edu/daikon/"><span style="font-family:monospace">http://plse.cs.washington.edu/daikon/</span></a>) is also annotated with
<a href="api/org/checkerframework/checker/interning/qual/Interned.html"><span style="font-family:monospace">@Interned</span></a>. From directory <span style="font-family:monospace">java</span>,
run <span style="font-family:monospace">make check-interning</span>.</p>
<!--TOC section id="other-interning-annotations" Other interning annotations-->
<h2 id="other-interning-annotations" class="section">5.5&#XA0;&#XA0;Other interning annotations</h2><!--SEC END --><p>The Checker Framework&#X2019;s interning annotations are similar to annotations used
elsewhere.</p><p>If your code is already annotated with a different interning
annotation, you can reuse that effort. The Checker Framework comes with
cleanroom re-implementations of annotations from other tools. It treats
them exactly as if you had written the corresponding annotation from the
Interning Checker, as described in Figure&#XA0;<a href="#fig-interning-refactoring">5.2</a>.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;com.sun.istack.internal.Interned&#XA0; </td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >&#X21D2;
&#XA0;org.checkerframework.checker.interning.qual.Interned&#XA0;
</td></tr>
</table>
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 5.2: Correspondence between other interning annotations and the
Checker Framework&#X2019;s annotations.</td></tr>
</table></div>
<a id="fig-interning-refactoring"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p>Alternately, the Checker Framework can process those other annotations (as
well as its own, if they also appear in your program). The Checker
Framework has its own definition of the annotations on the left side of
Figure&#XA0;<a href="#fig-interning-refactoring">5.2</a>, so that they can be used as type
qualifiers. The Checker Framework interprets them according to the right
side of Figure&#XA0;<a href="#fig-interning-refactoring">5.2</a>.</p><hr>
<!--TOC chapter id="lock-checker" Lock Checker-->
<h1 id="lock-checker" class="chapter">Chapter&#XA0;6&#XA0;&#XA0;Lock Checker</h1><!--SEC END --><p>The Lock Checker prevents certain concurrency errors by enforcing a
locking discipline. A locking discipline indicates which locks must be held
when a given operation occurs. You express the locking discipline by
declaring a variable&#X2019;s type to have the qualifier
<a href="api/org/checkerframework/checker/lock/qual/GuardedBy.html"><span style="font-family:monospace">@GuardedBy</span></a><span style="font-family:monospace"><span style="font-size:small">("</span></span><span style="font-family:monospace"><span style="font-size:small"><em>lockexpr</em></span></span><span style="font-family:monospace"><span style="font-size:small">")</span></span>.
This indicates that the variable&#X2019;s value may
be dereferenced only if the given lock is held.</p><p>To run the Lock Checker, supply the
<span style="font-family:monospace">-processor org.checkerframework.checker.lock.LockChecker</span>
command-line option to javac. The <span style="font-family:monospace">-AconcurrentSemantics</span>
command-line option is always enabled for the Lock Checker (see Section&#XA0;<a href="#faq-concurrency">30.4.4</a>).</p>
<!--TOC section id="lock-guarantees" What the Lock Checker guarantees-->
<h2 id="lock-guarantees" class="section">6.1&#XA0;&#XA0;What the Lock Checker guarantees</h2><!--SEC END --><p>The Lock Checker gives the following guarantee.
Suppose that expression <span style="font-style:italic">e</span> has type
<a href="api/org/checkerframework/checker/lock/qual/GuardedBy.html"><span style="font-family:monospace">@GuardedBy</span></a><span style="font-family:monospace">(</span><span style="font-family:monospace">{</span><span style="font-family:monospace">"x", "y.z"</span><span style="font-family:monospace">}</span><span style="font-family:monospace">)</span>.
Then the value computed for <span style="font-style:italic">e</span> is only dereferenced by a thread when the
thread holds locks <span style="font-family:monospace">x</span> and <span style="font-family:monospace">y.z</span>.
Dereferencing a value is reading or writing one of its fields.
The guarantee about <span style="font-style:italic">e</span>&#X2019;s value
holds not only if the expression <span style="font-style:italic">e</span> is dereferenced
directly, but also if the value was first copied into a variable,
returned as the
result of a method call, etc.
Copying a reference is always
permitted by the Lock Checker, regardless of which locks are held.</p><p>A lock is held if it has been acquired but not yet released.
Java has two types of locks.
A monitor lock is acquired upon entry to a <span style="font-family:monospace">synchronized</span> method or block,
and is released on exit from that method or block.
An explicit lock is acquired by a method call such as
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html#lock--"><span style="font-family:monospace">Lock.lock()</span></a>,
and is released by another method call such as
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html#unlock--"><span style="font-family:monospace">Lock.unlock()</span></a>.
The Lock Checker enforces that any expression whose type implements
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html"><span style="font-family:monospace">Lock</span></a> is used as an
explicit lock, and all other expressions are used as monitor locks.
</p><p>Ensuring that your program obeys its locking discipline is an easy and
effective way to eliminate a common and important class of errors.
If the Lock Checker issues no warnings, then your program obeys its locking discipline.
However, your program might still have other types of concurrency errors.
For example, you might have specified an inadequate locking discipline
because you forgot some <a href="api/org/checkerframework/checker/lock/qual/GuardedBy.html"><span style="font-family:monospace">@GuardedBy</span></a>
annotations.
Your program might release and
re-acquire the lock, when correctness requires it to hold it throughout a
computation.
And, there are other concurrency errors that cannot, or
should not, be solved with locks.</p>
<!--TOC section id="lock-annotations" Lock annotations-->
<h2 id="lock-annotations" class="section">6.2&#XA0;&#XA0;Lock annotations</h2><!--SEC END --><p>This section describes the lock annotations you can write on types and methods.</p>
<!--TOC subsection id="lock-type-qualifiers" Type qualifiers-->
<h3 id="lock-type-qualifiers" class="subsection">6.2.1&#XA0;&#XA0;Type qualifiers</h3><!--SEC END --><dl class="description"><dt class="dt-description"><a href="api/org/checkerframework/checker/lock/qual/GuardedBy.html"><span style="font-weight:bold"><span style="font-family:monospace">@GuardedBy</span></span></a><span style="font-weight:bold"><span style="font-size:small">(</span></span><span style="font-weight:bold"><span style="font-size:small"><em>exprSet</em></span></span><span style="font-weight:bold"><span style="font-size:small">)</span></span></dt><dd class="dd-description">
If a variable <span style="font-family:monospace">x</span> has type <span style="font-family:monospace">@GuardedBy("</span><span style="font-family:monospace"><em>expr</em></span><span style="font-family:monospace">")</span>, then a thread may
dereference the value referred to by <span style="font-family:monospace">x</span> only when the thread holds the
lock that <em>expr</em> currently evaluates to.<p>The <span style="font-family:monospace">@GuardedBy</span> annotation can list multiple expressions, as in
<span style="font-family:monospace">@GuardedBy(</span><span style="font-family:monospace">{</span><span style="font-family:monospace">"</span><span style="font-family:monospace"><em>expr1</em></span><span style="font-family:monospace">", "</span><span style="font-family:monospace"><em>expr2</em></span><span style="font-family:monospace">"</span><span style="font-family:monospace">}</span><span style="font-family:monospace">)</span>, in which case
the dereference is
permitted only if the thread holds all the locks.</p><p>Section&#XA0;<a href="#java-expressions-as-arguments">23.5</a> explains which
expressions the Lock Checker is able to analyze as lock expressions.
These include <span style="font-family:monospace">itself</span>, i.e. the value of the annotated reference
(non-primitive) variable. For example, <span style="font-family:monospace">@GuardedBy("itself") Object o</span>
indicates that the value referenced by <span style="font-family:monospace">o</span> is guarded by the intrinsic
(monitor) lock of the value referenced by <span style="font-family:monospace">o</span>.</p><p><span style="font-family:monospace">@GuardedBy({})</span>, which means the value is always allowed to be
dereferenced, is the default type qualifier that is used for all locations
where the programmer does not
write an explicit locking type qualifier (except all CLIMB-to-top locations
other than upper bounds and exception parameters &#X2014; see Section&#XA0;<a href="#climb-to-top">23.3.2</a>).
(Section&#XA0;<a href="#lock-checker-default-qualifier">6.5.4</a> discusses this choice.)
It is also the conservative
default type qualifier for method parameters in unannotated libraries
(see Chapter&#XA0;<a href="#annotating-libraries">27</a>).</p></dd><dt class="dt-description"><a href="api/org/checkerframework/checker/lock/qual/GuardedByUnknown.html"><span style="font-weight:bold"><span style="font-family:monospace">@GuardedByUnknown</span></span></a></dt><dd class="dd-description">
If a variable <span style="font-family:monospace">x</span> has type <span style="font-family:monospace">@GuardedByUnknown</span>, then
it is not known which locks protect <span style="font-family:monospace">x</span>&#X2019;s value. Those locks might
even be out of scope (inaccessible) and therefore unable to be written
in the annotation.
The practical consequence is that
the value referred to by <span style="font-family:monospace">x</span> can never be dereferenced.<p>Any value can be assigned to a variable of type
<span style="font-family:monospace">@GuardedByUnknown</span>. In particular, if it is written on a
formal parameter, then any value,
including one whose locks are not currently held,
may be passed as an argument.</p><p><span style="font-family:monospace">@GuardedByUnknown</span> is the conservative
default type qualifier for method receivers in unannotated libraries
(see Chapter&#XA0;<a href="#annotating-libraries">27</a>).</p></dd><dt class="dt-description"><a href="api/org/checkerframework/checker/lock/qual/GuardedByBottom.html"><span style="font-weight:bold"><span style="font-family:monospace">@GuardedByBottom</span></span></a></dt><dd class="dd-description">
If a variable <span style="font-family:monospace">x</span> has type <span style="font-family:monospace">@GuardedByBottom</span>, then
the value referred to by <span style="font-family:monospace">x</span> is <span style="font-family:monospace">null</span> and can never
be dereferenced.</dd></dl><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<img src="lock-guardedby.svg">
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 6.1: The subtyping relationship of the Lock Checker&#X2019;s qualifiers.
<span style="font-family:monospace">@GuardedBy({})</span> is the default type qualifier for unannotated
types (except all CLIMB-to-top locations other than upper bounds and exception
parameters &#X2014; see Section&#XA0;<a href="#climb-to-top">23.3.2</a>).
</td></tr>
</table></div>
<a id="fig-lock-guardedby-hierarchy"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p>Figure&#XA0;<a href="#fig-lock-guardedby-hierarchy">6.1</a> shows the type hierarchy of these
qualifiers.
All <span style="font-family:monospace">@GuardedBy</span> annotations are incomparable:
if <em>exprSet1</em> &#X2260; <em>exprSet2</em>, then <span style="font-family:monospace">@GuardedBy(</span><span style="font-family:monospace"><em>exprSet1</em></span><span style="font-family:monospace">)</span> and
<span style="font-family:monospace">@GuardedBy(</span><span style="font-family:monospace"><em>exprSet2</em></span><span style="font-family:monospace">)</span> are siblings in the type hierarchy.
You might expect that
<span style="font-family:monospace">@GuardedBy(</span><span style="font-family:monospace">"x", "y"</span><span style="font-family:monospace">) T</span> is a subtype of <span style="font-family:monospace">@GuardedBy(</span><span style="font-family:monospace">"x"</span><span style="font-family:monospace">) T</span>. The
first type requires two locks to be held, and the second requires only one
lock to be held and so could be used in any situation where both locks are
held. The type system conservatively prohibits this in order to prevent
type-checking loopholes that would result from aliasing and side effects
&#X2014; that is, from having two mutable references, of different types, to the
same data. See
Section&#XA0;<a href="#lock-guardedby-invariant-subtyping">6.4.2</a> for an example
of a problem that would occur if this rule were relaxed.</p>
<!--TOC paragraph id="lock-polymorphic-type-qualifiers" Polymorphic type qualifiers-->
<h5 id="lock-polymorphic-type-qualifiers" class="paragraph">Polymorphic type qualifiers</h5><!--SEC END --><dl class="description"><dt class="dt-description"><a href="api/org/checkerframework/checker/lock/qual/GuardSatisfied.html"><span style="font-weight:bold"><span style="font-family:monospace">@GuardSatisfied</span></span></a><span style="font-weight:bold"><span style="font-size:small">(</span></span><span style="font-weight:bold"><span style="font-size:small"><em>index</em></span></span><span style="font-weight:bold"><span style="font-size:small">)</span></span></dt><dd class="dd-description">
If a variable <span style="font-family:monospace">x</span> has type <span style="font-family:monospace">@GuardSatisfied</span>, then all
lock expressions for <span style="font-family:monospace">x</span>&#X2019;s value are held.<p>As with other qualifier-polymorphism annotations
(Section&#XA0;<a href="#qualifier-polymorphism">22.2</a>), the <em>index</em> argument
indicates when two values are guarded by the same (unknown) set of locks.</p><p><span style="font-family:monospace">@GuardSatisfied</span> is only allowed in method signatures: on
formal parameters (including the receiver) and return types.
It may not be written on fields. Also, it is a limitation of the
current design that <span style="font-family:monospace">@GuardSatisfied</span> may not be written on
array elements or on local variables.</p><p>A return type can only be annotated with <span style="font-family:monospace">@GuardSatisfied(index)</span>,
not <span style="font-family:monospace">@GuardSatisfied</span>.</p><p>See Section&#XA0;<a href="#lock-checker-polymorphism-example">6.4.6</a>
for an example of a use of <span style="font-family:monospace">@GuardSatisfied</span>.</p></dd></dl>
<!--TOC subsection id="lock-declaration-annotations" Declaration annotations-->
<h3 id="lock-declaration-annotations" class="subsection">6.2.2&#XA0;&#XA0;Declaration annotations</h3><!--SEC END --><p>The Lock Checker supports several annotations that specify method behavior.
These are declaration annotations, not type annotations: they apply to the
method itself rather than to some particular type.</p>
<!--TOC paragraph id="lock-method-pre-post-conditions" Method pre-conditions and post-conditions-->
<h5 id="lock-method-pre-post-conditions" class="paragraph">Method pre-conditions and post-conditions</h5><!--SEC END --><dl class="description"><dt class="dt-description">
<a href="api/org/checkerframework/checker/lock/qual/Holding.html"><span style="font-weight:bold"><span style="font-family:monospace">@Holding</span></span></a><span style="font-weight:bold"><span style="font-size:small">(String[] locks)</span></span></dt><dd class="dd-description">
All the given lock expressions
are held at the method call site.</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/lock/qual/EnsuresLockHeld.html"><span style="font-weight:bold"><span style="font-family:monospace">@EnsuresLockHeld</span></span></a><span style="font-weight:bold"><span style="font-size:small">(String[] locks)</span></span></dt><dd class="dd-description">
The given lock
expressions are
locked upon method return if the method
terminates successfully. This is useful for annotating a
method that acquires a lock such as
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantLock.html#lock--"><span style="font-family:monospace">ReentrantLock.lock()</span></a>.</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/lock/qual/EnsuresLockHeldIf.html"><span style="font-weight:bold"><span style="font-family:monospace">@EnsuresLockHeldIf</span></span></a><span style="font-weight:bold"><span style="font-size:small">(String[] locks, boolean result)</span></span></dt><dd class="dd-description">
If the annotated method returns the given
boolean value (true or false), the given lock
expressions are locked upon method return if the method
terminates successfully.
This is useful for annotating a
method that conditionally acquires a lock.
See Section&#XA0;<a href="#ensureslockheld-examples">6.4.4</a> for examples.</dd></dl>
<!--TOC paragraph id="lock-side-effect-specifications" Side effect specifications-->
<h5 id="lock-side-effect-specifications" class="paragraph">Side effect specifications</h5><!--SEC END --><dl class="description"><dt class="dt-description"><a href="api/org/checkerframework/checker/lock/qual/LockingFree.html"><span style="font-weight:bold"><span style="font-family:monospace">@LockingFree</span></span></a></dt><dd class="dd-description">
The method does not acquire or release locks,
directly or indirectly. The method is not <span style="font-family:monospace">synchronized</span>, it contains
no <span style="font-family:monospace">synchronized</span> blocks, it contains no calls to <span style="font-family:monospace">lock</span> or <span style="font-family:monospace">unlock</span>
methods, and it contains no calls to methods that are not themselves <span style="font-family:monospace">@LockingFree</span>.<p>Since
<span style="font-family:monospace">@SideEffectFree</span> implies <span style="font-family:monospace">@LockingFree</span>, if both are applicable
then you only need to write <span style="font-family:monospace">@SideEffectFree</span>.</p></dd><dt class="dt-description"><a href="api/org/checkerframework/checker/lock/qual/ReleasesNoLocks.html"><span style="font-weight:bold"><span style="font-family:monospace">@ReleasesNoLocks</span></span></a></dt><dd class="dd-description">
The method maintains a strictly nondecreasing lock hold count on the
current thread for any locks that were held prior
to the method call. The method might acquire locks but then release
them, or might acquire locks but not release them (in which case it should
also be annotated with
<a href="api/org/checkerframework/checker/lock/qual/EnsuresLockHeld.html"><span style="font-family:monospace">@EnsuresLockHeld</span></a> or
<a href="api/org/checkerframework/checker/lock/qual/EnsuresLockHeldIf.html"><span style="font-family:monospace">@EnsuresLockHeldIf</span></a>).<p>This is the default for methods being type-checked that have no <span style="font-family:monospace">@LockingFree</span>,
<span style="font-family:monospace">@MayReleaseLocks</span>, <span style="font-family:monospace">@SideEffectFree</span>, or <span style="font-family:monospace">@Pure</span>
annotation.</p></dd><dt class="dt-description"><a href="api/org/checkerframework/checker/lock/qual/MayReleaseLocks.html"><span style="font-weight:bold"><span style="font-family:monospace">@MayReleaseLocks</span></span></a></dt><dd class="dd-description">
The method may release locks that were held prior to the method being called.
You can write this when you are certain the method releases locks, or
when you don&#X2019;t know whether the method releases locks.
This is the conservative default for methods in unannotated libraries (see Chapter&#XA0;<a href="#annotating-libraries">27</a>).</dd></dl>
<!--TOC section id="lock-type-checking-rules" Type-checking rules-->
<h2 id="lock-type-checking-rules" class="section">6.3&#XA0;&#XA0;Type-checking rules</h2><!--SEC END --><p>In addition to the standard subtyping rules enforcing the subtyping relationship
described in Figure&#XA0;<a href="#fig-lock-guardedby-hierarchy">6.1</a>, the Lock Checker enforces
the following additional rules.</p>
<!--TOC subsection id="lock-type-checking-rules-polymorphic-qualifiers" Polymorphic qualifiers-->
<h3 id="lock-type-checking-rules-polymorphic-qualifiers" class="subsection">6.3.1&#XA0;&#XA0;Polymorphic qualifiers</h3><!--SEC END --><dl class="description"><dt class="dt-description"><span style="font-weight:bold"><span style="font-family:monospace">@GuardSatisfied</span></span></dt><dd class="dd-description"><p>The overall rules for polymorphic qualifiers are given in
Section&#XA0;<a href="#qualifier-polymorphism">22.2</a>.</p><p>Here are additional constraints for (pseudo-)assignments:</p><ul class="itemize"><li class="li-itemize">
If the left-hand side has type <span style="font-family:monospace">@GuardSatisfied</span> (with or without an index),
then all locks mentioned in the right-hand side&#X2019;s <span style="font-family:monospace">@GuardedBy</span> type
must be currently held.
</li><li class="li-itemize">A formal parameter with type qualifier <span style="font-family:monospace">@GuardSatisfied</span> without an
index cannot be assigned to.
</li><li class="li-itemize">If the left-hand side is a formal parameter with type
<span style="font-family:monospace">@GuardSatisfied(</span><span style="font-family:monospace"><em>index</em></span><span style="font-family:monospace">)</span>, the right-hand-side must have
identical <span style="font-family:monospace">@GuardSatisfied(</span><span style="font-family:monospace"><em>index</em></span><span style="font-family:monospace">)</span> type.
</li></ul><p>If a formal parameter type is
annotated with <span style="font-family:monospace">@GuardSatisfied</span> without an index, then that formal parameter
type is unrelated to every other type in the <span style="font-family:monospace">@GuardedBy</span> hierarchy,
including other occurrences of <span style="font-family:monospace">@GuardSatisfied</span> without an index.</p><p><span style="font-family:monospace">@GuardSatisfied</span> may not be used on formal parameters, receivers, or
return types of a method annotated with <span style="font-family:monospace">@MayReleaseLocks</span>.
</p></dd></dl>
<!--TOC subsection id="lock-type-checking-rules-dereferences" Dereferences-->
<h3 id="lock-type-checking-rules-dereferences" class="subsection">6.3.2&#XA0;&#XA0;Dereferences</h3><!--SEC END --><dl class="description"><dt class="dt-description"><span style="font-weight:bold"><span style="font-family:monospace">@GuardedBy</span></span></dt><dd class="dd-description">
An expression of type <span style="font-family:monospace">@GuardedBy(</span><span style="font-family:monospace"><em>eset</em></span><span style="font-family:monospace">)</span> may be dereferenced only
if all locks in <em>eset</em> are held.</dd><dt class="dt-description"><span style="font-weight:bold"><span style="font-family:monospace">@GuardSatisfied</span></span></dt><dd class="dd-description">
An expression of type <span style="font-family:monospace">@GuardSatisfied</span> may be dereferenced.</dd><dt class="dt-description"><span style="font-weight:bold">Not </span><span style="font-weight:bold"><span style="font-family:monospace">@GuardedBy</span></span><span style="font-weight:bold"> or </span><span style="font-weight:bold"><span style="font-family:monospace">@GuardSatisfied</span></span></dt><dd class="dd-description">
An expression whose type is not annotated with <span style="font-family:monospace">@GuardedBy</span> or
<span style="font-family:monospace">@GuardSatisfied</span> may not be dereferenced.
</dd></dl>
<!--TOC subsection id="lock-type-checking-rules-primitives" Primitive types, boxed primitive types, and Strings-->
<h3 id="lock-type-checking-rules-primitives" class="subsection">6.3.3&#XA0;&#XA0;Primitive types, boxed primitive types, and Strings</h3><!--SEC END --><p>Primitive types, boxed primitive types (such as <span style="font-family:monospace">java.lang.Integer</span>), and type <span style="font-family:monospace">java.lang.String</span>
are implicitly annotated with <span style="font-family:monospace">@GuardedBy({})</span>.
It is an error for the programmer to annotate any of these types with an annotation from
the <span style="font-family:monospace">@GuardedBy</span> type hierarchy, including <span style="font-family:monospace">@GuardedBy({})</span>.</p>
<!--TOC subsection id="lock-type-checking-rules-overriding" Overriding-->
<h3 id="lock-type-checking-rules-overriding" class="subsection">6.3.4&#XA0;&#XA0;Overriding</h3><!--SEC END --><dl class="description"><dt class="dt-description"><span style="font-weight:bold">Overriding methods annotated with </span><span style="font-weight:bold"><span style="font-family:monospace">@Holding</span></span></dt><dd class="dd-description">
If class <span style="font-style:italic">B</span> overrides method <span style="font-style:italic">m</span> from class <span style="font-style:italic">A</span>, then the expressions in
<span style="font-style:italic">B</span>&#X2019;s <span style="font-family:monospace">@Holding</span>
annotation must be a subset of or equal to that of <span style="font-style:italic">A</span>&#X2019;s <span style="font-family:monospace">@Holding</span>
annotation..</dd><dt class="dt-description"><span style="font-weight:bold">Overriding methods annotated with side effect annotations</span></dt><dd class="dd-description">
If class <span style="font-style:italic">B</span> overrides method <span style="font-style:italic">m</span> from class <span style="font-style:italic">A</span>, then
the side effect annotation on <span style="font-style:italic">B</span>&#X2019;s declaration of <span style="font-style:italic">m</span>
must be at least as strong as that in <span style="font-style:italic">A</span>&#X2019;s declaration of <span style="font-style:italic">m</span>.
From weakest to strongest, the side effect annotations
processed by the Lock Checker are:
<pre class="verbatim">  @MayReleaseLocks
  @ReleasesNoLocks
  @LockingFree
  @SideEffectFree
  @Pure
</pre></dd></dl>
<!--TOC subsection id="lock-type-checking-rules-polymorphic-side-effects" Side effects-->
<h3 id="lock-type-checking-rules-polymorphic-side-effects" class="subsection">6.3.5&#XA0;&#XA0;Side effects</h3><!--SEC END --><dl class="description"><dt class="dt-description"><span style="font-weight:bold">Releasing explicit locks</span></dt><dd class="dd-description">
Any method that releases an explicit lock must be annotated
with <span style="font-family:monospace">@MayReleaseLocks</span>.
The Lock Checker issues a warning if it encounters a method declaration
annotated with <span style="font-family:monospace">@MayReleaseLocks</span> and having a formal parameter
or receiver annotated with <span style="font-family:monospace">@GuardSatisfied</span>. This is because
the Lock Checker cannot guarantee that the guard will be satisfied
throughout the body of a method if that method may release a lock.</dd><dt class="dt-description"><span style="font-weight:bold">No side effects on lock expressions</span></dt><dd class="dd-description">
If expression <em>expr</em> is used to acquire a lock, then
<em>expr</em> must evaluate to the same value, starting from when
<em>expr</em> is used to acquire a lock until <em>expr</em> is used to
release the lock.
An expression is used to acquire a lock if it is the receiver at a
call site of a <span style="font-family:monospace">synchronized</span> method, is the expression in a
<span style="font-family:monospace">synchronized</span> block, or is the argument to a <span style="font-family:monospace">lock</span> method.</dd><dt class="dt-description"><span style="font-weight:bold">Locks are released after possible side effects</span></dt><dd class="dd-description">
After a call to a method annotated with <span style="font-family:monospace">@LockingFree</span>,
<span style="font-family:monospace">@ReleasesNoLocks</span>, <span style="font-family:monospace">@SideEffectFree</span>, or <span style="font-family:monospace">@Pure</span>,
the Lock Checker&#X2019;s estimate of held locks
after a method call is the same as that prior to the method call.
After a call to a method annotated with <span style="font-family:monospace">@MayReleaseLocks</span>,
the estimate of held locks is conservatively reset to the empty set,
except for those locks specified to be held after the call
by an <span style="font-family:monospace">@EnsuresLockHeld</span> or <span style="font-family:monospace">@EnsuresLockHeldIf</span>
annotation on the method. Assignments to variables also
cause the estimate of held locks to be conservatively reduced
to a smaller set if the Checker Framework determines that the
assignment might have side-effected a lock expression.
For more information on side effects, please refer to
Section&#XA0;<a href="#type-refinement-purity">23.4.5</a>.</dd></dl>
<!--TOC section id="lock-examples" Examples-->
<h2 id="lock-examples" class="section">6.4&#XA0;&#XA0;Examples</h2><!--SEC END --><p>The Lock Checker guarantees that a value that was computed from an expression of <span style="font-family:monospace">@GuardedBy</span> type is
dereferenced only when the current thread holds all the expressions in the
<span style="font-family:monospace">@GuardedBy</span> annotation.</p>
<!--TOC subsection id="lock-examples-guardedby" Examples of @GuardedBy-->
<h3 id="lock-examples-guardedby" class="subsection">6.4.1&#XA0;&#XA0;Examples of @GuardedBy</h3><!--SEC END --><p>The following example demonstrates the basic
type-checking rules.</p><pre class="verbatim">class MyClass {
  final ReentrantLock lock; // Initialized in the constructor

  @GuardedBy("lock") Object x = new Object();
  @GuardedBy("lock") Object y = x; // OK, since dereferences of y will require "lock" to be held.
  @GuardedBy({}) Object z = x; // ILLEGAL since dereferences of z don't require "lock" to be held.
  @GuardedBy("lock") Object myMethod() { // myMethod is implicitly annotated with @ReleasesNoLocks.
     return x; // OK because the return type is annotated with @GuardedBy("lock")
  }

  [...]

  void exampleMethod() {
     x.toString(); // ILLEGAL because the lock is not known to be held
     y.toString(); // ILLEGAL because the lock is not known to be held
     myMethod().toString(); // ILLEGAL because the lock is not known to be held
     lock.lock();
     x.toString();  // OK: the lock is known to be held
     y.toString();  // OK: the lock is known to be held, and toString() is annotated with @SideEffectFree.
     myMethod().toString(); // OK: the lock is known to be held, since myMethod
                            // is implicitly annotated with @ReleasesNoLocks.
  }
}
</pre><p>Note that the expression <span style="font-family:monospace">new Object()</span> is inferred to have type <span style="font-family:monospace">@GuardedBy("lock")</span>
because it is immediately assigned to a newly-declared
variable having type annotation <span style="font-family:monospace">@GuardedBy("lock")</span>. You could
explicitly write <span style="font-family:monospace">new @GuardedBy("lock") Object()</span> but it is not
required.</p><p>The following example demonstrates that using <span style="font-family:monospace">itself</span> as a lock expression
allows a guarded value to be dereferenced even when the original
variable name the value was originally assigned to falls out of scope.</p><pre class="verbatim">class MyClass {
  private final @GuardedBy("itself") Object x = new Object();
  void method() {
    x.toString(); // ILLEGAL because x is not known to be held.
    synchronized(x) {
      x.toString(); // OK: x is known to be held.
    }
  }

  public @GuardedBy("itself") Object get_x() {
    return x; // OK, since the return type is @GuardedBy("itself").
  }
}

class MyOtherClass {
  void method() {
    MyClass m = new MyClass();
    final @GuardedBy("itself") Object o = m.get_x();
    o.toString(); // ILLEGAL because o is not known to be held.
    synchronized(o) {
      o.toString(); // OK: o is known to be held.
    }
  }
}
</pre>
<!--TOC subsection id="lock-guardedby-invariant-subtyping" @GuardedBy({&#X201C;a&#X201D;, &#X201C;b&#X201D;}) is not a subtype of @GuardedBy({&#X201C;a&#X201D;})-->
<h3 id="lock-guardedby-invariant-subtyping" class="subsection">6.4.2&#XA0;&#XA0;@GuardedBy({&#X201C;a&#X201D;, &#X201C;b&#X201D;}) is not a subtype of @GuardedBy({&#X201C;a&#X201D;})</h3><!--SEC END --><p><span style="font-weight:bold">@GuardedBy(exprSet)</span></p><p>The following example demonstrates the reason the Lock Checker enforces the
following rule: if <em>exprSet1</em> &#X2260; <em>exprSet2</em>, then
<span style="font-family:monospace">@GuardedBy(</span><span style="font-family:monospace"><em>exprSet1</em></span><span style="font-family:monospace">)</span> and <span style="font-family:monospace">@GuardedBy(</span><span style="font-family:monospace"><em>exprSet2</em></span><span style="font-family:monospace">)</span> are siblings in the type
hierarchy.</p><pre class="verbatim">class MyClass {
    final Object lockA = new Object();
    final Object lockB = new Object();
    @GuardedBy("lockA") Object x = new Object();
    @GuardedBy({"lockA", "lockB"}) Object y = new Object();
    void myMethod() {
        y = x;      // ILLEGAL; if legal, later statement x.toString() would cause trouble
        synchronized(lockA) {
          x.toString();  // dereferences y's value without holding lock lockB
        }
    }
}
</pre><p>If the Lock Checker permitted the assignment
<span style="font-family:monospace">y = x;</span>, then the undesired dereference would be possible.</p>
<!--TOC subsection id="lock-examples-holding" Examples of @Holding-->
<h3 id="lock-examples-holding" class="subsection">6.4.3&#XA0;&#XA0;Examples of @Holding</h3><!--SEC END --><p>The following example shows the interaction between <span style="font-family:monospace">@GuardedBy</span> and
<span style="font-family:monospace">@Holding</span>:</p><pre class="verbatim">  void helper1(@GuardedBy("myLock") Object a) {
    a.toString(); // ILLEGAL: the lock is not held
    synchronized(myLock) {
      a.toString();  // OK: the lock is held
    }
  }
  @Holding("myLock")
  void helper2(@GuardedBy("myLock") Object b) {
    b.toString(); // OK: the lock is held
  }
  void helper3(@GuardedBy("myLock") Object d) {
    d.toString(); // ILLEGAL: the lock is not held
  }
  void myMethod2(@GuardedBy("myLock") Object e) {
    helper1(e);  // OK to pass to another routine without holding the lock
                 // (but helper1's body has an error)
    e.toString(); // ILLEGAL: the lock is not held
    synchronized (myLock) {
      helper2(e); // OK: the lock is held
      helper3(e); // OK, but helper3's body has an error
    }
  }
</pre>
<!--TOC subsection id="ensureslockheld-examples" Examples of @EnsuresLockHeld and @EnsuresLockHeldIf-->
<h3 id="ensureslockheld-examples" class="subsection">6.4.4&#XA0;&#XA0;Examples of @EnsuresLockHeld and @EnsuresLockHeldIf</h3><!--SEC END --><p><span style="font-family:monospace">@EnsuresLockHeld</span> and <span style="font-family:monospace">@EnsuresLockHeldIf</span> are primarily intended
for annotating JDK locking methods, as in:</p><pre class="verbatim">package java.util.concurrent.locks;

class ReentrantLock {

    @EnsuresLockHeld("this")
    public void lock();

    @EnsuresLockHeldIf (expression="this", result=true)
    public boolean tryLock();

    ...
}
</pre><p>They can also be used to annotate user methods, particularly for
higher-level lock constructs such as a Monitor, as in this simplified example:</p><pre class="verbatim">public class Monitor {

    private final ReentrantLock lock; // Initialized in the constructor

    ...

    @EnsuresLockHeld("lock")
    public void enter() {
       lock.lock();
    }

    ...
}
</pre>
<!--TOC subsection id="lock-lockingfree-example" Example of @LockingFree, @ReleasesNoLocks, and @MayReleaseLocks-->
<h3 id="lock-lockingfree-example" class="subsection">6.4.5&#XA0;&#XA0;Example of @LockingFree, @ReleasesNoLocks, and @MayReleaseLocks</h3><!--SEC END --><p><span style="font-family:monospace">@LockingFree</span> is useful when a method does not make any use of synchronization
or locks but causes other side effects (hence <span style="font-family:monospace">@SideEffectFree</span> is not appropriate).
<span style="font-family:monospace">@SideEffectFree</span> implies <span style="font-family:monospace">@LockingFree</span>, therefore if both are applicable,
you should only write <span style="font-family:monospace">@SideEffectFree</span>. <span style="font-family:monospace">@ReleasesNoLocks</span> has a weaker guarantee
than <span style="font-family:monospace">@LockingFree</span>, and <span style="font-family:monospace">@MayReleaseLocks</span> provides no guarantees.</p><pre class="verbatim">private Object myField;
private final ReentrantLock lock; // Initialized in the constructor
private @GuardedBy("lock") Object x; // Initialized in the constructor

[...]

// This method does not use locks or synchronization, but it cannot
// be annotated as @SideEffectFree since it alters myField.
@LockingFree
void myMethod() {
  myField = new Object();
}

@SideEffectFree
int mySideEffectFreeMethod() {
  return 0;
}

@MayReleaseLocks
void myUnlockingMethod() {
  lock.unlock();
}

@ReleasesNoLocks
void myLockingMethod() {
  lock.lock();
}

@MayReleaseLocks
void clientMethod() {
  if (lock.tryLock()) {
    x.toString(); // OK: the lock is held
    myMethod();
    x.toString(); // OK: the lock is still known to be held since myMethod is locking-free
    mySideEffectFreeMethod();
    x.toString(); // OK: the lock is still known to be held since mySideEffectFreeMethod
                  // is side-effect-free
    myUnlockingMethod();
    x.toString(); // ILLEGAL: myUnlockingMethod may have released a lock
  }
  if (lock.tryLock()) {
    x.toString(); // OK: the lock is held
    myLockingMethod();
    x.toString(); // OK: the lock is held
  }
  if (lock.isHeldByCurrentThread()) {
    x.toString(); // OK: the lock is known to be held
  }
}
</pre>
<!--TOC subsection id="lock-checker-polymorphism-example" Polymorphism and method formal parameters with unknown guards-->
<h3 id="lock-checker-polymorphism-example" class="subsection">6.4.6&#XA0;&#XA0;Polymorphism and method formal parameters with unknown guards</h3><!--SEC END --><p>The polymorphic <span style="font-family:monospace">@GuardSatisfied</span> type annotation allows a method body
to dereference the method&#X2019;s formal parameters even if the
<span style="font-family:monospace">@GuardedBy</span> annotations on the actual parameters are unknown at
the method declaration site.</p><p>The declaration of
<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#append-java.lang.String-"><span style="font-family:monospace">StringBuffer.append(String str)</span></a>
is annotated as:</p><pre class="verbatim">@LockingFree
public @GuardSatisfied(1) StringBuffer append(@GuardSatisfied(1) StringBuffer this,
                                              @GuardSatisfied(2) String str)
</pre><p>The method manipulates the values of its arguments, so all their locks must
be held. However, the declaration does not know what those are and they
might not even be in scope at the declaration. Therefore, the declaration
cannot use <span style="font-family:monospace">@GuardedBy</span> and must use <span style="font-family:monospace">@GuardSatisfied</span>. The arguments to
<span style="font-family:monospace">@GuardSatisfied</span> indicate that the receiver and result (which are the
same value) are guarded by the same (unknown, possibly empty) set of locks,
and the <span style="font-family:monospace">str</span> parameter may be guarded by a different set of locks.</p><p>The <span style="font-family:monospace">@LockingFree</span> annotation indicates that
this method makes no use of
locks or synchronization.</p><p>Given these annotations on <span style="font-family:monospace">append</span>, the following code type-checks:</p><pre class="verbatim">final ReentrantLock lock1, lock2; // Initialized in the constructor
@GuardedBy("lock1") StringBuffer filename;
@GuardedBy("lock2") StringBuffer extension;
...
lock1.lock();
lock2.lock();
filename = filename.append(extension);
</pre>
<!--TOC section id="lock-details" More locking details-->
<h2 id="lock-details" class="section">6.5&#XA0;&#XA0;More locking details</h2><!--SEC END --><p>This section gives some details that are helpful for understanding how Java
locking and the Lock Checker works.</p>
<!--TOC subsection id="lock-two-types" Two types of locking: monitor locks and explicit locks-->
<h3 id="lock-two-types" class="subsection">6.5.1&#XA0;&#XA0;Two types of locking: monitor locks and explicit locks</h3><!--SEC END --><p>Java provides two types of locking: monitor locks and explicit locks.</p><ul class="itemize"><li class="li-itemize">
A <span style="font-family:monospace">synchronized(</span><span style="font-family:monospace"><em>E</em></span><span style="font-family:monospace">)</span> block acquires the lock on the value of
<em>E</em>; similarly, a method declared using the <span style="font-family:monospace">synchronized</span> method
modifier acquires the lock on the method receiver when called.
(More precisely,
the current thread locks the monitor associated with the value of
<em>E</em>; see <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.1">JLS &#XA7;17.1</a>.)
The lock is automatically released when execution exits the block or the
method body, respectively.
We use the term &#X201C;monitor lock&#X201D; for a lock acquired using a
<span style="font-family:monospace">synchronized</span> block or <span style="font-family:monospace">synchronized</span> method modifier.
</li><li class="li-itemize">A method call, such as
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html#lock--"><span style="font-family:monospace">Lock.lock()</span></a>,
acquires a lock that implements the
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html"><span style="font-family:monospace">Lock</span></a>
interface.
The lock is released by another method call, such as
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html#unlock--"><span style="font-family:monospace">Lock.unlock()</span></a>.
We use the term &#X201C;explicit lock&#X201D; for a lock expression acquired in this
way.
</li></ul><p>You should not mix the two varieties of locking, and the Lock Checker
enforces this. To prevent an object from being used both as a monitor and
an explicit lock, the Lock Checker issues a warning if a
<span style="font-family:monospace">synchronized(</span><span style="font-family:monospace"><em>E</em></span><span style="font-family:monospace">)</span> block&#X2019;s expression <span style="font-family:monospace"><em>E</em></span> has a type that
implements <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html"><span style="font-family:monospace">Lock</span></a>.
</p>
<!--TOC subsection id="lock-aliasing" Held locks and held expressions; aliasing-->
<h3 id="lock-aliasing" class="subsection">6.5.2&#XA0;&#XA0;Held locks and held expressions; aliasing</h3><!--SEC END --><p>Whereas Java locking is defined in terms of values, Java programs are
written in terms of expressions.
We say that a lock expression is held if the value to which the expression
currently evaluates is held.</p><p>The Lock Checker conservatively estimates the expressions that are held at
each point in a program.
The Lock Checker does not track aliasing
(different expressions that evaluate to the same value); it only considers
the exact expression used to acquire a lock to be held. After any statement
that might side-effect a held expression or a lock expression, the Lock
Checker conservatively considers the expression to be no longer held.</p><p>Section&#XA0;<a href="#java-expressions-as-arguments">23.5</a> explains which Java
expressions the Lock Checker is able to analyze as lock expressions.</p><p>The <span style="font-family:monospace">@LockHeld</span> and <span style="font-family:monospace">@LockPossiblyHeld</span> type qualifiers are used internally by the Lock Checker
and should never be written by the programmer.
If you
see a warning mentioning <span style="font-family:monospace">@LockHeld</span> or <span style="font-family:monospace">@LockPossiblyHeld</span>,
please contact the Checker Framework developers as it is likely to
indicate a bug in the Checker Framework.</p>
<!--TOC subsection id="lock-runtime-checks" Run-time checks for locking-->
<h3 id="lock-runtime-checks" class="subsection">6.5.3&#XA0;&#XA0;Run-time checks for locking</h3><!--SEC END --><p>When you perform a run-time check for locking, such as
<span style="font-family:monospace">if (explicitLock.isHeldByCurrentThread()){...}</span> or
<span style="font-family:monospace">if (Thread.holdsLock(monitorLock)){...}</span>,
then the Lock Checker considers the lock expression to be held
within the scope of the test. For more details, see
Section&#XA0;<a href="#type-refinement">23.4</a>.
</p>
<!--TOC subsection id="lock-checker-default-qualifier" Discussion of default qualifier-->
<h3 id="lock-checker-default-qualifier" class="subsection">6.5.4&#XA0;&#XA0;Discussion of default qualifier</h3><!--SEC END --><p>The default qualifier for unannotated types is <span style="font-family:monospace">@GuardedBy({})</span>.
This default forces you to write explicit <span style="font-family:monospace">@GuardSatisfied</span> in method
signatures in the common case that clients ensure that all locks are held.</p><p>It might seem that <span style="font-family:monospace">@GuardSatisfied</span> would be a better default for
method signatures, but such a default would require even more annotations.
The reason is that <span style="font-family:monospace">@GuardSatisfied</span> cannot be used on fields. If
<span style="font-family:monospace">@GuardedBy({})</span> is the default for fields but <span style="font-family:monospace">@GuardSatisfied</span> is the
default for parameters and return types, then getters, setters, and many
other types of methods do not type-check without explicit lock qualifiers.</p>
<!--TOC subsection id="lock-checker-holding" Discussion of <span style="font-family:monospace">@Holding</span>-->
<h3 id="lock-checker-holding" class="subsection">6.5.5&#XA0;&#XA0;Discussion of <span style="font-family:monospace">@Holding</span></h3><!--SEC END --><p>A programmer might choose to use the <span style="font-family:monospace">@Holding</span> method annotation in
two different ways: to specify correctness constraints for a
synchronization protocol, or to summarize intended usage. Both of these
approaches are useful, and the Lock Checker supports both.</p>
<!--TOC paragraph id="lock-checker-holding-synchronization-protocol" Synchronization protocol-->
<h5 id="lock-checker-holding-synchronization-protocol" class="paragraph">Synchronization protocol</h5><!--SEC END --><p><span style="font-family:monospace">@Holding</span> can specify a synchronization protocol that
is not expressible as locks over the parameters to a method. For example, a global lock
or a lock on a different object might need to be held. By requiring locks to be
held, you can create protocol primitives without giving up
the benefits of the annotations and checking of them.</p>
<!--TOC paragraph id="lock-checker-holding-method-summary" Method summary that simplifies reasoning-->
<h5 id="lock-checker-holding-method-summary" class="paragraph">Method summary that simplifies reasoning</h5><!--SEC END --><p><span style="font-family:monospace">@Holding</span> can be a method summary that simplifies reasoning. In
this case, the <span style="font-family:monospace">@Holding</span> doesn&#X2019;t necessarily introduce a new
correctness constraint; the program might be correct even if the lock
were not already acquired.</p><p>Rather, here <span style="font-family:monospace">@Holding</span> expresses a fact about execution: when
execution reaches this point, the following locks are known to be already held. This
fact enables people and tools to reason intra- rather than
inter-procedurally.</p><p>In Java, it is always legal to re-acquire a lock that is already held,
and the re-acquisition always works. Thus, whenever you write</p><pre class="verbatim">  @Holding("myLock")
  void myMethod() {
    ...
  }
</pre><p>it would be equivalent, from the point of view of which locks are held
during the body, to write</p><pre class="verbatim">  void myMethod() {
    synchronized (myLock) {   // no-op:  re-acquire a lock that is already held
      ...
    }
  }
</pre><p>It is better to write a <span style="font-family:monospace">@Holding</span> annotation rather than writing the
extra synchronized block. Here are reasons:</p><ul class="itemize"><li class="li-itemize">
The annotation documents the fact that the lock is intended to already be
held; that is, the method&#X2019;s contract requires that the lock be held when
the method is called.
</li><li class="li-itemize">The Lock Checker enforces that the lock is held when the method is
called, rather than masking a programmer error by silently re-acquiring
the lock.
</li><li class="li-itemize">The version with a synchronized statement can deadlock if, due to a programmer error,
the lock is not already held. The Lock Checker prevents this type of
error.
</li><li class="li-itemize">The annotation has no run-time overhead. The lock re-acquisition
consumes time, even if it succeeds.
</li></ul>
<!--TOC section id="lock-other-annotations" Other lock annotations-->
<h2 id="lock-other-annotations" class="section">6.6&#XA0;&#XA0;Other lock annotations</h2><!--SEC END --><p>The Checker Framework&#X2019;s lock annotations are similar to annotations used
elsewhere.</p><p>If your code is already annotated with a different lock
annotation, you can reuse that effort. The Checker Framework comes with
cleanroom re-implementations of annotations from other tools. It treats
them exactly as if you had written the corresponding annotation from the
Lock Checker, as described in Figure&#XA0;<a href="#fig-lock-refactoring">6.2</a>.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;net.jcip.annotations.GuardedBy&#XA0; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > &#XA0;javax.annotation.concurrent.GuardedBy&#XA0; </td></tr>
</table></td><td style="text-align:left;white-space:nowrap" >&#X21D2;
&#XA0;org.checkerframework.checker.lock.qual.GuardedBy (for fields) or &#X2026;Holding (for methods)&#XA0;
</td></tr>
</table></div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 6.2: Correspondence between other lock annotations and the
Checker Framework&#X2019;s annotations.</td></tr>
</table></div>
<a id="fig-lock-refactoring"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote>
<!--TOC subsection id="lock-jcip-annotations" Relationship to annotations in <em>Java Concurrency in Practice</em>-->
<h3 id="lock-jcip-annotations" class="subsection">6.6.1&#XA0;&#XA0;Relationship to annotations in <em>Java Concurrency in Practice</em></h3><!--SEC END --><p>The book <a href="http://jcip.net/"><em>Java Concurrency in Practice</em></a>&#XA0;[<a href="#Goetz2006">GPB+06</a>] defines a
<a href="http://jcip.net.s3-website-us-east-1.amazonaws.com/annotations/doc/net/jcip/annotations/GuardedBy.html"><span style="font-family:monospace">@GuardedBy</span></a> annotation that is the inspiration for ours. The book&#X2019;s
<span style="font-family:monospace">@GuardedBy</span> serves two related but distinct purposes:</p><ul class="itemize"><li class="li-itemize">
When applied to a field, it means that the given lock must be held when
accessing the field. The lock acquisition and the field access may occur
arbitrarily far in the future.
</li><li class="li-itemize">When applied to a method, it means that the given lock must be held by
the caller at the time that the method is called &#X2014; in other words, at
the time that execution passes the <span style="font-family:monospace">@GuardedBy</span> annotation.
</li></ul><p>The Lock Checker renames the method annotation to
<a href="api/org/checkerframework/checker/lock/qual/Holding.html"><span style="font-family:monospace">@Holding</span></a>, and it generalizes the
<a href="api/org/checkerframework/checker/lock/qual/GuardedBy.html"><span style="font-family:monospace">@GuardedBy</span></a> annotation into a type annotation
that can apply not just to a field but to an arbitrary type (including the
type of a parameter, return value, local variable, generic type parameter,
etc.). Another important distinction is that the Lock Checker&#X2019;s
annotations express and enforce a locking discipline over values, just like
the JLS expresses Java&#X2019;s locking semantics; by contrast, JCIP&#X2019;s annotations
express a locking discipline that protects variable names and does not
prevent race conditions.
This makes the annotations more expressive and also more amenable
to automated checking. It also accommodates the distinct
meanings of the two annotations, and resolves ambiguity when <span style="font-family:monospace">@GuardedBy</span>
is written in a location that might apply to either the method or the
return type.</p><p>(The JCIP book gives some rationales for reusing the annotation name for
two purposes. One rationale is
that there are fewer annotations to learn. Another rationale is
that both variables and methods are &#X201C;members&#X201D; that can be &#X201C;accessed&#X201D;
and <span style="font-family:monospace">@GuardedBy</span> creates preconditions for doing so.
Variables can be accessed by reading or writing them (putfield, getfield),
and methods can be accessed by calling them (invokevirtual,
invokeinterface). This informal intuition is
inappropriate for a tool that requires precise semantics.)</p>
<!--TOC section id="lock-extensions" Possible extensions-->
<h2 id="lock-extensions" class="section">6.7&#XA0;&#XA0;Possible extensions</h2><!--SEC END --><p>The Lock Checker validates some uses of locks, but not all. It would be
possible to enrich it with additional annotations. This would increase the
programmer annotation burden, but would provide additional guarantees.</p><p>Lock ordering: Specify that one lock must be acquired before or after
another, or specify a global ordering for all locks. This would prevent
deadlock.</p><p>Not-holding: Specify that a method must not be called if any of the listed
locks are held.</p><p>These features are supported by
<a href="http://clang.llvm.org/docs/ThreadSafetyAnalysis.html">Clang&#X2019;s
thread-safety analysis</a>.</p><hr>
<!--TOC chapter id="fenum-checker" Fake Enum Checker-->
<h1 id="fenum-checker" class="chapter">Chapter&#XA0;7&#XA0;&#XA0;Fake Enum Checker</h1><!--SEC END --><p>Java&#X2019;s
<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9"><span style="font-family:monospace">enum</span></a>
keyword lets you define an enumeration type: a finite set of distinct values
that are related to one another but are disjoint from all other
types, including other enumerations.
Before enums were added to Java, there were two ways to encode an
enumeration, both of which are error-prone:</p><dl class="description"><dt class="dt-description">
<span style="font-weight:bold">the fake enum pattern</span></dt><dd class="dd-description"> a set of <span style="font-family:monospace">int</span> or <span style="font-family:monospace">String</span>
constants (as often found in older C code).</dd><dt class="dt-description"><span style="font-weight:bold">the </span><a href="http://www.oracle.com/technetwork/java/page1-139488.html"><span style="font-weight:bold">typesafe
enum pattern</span></a></dt><dd class="dd-description"> a class with private constructor.
</dd></dl><p>Sometimes you need to use the fake enum pattern,
rather than a real enum or the typesafe enum pattern.
One reason is backward-compatibility. A public API that predates Java&#X2019;s
enum keyword may use <span style="font-family:monospace">int</span> constants; it cannot be changed, because
doing so would break existing clients. For example, Java&#X2019;s JDK still uses
<span style="font-family:monospace">int</span> constants in the AWT and Swing frameworks, and Android also uses
<span style="font-family:monospace">int</span> constants rather than Java enums.
Another reason is performance, especially in environments with limited
resources. Use of an int instead of an object can
reduce code size, memory requirements, and run time.
</p><p>In cases when code has to use the fake enum pattern, the Fake Enum Checker,
or Fenum Checker, gives the same safety guarantees as a true enumeration type.
The developer can introduce new types that are distinct from all values of the
base type and from all other fake enums. Fenums can be introduced for
primitive types as well as for reference types.</p><p>Figure&#XA0;<a href="#fig-fenum-hierarchy">7.1</a> shows part of the type hierarchy for the
Fenum type system.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<img src="fenum.svg">
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 7.1: Partial type hierarchy for the Fenum type system.
There are two forms of fake enumeration annotations &#X2014; above, illustrated
by <span style="font-family:monospace">@Fenum("A")</span> and <span style="font-family:monospace">@FenumC</span>.
See Section&#XA0;<a href="#fenum-annotations">7.1</a> for descriptions of how to
introduce both types of fenums. The type qualifiers in gray
(<span style="font-family:monospace">@FenumTop</span>, <span style="font-family:monospace">@FenumUnqualified</span>, and <span style="font-family:monospace">@FenumBottom</span>)
should never be written in
source code; they are used internally by the type system.</td></tr>
</table></div>
<a id="fig-fenum-hierarchy"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote>
<!--TOC section id="fenum-annotations" Fake enum annotations-->
<h2 id="fenum-annotations" class="section">7.1&#XA0;&#XA0;Fake enum annotations</h2><!--SEC END --><p>The checker supports two ways to introduce a new fake enum (fenum):</p><ol class="enumerate" type=1><li class="li-enumerate">
Introduce your own specialized fenum annotation with code like this in
file <span style="font-family:monospace"><em>MyFenum</em></span><span style="font-family:monospace">.java</span>:<pre>
package <span style="font-style:italic">myModule</span>.qual;

import java.lang.annotation.*;
import org.checkerframework.checker.fenum.qual.FenumTop;
import org.checkerframework.framework.qual.SubtypeOf;

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE_USE, ElementType.TYPE_PARAMETER)
@SubtypeOf(FenumTop.class)
public @interface <span style="font-style:italic">MyFenum</span> <span style="font-family:monospace">{</span><span style="font-family:monospace">}</span>
</pre><p>You only need to adapt the italicized package, annotation, and file names in the example.</p><p>Note that all custom annotations must have the
<span style="font-family:monospace">@Target(</span><span style="font-family:monospace">ElementType.TYPE_USE</span><span style="font-family:monospace">)</span> meta-annotation. See section
<a href="#define-type-qualifiers">28.3.1</a>.</p></li><li class="li-enumerate">Use the provided <a href="api/org/checkerframework/checker/fenum/qual/Fenum.html"><span style="font-family:monospace">@Fenum</span></a> annotation, which takes a
<span style="font-family:monospace">String</span> argument to distinguish different fenums.
For example, <span style="font-family:monospace">@Fenum("A")</span> and <span style="font-family:monospace">@Fenum("B")</span> are two distinct fenums.
</li></ol><p>The first approach allows you to define a short, meaningful name suitable for
your project, whereas the second approach allows quick prototyping.</p>
<!--TOC section id="fenum-checks" What the Fenum Checker checks-->
<h2 id="fenum-checks" class="section">7.2&#XA0;&#XA0;What the Fenum Checker checks</h2><!--SEC END --><p>The Fenum Checker ensures that unrelated types are not mixed.
All types with a particular fenum annotation, or <span style="font-family:monospace">@Fenum(...)</span> with a particular <span style="font-family:monospace">String</span> argument, are
disjoint from all unannotated types and all types with a different fenum
annotation or <span style="font-family:monospace">String</span> argument.</p><p>The checker forbids method calls on fenum types and ensures that
only compatible fenum types are used in comparisons and arithmetic operations
(if applicable to the annotated type).</p><p>It is the programmer&#X2019;s responsibility to ensure that fields with a fenum type
are properly initialized before use. Otherwise, one might observe a <span style="font-family:monospace">null</span>
reference or zero value in the field of a fenum type. (The Nullness Checker
(Chapter&#XA0;<a href="#nullness-checker">3</a>) can prevent failure to initialize a
reference variable.)</p>
<!--TOC section id="fenum-running" Running the Fenum Checker-->
<h2 id="fenum-running" class="section">7.3&#XA0;&#XA0;Running the Fenum Checker</h2><!--SEC END --><p>The Fenum Checker can be invoked by running the following commands.</p><ul class="itemize"><li class="li-itemize">
If you define your own annotation(s), provide the name(s) of the annotation(s)
through the <span style="font-family:monospace">-Aquals</span> option, using a comma-no-space-separated notation:<pre>
  javac -Xbootclasspath/p:<span style="font-style:italic">/full/path/to/myProject/bin</span>:<span style="font-style:italic">/full/path/to/myLibrary/bin</span> <span style="font-family:monospace">\</span>
        -processor org.checkerframework.checker.fenum.FenumChecker <span style="font-family:monospace">\</span>
        -Aquals=<span style="font-style:italic">myModule.qual.MyFenum</span> MyFile.java ...
</pre><p>The annotations listed in <span style="font-family:monospace">-Aquals</span> must be accessible to
the compiler during compilation in the classpath. In other words, they must
already be compiled (and, typically, be on the javac bootclasspath)
before you run the Fenum Checker with <span style="font-family:monospace">javac</span>. It
is not sufficient to supply their source files on the command line.</p><p>You can also provide the fully-qualified paths to a set of directories
that contain the annotations through the <span style="font-family:monospace">-AqualDirs</span> option,
using a colon-no-space-separated notation. For example:</p><pre>
  javac -Xbootclasspath/p:<span style="font-style:italic">/full/path/to/myProject/bin</span>:<span style="font-style:italic">/full/path/to/myLibrary/bin</span> <span style="font-family:monospace">\</span>
        -processor org.checkerframework.checker.fenum.FenumChecker <span style="font-family:monospace">\</span>
        -AqualDirs=<span style="font-style:italic">/full/path/to/myProject/bin</span>:<span style="font-style:italic">/full/path/to/myLibrary/bin</span> MyFile.java ...
</pre><p>Note that in these two examples, the compiled class file of the
<span style="font-family:monospace">myModule.qual.MyFenum</span> annotation must exist in either the <span style="font-family:monospace">myProject/bin</span>
directory or the <span style="font-family:monospace">myLibrary/bin</span> directory. The following placement of
the class file will work with the above commands:</p><pre>
  .../myProject/bin/myModule/qual/MyFenum.class
</pre><p>The two options can be used at the same time to provide groups of annotations
from directories, and individually named annotations.</p></li><li class="li-itemize">If your code uses the <a href="api/org/checkerframework/checker/fenum/qual/Fenum.html"><span style="font-family:monospace">@Fenum</span></a> annotation, you do
not need the <span style="font-family:monospace">-Aquals</span> or <span style="font-family:monospace">-AqualDirs</span> option:<pre class="verbatim">  javac -processor org.checkerframework.checker.fenum.FenumChecker MyFile.java ...
</pre></li></ul>
<!--TOC section id="fenum-suppressing" Suppressing warnings-->
<h2 id="fenum-suppressing" class="section">7.4&#XA0;&#XA0;Suppressing warnings</h2><!--SEC END --><p>One example of when you need to suppress warnings is when you initialize the
fenum constants to literal values.
To remove this warning message, add a <span style="font-family:monospace">@SuppressWarnings</span> annotation to either
the field or class declaration, for example:</p><pre class="verbatim">@SuppressWarnings("fenum:assignment.type.incompatible") // initialization of fake enums
class MyConsts {
  public static final @Fenum("A") int ACONST1 = 1;
  public static final @Fenum("A") int ACONST2 = 2;
}
</pre>
<!--TOC section id="fenum-example" Example-->
<h2 id="fenum-example" class="section">7.5&#XA0;&#XA0;Example</h2><!--SEC END --><p>The following example introduces two fenums in class <span style="font-family:monospace">TestStatic</span>
and then performs a few typical operations.</p><pre class="verbatim">@SuppressWarnings("fenum:assignment.type.incompatible")   // initialization of fake enums
public class TestStatic {
  public static final @Fenum("A") int ACONST1 = 1;
  public static final @Fenum("A") int ACONST2 = 2;

  public static final @Fenum("B") int BCONST1 = 4;
  public static final @Fenum("B") int BCONST2 = 5;
}

class FenumUser {
  @Fenum("A") int state1 = TestStatic.ACONST1;     // ok
  @Fenum("B") int state2 = TestStatic.ACONST1;     // Incompatible fenums forbidden!

  void fenumArg(@Fenum("A") int p) {}

  void foo() {
    state1 = 4;                     // Direct use of value forbidden!
    state1 = TestStatic.BCONST1;    // Incompatible fenums forbidden!
    state1 = TestStatic.ACONST2;    // ok

    fenumArg(5);                    // Direct use of value forbidden!
    fenumArg(TestStatic.BCONST1);   // Incompatible fenums forbidden!
    fenumArg(TestStatic.ACONST1);   // ok
  }
 }
</pre><p>Also, see the example project in the <span style="font-family:monospace">checker/examples/fenum-extension</span> directory.</p>
<!--TOC section id="fenum-references" References-->
<h2 id="fenum-references" class="section">7.6&#XA0;&#XA0;References</h2><!--SEC END --><ul class="itemize"><li class="li-itemize">
Case studies of the Fake Enum Checker:<br>
 &#X201C;Building and using pluggable type-checkers&#X201D;&#XA0;[<a href="#DietlDEMS2011">DDE+11</a>]
(ICSE 2011, <a href="http://homes.cs.washington.edu/~mernst/pubs/pluggable-checkers-icse2011.pdf#page=3"><span style="font-family:monospace">http://homes.cs.washington.edu/~mernst/pubs/pluggable-checkers-icse2011.pdf#page=3</span></a>)</li><li class="li-itemize">Java Language Specification on enums:<br>
 <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9"><span style="font-family:monospace">https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9</span></a></li><li class="li-itemize">Tutorial trail on enums:<br>
 <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html"><span style="font-family:monospace">https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html</span></a></li><li class="li-itemize">Typesafe enum pattern:<br>
 <a href="http://www.oracle.com/technetwork/java/page1-139488.html"><span style="font-family:monospace">http://www.oracle.com/technetwork/java/page1-139488.html</span></a></li><li class="li-itemize">Java Tip 122: Beware of Java typesafe enumerations:<br>
 <a href="http://www.javaworld.com/article/2077487/core-java/java-tip-122--beware-of-java-typesafe-enumerations.html"><span style="font-family:monospace">http://www.javaworld.com/article/2077487/core-java/java-tip-122--beware-of-java-typesafe-enumerations.html</span></a></li></ul><hr>
<!--TOC chapter id="tainting-checker" Tainting Checker-->
<h1 id="tainting-checker" class="chapter">Chapter&#XA0;8&#XA0;&#XA0;Tainting Checker</h1><!--SEC END --><p>The Tainting Checker prevents certain kinds of trust errors.
A <em>tainted</em>, or untrusted, value is one that comes from an arbitrary,
possibly malicious source, such as user input or unvalidated data.
In certain parts of your application, using a tainted value can compromise
the application&#X2019;s integrity, causing it to crash, corrupt data, leak
private data, etc.</p><p>For example, a user-supplied pointer, handle, or map key should be
validated before being dereferenced.
As another example, a user-supplied string should not be concatenated into a
SQL query, lest the program be subject to a
<a href="https://en.wikipedia.org/wiki/Sql_injection">SQL injection</a> attack.
A location in your program where malicious data could do damage is
called a <em>sensitive sink</em>.</p><p>A program must &#X201C;sanitize&#X201D; or &#X201C;untaint&#X201D; an untrusted value before using
it at a sensitive sink. There are two general ways to untaint a value:
by checking
that it is innocuous/legal (e.g., it contains no characters that can be
interpreted as SQL commands when pasted into a string context), or by
transforming the value to be legal (e.g., quoting all the characters that
can be interpreted as SQL commands). A correct program must use one of
these two techniques so that tainted values never flow to a sensitive sink.
The Tainting Checker ensures that your program does so.</p><p>If the Tainting Checker issues no warning for a given program, then no
tainted value ever flows to a sensitive sink. However, your program is not
necessarily free from all trust errors. As a simple example, you might
have forgotten to annotate a sensitive sink as requiring an untainted type,
or you might have forgotten to annotate untrusted data as having a tainted
type.</p><p>To run the Tainting Checker, supply the
<span style="font-family:monospace">-processor TaintingChecker</span>
command-line option to javac.
</p>
<!--TOC section id="tainting-annotations" Tainting annotations-->
<h2 id="tainting-annotations" class="section">8.1&#XA0;&#XA0;Tainting annotations</h2><!--SEC END --><p>The Tainting type system uses the following annotations:
</p><ul class="itemize"><li class="li-itemize">
<a href="api/org/checkerframework/checker/tainting/qual/Untainted.html"><span style="font-family:monospace">@Untainted</span></a> indicates
a type that includes only untainted, trusted values.
</li><li class="li-itemize"><a href="api/org/checkerframework/checker/tainting/qual/Tainted.html"><span style="font-family:monospace">@Tainted</span></a> indicates
a type that may include only tainted, untrusted values.
<span style="font-family:monospace">@Tainted</span> is a supertype of <span style="font-family:monospace">@Untainted</span>.
</li><li class="li-itemize"><a href="api/org/checkerframework/checker/tainting/qual/PolyTainted.html"><span style="font-family:monospace">@PolyTainted</span></a> is a qualifier that is
polymorphic over tainting (see Section&#XA0;<a href="#qualifier-polymorphism">22.2</a>).
</li></ul>
<!--TOC section id="writing-untainted" Tips on writing <span style="font-family:monospace">@Untainted</span> annotations-->
<h2 id="writing-untainted" class="section">8.2&#XA0;&#XA0;Tips on writing <span style="font-family:monospace">@Untainted</span> annotations</h2><!--SEC END --><p>Most programs are designed with a boundary that surrounds sensitive
computations, separating them from untrusted values. Outside this
boundary, the program may manipulate malicious values, but no malicious
values ever pass the boundary to be operated upon by sensitive
computations.</p><p>In some programs, the area outside the boundary is very small: values are
sanitized as soon as they are received from an external source. In other
programs, the area inside the boundary is very small: values are sanitized
only immediately before being used at a sensitive sink. Either approach
can work, so long as every possibly-tainted value is sanitized before it
reaches a sensitive sink.</p><p>Once you determine the boundary, annotating your program is easy: put
<span style="font-family:monospace">@Tainted</span> outside the boundary, <span style="font-family:monospace">@Untainted</span> inside, and
<span style="font-family:monospace">@SuppressWarnings("tainting")</span> at the validation or
sanitization routines that are used at the boundary.
</p><p>The Tainting Checker&#X2019;s standard default qualifier is <span style="font-family:monospace">@Tainted</span> (see
Section&#XA0;<a href="#defaults">23.3.1</a> for overriding this default). This is the safest
default, and the one that should be used for all code outside the boundary
(for example, code that reads user input). You can set the default
qualifier to <span style="font-family:monospace">@Untainted</span> in code that may contain sensitive sinks.</p><p>The Tainting Checker does not know the intended semantics of your program,
so it cannot warn you if you mis-annotate a sensitive sink as taking
<span style="font-family:monospace">@Tainted</span> data, or if you mis-annotate external data as
<span style="font-family:monospace">@Untainted</span>. So long as you correctly annotate the sensitive sinks
and the places that untrusted data is read, the Tainting Checker will
ensure that all your other annotations are correct and that no undesired
information flows exist.</p><p>As an example, suppose that you wish to prevent SQL injection attacks. You
would start by annotating the
<a href="http://docs.oracle.com/javase/8/docs/api/java/sql/Statement.html"><span style="font-family:monospace">Statement</span></a> class to indicate that the
<span style="font-family:monospace">execute</span> operations may only operate on untainted queries
(Chapter&#XA0;<a href="#annotating-libraries">27</a> describes how to annotate external
libraries):</p><pre class="verbatim">  public boolean execute(@Untainted String sql) throws SQLException;
  public boolean executeUpdate(@Untainted String sql) throws SQLException;
</pre>
<!--TOC section id="tainting-many-uses" <span style="font-family:monospace">@Tainted</span> and <span style="font-family:monospace">@Untainted</span> can be used for many purposes-->
<h2 id="tainting-many-uses" class="section">8.3&#XA0;&#XA0;<span style="font-family:monospace">@Tainted</span> and <span style="font-family:monospace">@Untainted</span> can be used for many purposes</h2><!--SEC END --><p>The <span style="font-family:monospace">@Tainted</span> and <span style="font-family:monospace">@Untainted</span> annotations have only minimal
built-in semantics. In fact, the Tainting Checker provides only a small
amount of functionality beyond the Subtyping Checker
(Chapter&#XA0;<a href="#subtyping-checker">20</a>). This lack of hard-coded behavior means that
the annotations can serve many different purposes. Here are just a few
examples:</p><ul class="itemize"><li class="li-itemize">
Prevent SQL injection attacks: <span style="font-family:monospace">@Tainted</span> is external input,
<span style="font-family:monospace">@Untainted</span> has been checked for SQL syntax.
</li><li class="li-itemize">Prevent cross-site scripting attacks: <span style="font-family:monospace">@Tainted</span> is external input,
<span style="font-family:monospace">@Untainted</span> has been checked for JavaScript syntax.
</li><li class="li-itemize">Prevent information leakage: <span style="font-family:monospace">@Tainted</span> is secret data,
<span style="font-family:monospace">@Untainted</span> may be displayed to a user.
</li></ul><p>In each case, you need to annotate the appropriate untainting/sanitization
routines. This is similar to the <span style="font-family:monospace">@Encrypted</span> annotation
(Section&#XA0;<a href="#encrypted-example">20.2</a>), where the cryptographic functions are
beyond the reasoning abilities of the type system. In each case, the type
system verifies most of your code, and the <span style="font-family:monospace">@SuppressWarnings</span>
annotations indicate the few places where human attention is needed.</p><p>If you want more specialized semantics, or you want to annotate multiple
types of tainting in a single program, then you can copy the definition of
the Tainting Checker to create a new annotation and checker with a more
specific name and semantics. See Chapter&#XA0;<a href="#writing-a-checker">28</a> for more
details.</p>
<!--TOC subsection id="tainting-qual-params" Qualifier Parameters-->
<h3 id="tainting-qual-params" class="subsection">8.3.1&#XA0;&#XA0;Qualifier Parameters</h3><!--SEC END --><p>
The Tainting Checker supports qualifier parameters.
See Section&#XA0;<a href="#qualifier-parameters">22.3</a> for more details on qualifier parameters.</p><p>
The qualifier parameter system currently
incurs a 50% performance penalty. If this is unacceptable you can run the
original Tainting Checker by passing the
<span style="font-family:monospace">-processor org.checkerframework.checker.tainting.classic.TaintingClassicChecker</span>
command-line option to javac.
</p><hr>
<!--TOC chapter id="regex-checker" Regex Checker for regular expression syntax-->
<h1 id="regex-checker" class="chapter">Chapter&#XA0;9&#XA0;&#XA0;Regex Checker for regular expression syntax</h1><!--SEC END --><p>The Regex Checker prevents, at compile-time, use of syntactically invalid
regular expressions and access of invalid capturing groups.</p><p>A regular expression, or regex, is a pattern for matching certain strings
of text. In Java, a programmer writes a regular expression as a string.
At run time, the string is &#X201C;compiled&#X201D; into an efficient internal form
(<a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html"><span style="font-family:monospace">Pattern</span></a>) that is used for
text-matching. Regular expression in Java also have capturing groups, which
are delimited by parentheses and allow for extraction from text.</p><p>The syntax of regular expressions is complex, so it is easy to make a
mistake. It is also easy to accidentally use a regex feature from another
language that is not supported by Java (see section &#X201C;Comparison to Perl
5&#X201D; in the <a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html"><span style="font-family:monospace">Pattern</span></a> Javadoc).
Ordinarily, the programmer does not learn of these errors until run time.
The Regex Checker warns about these problems at compile time.</p><p>For further details, including case studies, see a paper about the Regex
Checker&#XA0;[<a href="#SpishakDE2012">SDE12</a>].</p><p>To run the Regex Checker, supply the
<span style="font-family:monospace">-processor org.checkerframework.checker.regex.RegexChecker</span>
command-line option to javac.</p>
<!--TOC section id="regex-annotations" Regex annotations-->
<h2 id="regex-annotations" class="section">9.1&#XA0;&#XA0;Regex annotations</h2><!--SEC END --><p>These qualifiers make up the Regex type system:</p><dl class="description"><dt class="dt-description"><a href="api/org/checkerframework/checker/regex/qual/Regex.html"><span style="font-weight:bold"><span style="font-family:monospace">@Regex</span></span></a></dt><dd class="dd-description">
indicates that the run-time value is a valid regular expression
<span style="font-family:monospace">String</span>. If the optional parameter is supplied to the qualifier,
then the number of capturing groups in the regular expression is at least
that many. If not provided, the parameter defaults to 0.
For example, if an expression&#X2019;s type is <span style="font-family:monospace">@Regex(1) String</span>, then its
run-time value could be <span style="font-family:monospace">"colo(u?)r"</span> or <span style="font-family:monospace">"(brown|beige)"</span> but not
<span style="font-family:monospace">"colou?r"</span> nor a non-regex string such as <span style="font-family:monospace">"1) first point"</span>.</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/regex/qual/PolyRegex.html"><span style="font-weight:bold"><span style="font-family:monospace">@PolyRegex</span></span></a></dt><dd class="dd-description">
indicates qualifier polymorphism (see Section&#XA0;<a href="#qualifier-polymorphism">22.2</a>).</dd></dl><p>The subtyping hierarchy of the Regex Checker&#X2019;s qualifiers is shown in
Figure&#XA0;<a href="#fig-regex-hierarchy">9.1</a>.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<img src="regex.svg">
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 9.1: The subtyping relationship of the Regex Checker&#X2019;s qualifiers.
Because the parameter to a <span style="font-family:monospace">@Regex</span> qualifier is at least the number of
capturing groups in a regular expression, a <span style="font-family:monospace">@Regex</span> qualifier with more
capturing groups is a subtype of a <span style="font-family:monospace">@Regex</span> qualifier with fewer capturing
groups. Qualifiers in gray are used internally by the type
system but should never be written by a programmer.</td></tr>
</table></div>
<a id="fig-regex-hierarchy"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote>
<!--TOC section id="annotating-with-regex" Annotating your code with <span style="font-family:monospace">@Regex</span>-->
<h2 id="annotating-with-regex" class="section">9.2&#XA0;&#XA0;Annotating your code with <span style="font-family:monospace">@Regex</span></h2><!--SEC END -->
<!--TOC subsection id="regex-implicit-qualifiers" Implicit qualifiers-->
<h3 id="regex-implicit-qualifiers" class="subsection">9.2.1&#XA0;&#XA0;Implicit qualifiers</h3><!--SEC END --><p>As described in Section&#XA0;<a href="#effective-qualifier">23.3</a>, the Regex Checker adds
implicit qualifiers, reducing the number of annotations that must appear
in your code. The checker implicitly adds the <span style="font-family:monospace">Regex</span> qualifier with
the parameter set to the correct number of capturing groups to
any <span style="font-family:monospace">String</span> literal that is a valid regex. The Regex Checker allows
the <span style="font-family:monospace">null</span> literal to be assigned to any type qualified with the
<span style="font-family:monospace">Regex</span> qualifier.</p>
<!--TOC subsection id="regex-capturing-groups" Capturing groups-->
<h3 id="regex-capturing-groups" class="subsection">9.2.2&#XA0;&#XA0;Capturing groups</h3><!--SEC END --><p>The Regex Checker validates that a legal capturing group number is passed
to <a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html"><span style="font-family:monospace">Matcher</span></a>&#X2019;s
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#group-int-"><span style="font-family:monospace">group</span></a>,
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#start-int-"><span style="font-family:monospace">start</span></a> and
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#end-int-"><span style="font-family:monospace">end</span></a> methods. To do this,
the type of <span style="font-family:monospace">Matcher</span> must be qualified with a <span style="font-family:monospace">@Regex</span> annotation
with the number of capturing groups in the regular expression. This is
handled implicitly by the Regex Checker for local variables (see
Section&#XA0;<a href="#type-refinement">23.4</a>), but you may need to add <span style="font-family:monospace">@Regex</span> annotations
with a capturing group count to <span style="font-family:monospace">Pattern</span> and <span style="font-family:monospace">Matcher</span> fields and
parameters.</p>
<!--TOC subsection id="regex-partial-regex" Concatenation of partial regular expressions-->
<h3 id="regex-partial-regex" class="subsection">9.2.3&#XA0;&#XA0;Concatenation of partial regular expressions</h3><!--SEC END --><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<pre class="verbatim">public @Regex String parenthesize(@Regex String regex) {
    return "(" + regex + ")"; // Even though the parentheses are not @Regex Strings,
                              // the whole expression is a @Regex String
}
</pre><div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 9.2: An example of the Regex Checker&#X2019;s support for concatenation
of non-regular-expression Strings to produce valid regular expression Strings.</td></tr>
</table></div>
<a id="fig-regex-partial"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p>In general, concatenating a non-regular-expression String with any other
string yields a non-regular-expression String. The Regex Checker can
sometimes determine that concatenation of non-regular-expression Strings
will produce valid regular expression Strings. For an example see
Figure&#XA0;<a href="#fig-regex-partial">9.2</a>.</p>
<!--TOC subsection id="regexutil-methods" Testing whether a string is a regular expression-->
<h3 id="regexutil-methods" class="subsection">9.2.4&#XA0;&#XA0;Testing whether a string is a regular expression</h3><!--SEC END --><p>Sometimes, the Regex Checker cannot infer whether a particular expression
is a regular expression &#X2014; and sometimes your code cannot either! In
these cases, you can use the <span style="font-family:monospace">isRegex</span> method to perform such a test, and
other helper methods to provide useful error messages. A
common use is for user-provided regular expressions (such as ones passed
on the command-line).
Figure&#XA0;<a href="#fig-regex-util-example">9.3</a> gives an
example of the intended use of the <span style="font-family:monospace">RegexUtil</span> methods.</p><dl class="description"><dt class="dt-description"><a href="api/org/checkerframework/checker/regex/RegexUtil.html#isRegex-java.lang.String-"><span style="font-weight:bold"><span style="font-family:monospace">RegexUtil.isRegex</span></span></a></dt><dd class="dd-description">
returns <span style="font-family:monospace">true</span> if its argument is a valid regular expression.</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/regex/RegexUtil.html#regexError-java.lang.String-"><span style="font-weight:bold"><span style="font-family:monospace">RegexUtil.regexError</span></span></a></dt><dd class="dd-description">
returns a <span style="font-family:monospace">String</span> error message if its argument is not a valid regular
expression, or <span style="font-family:monospace">null</span> if its argument is a valid regular expression.</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/regex/RegexUtil.html#regexException-java.lang.String-"><span style="font-weight:bold"><span style="font-family:monospace">RegexUtil.regexException</span></span></a></dt><dd class="dd-description">
returns the
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/PatternSyntaxException.html"><span style="font-family:monospace">PatternSyntaxException</span></a>
that <a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#compile-java.lang.String-"><span style="font-family:monospace">Pattern.compile(String)</span></a>
throws when compiling an invalid regular expression. It returns <span style="font-family:monospace">null</span>
if its argument is a valid regular expression.</dd></dl><p>An additional version of each of these methods is also provided that takes
an additional group count parameter. The
<a href="api/org/checkerframework/checker/regex/RegexUtil.html#isRegex-java.lang.String-int-"><span style="font-family:monospace">RegexUtil.isRegex</span></a> method
verifies that the argument has at least the given number of groups. The
<a href="api/org/checkerframework/checker/regex/RegexUtil.html#regexError-java.lang.String-int-"><span style="font-family:monospace">RegexUtil.regexError</span></a> and
<a href="api/org/checkerframework/checker/regex/RegexUtil.html#regexException-java.lang.String-int-"><span style="font-family:monospace">RegexUtil.regexException</span></a>
methods return a <span style="font-family:monospace">String</span> error message and <span style="font-family:monospace">PatternSyntaxException</span>,
respectively, detailing why the given String is not a syntactically valid
regular expression with at least the given number of capturing groups.</p><p>
If you detect that a <span style="font-family:monospace">String</span> is not a valid regular expression but would like
to report the error higher up the call stack (potentially where you can
provide a more detailed error message) you can throw a
<a href="api/org/checkerframework/checker/regex/RegexUtil.CheckedPatternSyntaxException.html"><span style="font-family:monospace">RegexUtil.CheckedPatternSyntaxException</span></a>. This exception is
functionally the same as a
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/PatternSyntaxException.html"><span style="font-family:monospace">PatternSyntaxException</span></a>
except it is checked to guarantee that the error will be handled up the
call stack. For more details, see the Javadoc for
<a href="api/org/checkerframework/checker/regex/RegexUtil.CheckedPatternSyntaxException.html"><span style="font-family:monospace">RegexUtil.CheckedPatternSyntaxException</span></a>.
</p><p>A potential disadvantage of using the <span style="font-family:monospace">RegexUtil</span> class is that your code becomes
dependent on the Checker Framework at run time as well as at compile time.
You can avoid this by adding the Checker Framework to your project, or by
copying the <span style="font-family:monospace">RegexUtil</span> class into
your own code.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<pre class="verbatim">String regex = getRegexFromUser();
if (! RegexUtil.isRegex(regex)) {
   throw new RuntimeException("Error parsing regex " + regex, RegexUtil.regexException(regex));
}
Pattern p = Pattern.compile(regex);
</pre><div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 9.3: Example use of <span style="font-family:monospace">RegexUtil</span> methods.</td></tr>
</table></div>
<a id="fig-regex-util-example"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote>
<!--TOC subsection id="regex-qual-params" Qualifier Parameters-->
<h3 id="regex-qual-params" class="subsection">9.2.5&#XA0;&#XA0;Qualifier Parameters</h3><!--SEC END --><p>
The Regex Checker supports qualifier parameters.
See Section&#XA0;<a href="#qualifier-parameters">22.3</a> for more details on qualifier parameters.</p><p>
The qualifier parameter system currently
incurs a 50%
performance penalty. If this is unacceptable you can run the original Regex
Checker by passing the
<span style="font-family:monospace">-processor org.checkerframework.checker.regex.classic.RegexClassicChecker</span>
command-line option to javac.
</p>
<!--TOC subsection id="regex-suppressing-warnings" Suppressing warnings-->
<h3 id="regex-suppressing-warnings" class="subsection">9.2.6&#XA0;&#XA0;Suppressing warnings</h3><!--SEC END --><p>If you are positive that a particular string that is being used as a
regular expression is syntactically valid, but the Regex Checker cannot
conclude this and issues a warning about possible use of an invalid regular
expression, then you can use the
<a href="api/org/checkerframework/checker/regex/RegexUtil.html#asRegex-java.lang.String-"><span style="font-family:monospace">RegexUtil.asRegex</span></a> method to suppress the
warning.</p><p>You can think of this method
as a cast: it returns its argument unchanged, but with the type
<span style="font-family:monospace">@Regex String</span> if it is a valid regular expression. It throws an
error if its argument is not a valid regular expression, but you should
only use it when you are sure it will not throw an error.</p><p>There is an additional <a href="api/org/checkerframework/checker/regex/RegexUtil.html#asRegex-java.lang.String-int-"><span style="font-family:monospace">RegexUtil.asRegex</span></a>
method that takes a capturing group parameter. This method works the same as
described above, but returns a <span style="font-family:monospace">@Regex String</span> with the parameter on the
annotation set to the value of the capturing group parameter passed to the method.</p><p>The use case shown in Figure&#XA0;<a href="#fig-regex-util-example">9.3</a> should support most cases
so the <span style="font-family:monospace">asRegex</span> method should be used rarely.</p><hr>
<!--TOC chapter id="formatter-checker" Format String Checker-->
<h1 id="formatter-checker" class="chapter">Chapter&#XA0;10&#XA0;&#XA0;Format String Checker</h1><!--SEC END --><p>
The Format String Checker
prevents use of incorrect format strings
in format methods such as
<a href="http://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html#printf-java.lang.String-java.lang.Object...-"><span style="font-family:monospace">System.out.printf</span></a>
and <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-"><span style="font-family:monospace">String.format</span></a>.
</p><p>The Format String Checker warns you if you write an invalid format string,
and it warns you if the other arguments are not consistent with the format
string (in number of arguments or in their types).
Here are examples of errors that the
Format String Checker
detects at compile time.
Section&#XA0;<a href="#formatter-guarantees">10.3</a> provides more details.</p><pre class="verbatim">  String.format("%y", 7);           // error: invalid format string

  String.format("%d", "a string");  // error: invalid argument type for %d

  String.format("%d %s", 7);        // error: missing argument for %s
  String.format("%d", 7, 3);        // warning: unused argument 3
  String.format("{0}", 7);          // warning: unused argument 7, because {0} is wrong syntax
</pre><p>
To run the Format String Checker, supply the
<span style="font-family:monospace">-processor org.checkerframework.checker.formatter.FormatterChecker</span> command-line option to javac.
</p>
<!--TOC section id="formatter-terminology" Formatting terminology-->
<h2 id="formatter-terminology" class="section">10.1&#XA0;&#XA0;Formatting terminology</h2><!--SEC END --><p>Printf-style formatting takes as an argument a <em>format string</em> and a
list of arguments. It produces a new string in which each <em>format
specifier</em> has been replaced by the corresponding argument.
The format specifier determines how the format argument is converted to a
string.
A format specifier is introduced by a <span style="font-family:monospace">%</span> character. For example,
<span style="font-family:monospace">String.format("The %s is %d.","answer",42)</span> yields
<span style="font-family:monospace">"The answer is 42."</span>. <span style="font-family:monospace">"The %s is %d."</span> is
the format string, <span style="font-family:monospace">"%s"</span> and <span style="font-family:monospace">"%d"</span> are the format specifiers;
<span style="font-family:monospace">"answer"</span> and <span style="font-family:monospace">42</span> are format arguments.</p>
<!--TOC section id="formatter-annotations" Format String Checker annotations-->
<h2 id="formatter-annotations" class="section">10.2&#XA0;&#XA0;Format String Checker annotations</h2><!--SEC END --><p>The <a href="api/org/checkerframework/checker/formatter/qual/Format.html"><span style="font-family:monospace">@Format</span></a> qualifier on a string type
indicates a <em>valid</em> format string. The JDK documentation for the
<span style="font-family:monospace">Formatter</span> class explains the requirements for a
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax">valid format string</a>.
A programmer rarely writes the <span style="font-family:monospace">@Format</span> annotation, as it is inferred for
string literals. A programmer may need to write it on fields and on method
signatures.</p><p>The <a href="api/org/checkerframework/checker/formatter/qual/Format.html"><span style="font-family:monospace">@Format</span></a> qualifier is parameterized with
a list of conversion categories that impose restrictions on the format arguments.
Conversion categories are explained in more detail in
Section&#XA0;<a href="#formatter-categories">10.2.1</a>. The type qualifier for <span style="font-family:monospace">"%d %f"</span> is
for example <span style="font-family:monospace">@Format({INT, FLOAT})</span>.</p><p>Consider the below <span style="font-family:monospace">printFloatAndInt</span> method. Its parameter must be a
format string that can be used in a format method, where the first format
argument is &#X201C;float-like&#X201D; and the second format argument is
&#X201C;integer-like&#X201D;. The type of its parameter, <span style="font-family:monospace">@Format({FLOAT, INT})
String</span>, expresses that contract.</p><pre class="verbatim">    void printFloatAndInt(@Format({FLOAT, INT}) String fs) {
        System.out.printf(fs, 3.1415, 42);
    }

    printFloatAndInt("Float %f, Number %d");  // OK
    printFloatAndInt("Float %f");             // error
</pre><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<img src="formatter-hierarchy.svg">
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 10.1: The
Format String Checker type qualifier hierarchy.
The figure does not show the subtyping rules among different
<span style="font-family:monospace">@Format(...)</span>
qualifiers; see
Section&#XA0;<a href="#formatter-format-subtyping">10.2.1</a>.
</td></tr>
</table></div>
<a id="fig-formatter-hierarchy"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p>Figure&#XA0;<a href="#fig-formatter-hierarchy">10.1</a> shows all the type qualifiers.
The annotations other than <span style="font-family:monospace">@Format</span> are only used
internally and cannot be written in your code.
<a href="api/org/checkerframework/checker/formatter/qual/InvalidFormat.html"><span style="font-family:monospace">@InvalidFormat</span></a> indicates an invalid format
string &#X2014; that is, a string that cannot be used as a format string. For
example, the type of <span style="font-family:monospace">"%y"</span> is <span style="font-family:monospace">@InvalidFormat String</span>.
<a href="api/org/checkerframework/checker/formatter/qual/FormatBottom.html"><span style="font-family:monospace">@FormatBottom</span></a> is the type of the
<span style="font-family:monospace">null</span> literal.
<a href="api/org/checkerframework/framework/qual/Unqualified.html"><span style="font-family:monospace">@Unqualified</span></a> is the default that is
applied to strings that are not literals and on which the user has not
written a <span style="font-family:monospace">@Format</span> annotation.</p>
<!--TOC subsection id="formatter-categories" Conversion Categories-->
<h3 id="formatter-categories" class="subsection">10.2.1&#XA0;&#XA0;Conversion Categories</h3><!--SEC END --><p>Given a format specifier, only certain format arguments are compatible with
it, depending on its &#X201C;conversion&#X201D; &#X2014; its last, or last two,
characters. For example, in the format specifier <span style="font-family:monospace">"%d"</span>, the
conversion <span style="font-family:monospace">d</span> restricts the corresponding format argument
to be &#X201C;integer-like&#X201D;:</p><pre class="verbatim">    String.format("%d", 5);         // OK
    String.format("%d", "hello");   // error
</pre><p>Many conversions enforce the same restrictions. A set of
restrictions is represented as a <em>conversion
category</em>. The &#X201C;integer like&#X201D; restriction is for example the conversion
category <a href="api/org/checkerframework/checker/formatter/qual/ConversionCategory.html#INT"><span style="font-family:monospace">INT</span></a>. The following conversion categories are defined in the
<a href="api/org/checkerframework/checker/formatter/qual/ConversionCategory.html"><span style="font-family:monospace">ConversionCategory</span></a> enumeration:</p><dl class="description"><dt class="dt-description">
</dt><dd class="dd-description"><a href="api/org/checkerframework/checker/formatter/qual/ConversionCategory.html#GENERAL"><span style="font-family:monospace">GENERAL</span></a> imposes no restrictions on a format argument&#X2019;s type. Applicable for
conversions b, B, h, H, s, S.</dd><dt class="dt-description"></dt><dd class="dd-description"><a href="api/org/checkerframework/checker/formatter/qual/ConversionCategory.html#CHAR"><span style="font-family:monospace">CHAR</span></a> requires that a format argument represents a Unicode character.
Specifically, <span style="font-family:monospace">char</span>, <span style="font-family:monospace">Character</span>, <span style="font-family:monospace">byte</span>,
<span style="font-family:monospace">Byte</span>, <span style="font-family:monospace">short</span>, and <span style="font-family:monospace">Short</span> are allowed.
<span style="font-family:monospace">int</span> or <span style="font-family:monospace">Integer</span> are allowed if
<span style="font-family:monospace">Character.isValidCodePoint(argument)</span> would return <span style="font-family:monospace">true</span>
for the format argument. (The Format String Checker permits any <span style="font-family:monospace">int</span>
or <span style="font-family:monospace">Integer</span> without issuing a warning or error &#X2014; see
Section&#XA0;<a href="#formatter-missed-alarms">10.3.2</a>.)
Applicable for conversions c, C.</dd><dt class="dt-description"></dt><dd class="dd-description"><a href="api/org/checkerframework/checker/formatter/qual/ConversionCategory.html#INT"><span style="font-family:monospace">INT</span></a> requires that a format argument represents an integral type. Specifically,
<span style="font-family:monospace">byte</span>, <span style="font-family:monospace">Byte</span>, <span style="font-family:monospace">short</span>, <span style="font-family:monospace">Short</span>,
<span style="font-family:monospace">int</span> and <span style="font-family:monospace">Integer</span>, <span style="font-family:monospace">long</span>,
<span style="font-family:monospace">Long</span>, and <span style="font-family:monospace">BigInteger</span> are allowed. Applicable for
conversions d, o, x, X.</dd><dt class="dt-description"></dt><dd class="dd-description"><a href="api/org/checkerframework/checker/formatter/qual/ConversionCategory.html#FLOAT"><span style="font-family:monospace">FLOAT</span></a> requires that a format argument represents a floating-point type. Specifically,
<span style="font-family:monospace">float</span>, <span style="font-family:monospace">Float</span>, <span style="font-family:monospace">double</span>,
<span style="font-family:monospace">Double</span>, and <span style="font-family:monospace">BigDecimal</span> are allowed. Surprisingly, integer
values are not allowed. Applicable for
conversions e, E, f, g, G, a, A.</dd><dt class="dt-description"></dt><dd class="dd-description"><a href="api/org/checkerframework/checker/formatter/qual/ConversionCategory.html#TIME"><span style="font-family:monospace">TIME</span></a> requires that a format argument represents a date or time.
Specifically, <span style="font-family:monospace">long</span>, <span style="font-family:monospace">Long</span>, <span style="font-family:monospace">Calendar</span>, and
<span style="font-family:monospace">Date</span> are allowed. Applicable for conversions t, T.</dd><dt class="dt-description"></dt><dd class="dd-description"><a href="api/org/checkerframework/checker/formatter/qual/ConversionCategory.html#UNUSED"><span style="font-family:monospace">UNUSED</span></a> imposes no restrictions on a format argument. This is the case if a
format argument is not used as replacement for any format specifier.
<span style="font-family:monospace">"%2$s"</span> for example ignores the first format argument.
</dd></dl><p>Further, all conversion categories accept <span style="font-family:monospace">null</span>.
</p><p>The same format argument may serve as a replacement for multiple format specifiers.
Until now, we have assumed that the format specifiers simply consume format arguments left to right.
But there are two other ways for a format specifier to select a format argument:</p><ul class="itemize"><li class="li-itemize">
<span style="font-style:italic">n</span><span style="font-family:monospace">$</span> specifies a one-based index <span style="font-style:italic">n</span>. In the
format string <span style="font-family:monospace">"%2$s"</span>, the format specifier selects the
second format argument.
</li><li class="li-itemize">The <span style="font-family:monospace">&lt;</span> <em>flag</em> references the format argument
that was used by the previous format specifier. In the format string
<span style="font-family:monospace">"%d %&lt;d"</span> for example, both format specifiers select the first
format argument.
</li></ul><p>In the following example,
the format argument must be compatible with both conversion
categories, and can therefore be neither a <span style="font-family:monospace">Character</span> nor a <span style="font-family:monospace">long</span>.</p><pre class="verbatim">    format("Char %1$c, Int %1$d", (int)42);            // OK
    format("Char %1$c, Int %1$d", new Character(42));  // error
    format("Char %1$c, Int %1$d", (long)42);           // error
</pre><p>Only three additional conversion categories are needed represent all possible
intersections of previously-mentioned conversion categories:</p><dl class="description"><dt class="dt-description">
</dt><dd class="dd-description"><a href="api/org/checkerframework/checker/formatter/qual/ConversionCategory.html#NULL"><span style="font-family:monospace">NULL</span></a> is used if no object of any type can be
passed as parameter. In this case, the only legal value is <span style="font-family:monospace">null</span>.
The format string <span style="font-family:monospace">"%1$f %1$c"</span>, for example requires that the first
format argument be <span style="font-family:monospace">null</span>. Passing a value such as <span style="font-family:monospace">4</span> or
<span style="font-family:monospace">4.2</span> would lead to an exception.
</dd><dt class="dt-description"></dt><dd class="dd-description"><a href="api/org/checkerframework/checker/formatter/qual/ConversionCategory.html#CHAR_AND_INT"><span style="font-family:monospace">CHAR_AND_INT</span></a> is used if a format argument is restricted by a <a href="api/org/checkerframework/checker/formatter/qual/ConversionCategory.html#CHAR"><span style="font-family:monospace">CHAR</span></a> and a <a href="api/org/checkerframework/checker/formatter/qual/ConversionCategory.html#INT"><span style="font-family:monospace">INT</span></a> conversion category (<span style="font-family:monospace">CHAR</span> &#X2229; <span style="font-family:monospace">INT</span>).
</dd><dt class="dt-description"></dt><dd class="dd-description"><a href="api/org/checkerframework/checker/formatter/qual/ConversionCategory.html#INT_AND_TIME"><span style="font-family:monospace">INT_AND_TIME</span></a> is used if a format argument is restricted by an <a href="api/org/checkerframework/checker/formatter/qual/ConversionCategory.html#INT"><span style="font-family:monospace">INT</span></a> and a <a href="api/org/checkerframework/checker/formatter/qual/ConversionCategory.html#TIME"><span style="font-family:monospace">TIME</span></a> conversion category (<span style="font-family:monospace">INT</span> &#X2229; <span style="font-family:monospace">TIME</span>).
</dd></dl><p>All other intersections lead to already existing conversion categories.
For example, <span style="font-family:monospace">GENERAL</span> &#X2229; <span style="font-family:monospace">CHAR</span> = <span style="font-family:monospace">CHAR</span> and
<span style="font-family:monospace">UNUSED</span> &#X2229; <span style="font-family:monospace">GENERAL</span> = <span style="font-family:monospace">GENERAL</span>.</p><p>Figure&#XA0;<a href="#fig-formatter-cat">10.2</a> summarizes the subset
relationship among all conversion categories.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<img src="formatter-categories.svg">
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 10.2: The subset relationship
among conversion categories.</td></tr>
</table></div>
<a id="fig-formatter-cat"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p><a id="formatter-format-subtyping"></a>
Here are the subtyping rules among different
<a href="api/org/checkerframework/checker/formatter/qual/Format.html"><span style="font-family:monospace">@Format</span></a>
qualifiers.
It is legal to:</p><ul class="itemize"><li class="li-itemize">
use a format string with a weaker (less restrictive) conversion category than required.
</li><li class="li-itemize">use a format string with fewer format specifiers than required, but a warning is issued.
</li></ul><p>The following example shows the subtyping rules in action:</p><pre class="verbatim">    @Format({FLOAT, INT})
    String f;

    f = "%f %d";       // Ok
    f = "%s %d";       // OK, %s is weaker than %f
    f = "%f";          // warning: last argument is ignored
    f = "%f %d %s";    // error: too many arguments
    f = "%d %d";       // error: %d is not weaker than %f

    String.format(f, 0.8, 42);
</pre>
<!--TOC section id="formatter-guarantees" What the Format String Checker checks-->
<h2 id="formatter-guarantees" class="section">10.3&#XA0;&#XA0;What the Format String Checker checks</h2><!--SEC END --><p>If the Format String Checker issues no errors, it provides the following guarantees:</p><ol class="enumerate" type=1><li class="li-enumerate">
The following guarantees hold for every format method invocation:<ol class="enumerate" type=a><li class="li-enumerate">
The format method&#X2019;s first parameter (or second if a <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Locale.html"><span style="font-family:monospace">Locale</span></a> is provided) is a valid
format string (or <span style="font-family:monospace">null</span>).</li><li class="li-enumerate">A warning is issued if one of the format string&#X2019;s conversion categories is <span style="font-family:monospace">UNUSED</span>.
<a id="formatter-unused-category-warning"></a>
</li><li class="li-enumerate">None of the format string&#X2019;s conversion categories is <span style="font-family:monospace">NULL</span>.
<a id="formatter-null-category-error"></a>
</li></ol></li><li class="li-enumerate">If the format arguments are passed to the format method as varargs, the
Format String Checker guarantees the following additional properties:<ol class="enumerate" type=a><li class="li-enumerate">
No fewer format arguments are passed than required by the format string.
</li><li class="li-enumerate">A warning is issued if more format arguments are passed than required by the format string.
</li><li class="li-enumerate">Every format argument&#X2019;s type satisfies its conversion category&#X2019;s restrictions.
</li></ol></li><li class="li-enumerate">If the format arguments are passed to the format method as an array,
a warning is issued by the Format String Checker.
<a id="formatter-array-warning"></a>
</li></ol><p>Following are examples for every guarantee:</p><pre class="verbatim">    String.format("%d", 42);                      // OK
    String.format(Locale.GERMAN, "%d", 42);       // OK
    String.format(new Object());                  // error (1a)
    String.format("%y");                          // error (1a)
    String.format("%2$s", "unused", "used");      // warning (1b)
    String.format("%1$d %1$f", 5.5);              // error (1c)
    String.format("%1$d %1$f %d", null, 6);       // error (1c)
    String.format("%s");                          // error (2a)
    String.format("%s", "used", "ignored");       // warning (2b)
    String.format("%c",4.2);                      // error (2c)
    String.format("%c", (String)null);            // error (2c)
    String.format("%1$d %1$f", new Object[]{1});  // warning (3)
    String.format("%s", new Object[]{"hello"});   // warning (3)
</pre>
<!--TOC subsection id="formatter-false-alarms" Possible false alarms-->
<h3 id="formatter-false-alarms" class="subsection">10.3.1&#XA0;&#XA0;Possible false alarms</h3><!--SEC END --><p>There are three cases in which the Format String Checker may issue a
warning or error, even though the code cannot fail at run time.
(These are in addition to the general conservatism of a type system: code
may be correct because of application invariants that are not captured by
the type system.)
In each of these cases, you can rewrite the code, or you can manually check
it and write a <span style="font-family:monospace">@SuppressWarnings</span> annotation if you can reason that
the code is correct.</p><p>Case <a href="#formatter-unused-category-warning">1(b)</a>:
Unused format arguments. It is legal to provide more arguments than are
required by the format string; Java ignores the extras. However, this is
an uncommon case. In practice, a mismatch between the number of format
specifiers and the number of format arguments is usually an error.</p><p>Case <a href="#formatter-null-category-error">1(c)</a>:
Format arguments that can only be <span style="font-family:monospace">null</span>.
It is legal to write a format string that permits only null arguments and
throws an exception for any other argument. An example is
<span style="font-family:monospace">String.format("%1$d %1$f", null)</span>.
The Format String Checker forbids such a format string.
If you should ever need such a format string, simply replace the problematic
format specifier with <span style="font-family:monospace">"null"</span>. For example, you would replace the
call above by <span style="font-family:monospace">String.format("null null")</span>.</p><p>Case <a href="#formatter-array-warning">3</a>:
Array format arguments.
The Format String Checker performs no analysis of
arrays, only of varargs invocations. It is better style to use varargs
when possible.</p>
<!--TOC subsection id="formatter-missed-alarms" Possible missed alarms-->
<h3 id="formatter-missed-alarms" class="subsection">10.3.2&#XA0;&#XA0;Possible missed alarms</h3><!--SEC END --><p>The Format String Checker helps prevent bugs by detecting, at compile time,
which invocations of format methods will fail. While the Format String Checker
finds most of these invocations, there are cases in which a format method call
will fail even though the Format String Checker issued neither errors nor
warnings. These cases are:</p><ol class="enumerate" type=1><li class="li-enumerate">
The format string is <span style="font-family:monospace">null</span>. Use the <a href="#nullness-checker">Nullness Checker</a> to prevent this.
</li><li class="li-enumerate">A format argument&#X2019;s <span style="font-family:monospace">toString</span> method throws an exception.
</li><li class="li-enumerate">A format argument implements the <span style="font-family:monospace">Formattable</span> interface and throws an
exception in the <span style="font-family:monospace">formatTo</span> method.
</li><li class="li-enumerate">A format argument&#X2019;s conversion category is <span style="font-family:monospace">CHAR</span> or <span style="font-family:monospace">CHAR_AND_INT</span>,
and the passed value is an <span style="font-family:monospace">int</span> or <span style="font-family:monospace">Integer</span>, and
<span style="font-family:monospace">Character.isValidCodePoint(argument)</span> returns <span style="font-family:monospace">false</span>.
</li></ol><p>The following examples illustrate these limitations:</p><pre class="verbatim">    class A {
        public String toString() {
            throw new Error();
        }
    }

    class B implements Formattable {
        public void formatTo(Formatter fmt, int f,
                int width, int precision) {
            throw new Error();
        }
    }

    // The checker issues no errors or warnings for the
    // following illegal invocations of format methods.
    String.format(null);          // NullPointerException (1)
    String.format("%s", new A()); // Error (2)
    String.format("%s", new B()); // Error (3)
    String.format("%c", (int)-1); // IllegalFormatCodePointException (4)
</pre>
<!--TOC section id="formatter-implicit" Implicit qualifiers-->
<h2 id="formatter-implicit" class="section">10.4&#XA0;&#XA0;Implicit qualifiers</h2><!--SEC END --><p>As described in Section&#XA0;<a href="#effective-qualifier">23.3</a>, the Format String Checker adds implicit
qualifiers, reducing the number of annotations that must appear in your code.
The checker implicitly adds the <span style="font-family:monospace">@Format</span> qualifier with the appropriate
conversion categories to any String literal that is a valid format string.</p>
<!--TOC section id="formatter-FormatMethod" FormatMethod-->
<h2 id="formatter-FormatMethod" class="section">10.5&#XA0;&#XA0;FormatMethod</h2><!--SEC END --><p>Your project may contain methods that forward their arguments to a format method.
Consider for example the following <span style="font-family:monospace">log</span> method:</p><pre class="verbatim">@FormatMethod
void log(String format, Object... args) {
    if (enabled) {
        logfile.print(indent_str);
        logfile.printf(format , args);
    }
}
</pre><p>By attaching a <a href="api/org/checkerframework/checker/formatter/qual/FormatMethod.html"><span style="font-family:monospace">@FormatMethod</span></a> annotation to
such a method, you can instruct the Format String Checker to check every
invocation of the method. This check is analogous to the check done on
every invocation of built in format methods like <span style="font-family:monospace">String.format</span>.</p>
<!--TOC section id="formatter-run-time-tests" Testing whether a format string is valid-->
<h2 id="formatter-run-time-tests" class="section">10.6&#XA0;&#XA0;Testing whether a format string is valid</h2><!--SEC END --><p>The Format String Checker automatically determines whether each <span style="font-family:monospace">String</span>
literal is a valid format string or not. When a string is computed or is
obtained from an external resource, then the string must be trusted or tested.</p><p>One way to test a string is to call the
<a href="api/org/checkerframework/checker/formatter/FormatUtil.html#asFormat-java.lang.String-org.checkerframework.checker.formatter.qual.ConversionCategory...-"><span style="font-family:monospace">FormatUtil.asFormat</span></a>
method to check whether the format string is valid and its format
specifiers match certain conversion categories.
If this is not the case, <span style="font-family:monospace">asFormat</span> raises an exception. Your code should
catch this exception and handle it gracefully.</p><p>The following code examples may fail at run time, and therefore they do not
type check. The type-checking errors are indicated by comments.</p><pre class="verbatim">Scanner s = new Scanner(System.in);
String fs = s.next();
System.out.printf(fs, "hello", 1337);          // error: fs is not known to be a format string
</pre><pre class="verbatim">Scanner s = new Scanner(System.in);
@Format({GENERAL, INT}) String fs = s.next();  // error: fs is not known to have the given type
System.out.printf(fs, "hello", 1337);          // OK
</pre><p>The following variant does not throw a run-time error, and
therefore passes the type-checker:</p><pre class="verbatim">Scanner s = new Scanner(System.in);
String format = s.next()
try {
    format = FormatUtil.asFormat(format, GENERAL, INT);
} catch (IllegalFormatException e) {
    // Replace this by your own error handling.
    System.err.println("The user entered the following invalid format string: " + format);
    System.exit(2);
}
// fs is now known to be of type: @Format({GENERAL, INT}) String
System.out.printf(format, "hello", 1337);
</pre><p>A potential disadvantage of using the <span style="font-family:monospace">FormatUtil</span> class is that your code becomes
dependent on the Checker Framework at run time as well as at compile time. You
can avoid this by adding the Checker Framework to your project, or by copying
the <span style="font-family:monospace">FormatUtil</span> class into your own code.</p><hr>
<!--TOC chapter id="i18n-formatter-checker" Internationalization Format String Checker (I18n Format String Checker)-->
<h1 id="i18n-formatter-checker" class="chapter">Chapter&#XA0;11&#XA0;&#XA0;Internationalization Format String Checker (I18n Format String Checker)</h1><!--SEC END --><p>The Internationalization Format String Checker, or I18n Format String Checker,
prevents use of incorrect i18n format strings.</p><p>If the I18n Format String Checker issues no warnings or errors, then
<a href="http://docs.oracle.com/javase/8/docs/api/java/text/MessageFormat.html#format-java.lang.String-java.lang.Object...-"><span style="font-family:monospace">MessageFormat.format</span></a>
will raise no error at run time.
&#X201C;I18n&#X201D; is short for
&#X201C;internationalization&#X201D; because there are 18 characters between the &#X201C;i&#X201D; and
the &#X201C;n&#X201D;.</p><p>Here are the examples of errors that the
I18n Format Checker
detects at compile time.</p><pre class="verbatim">  // Warning: the second argument is missing.
  MessageFormat.format("{0} {1}", 3.1415);
  // String argument cannot be formatted as Time type.
  MessageFormat.format("{0, time}", "my string");
  // Invalid format string: unknown format type: thyme.
  MessageFormat.format("{0, thyme}", new Date());
  // Invalid format string: missing the right brace.
  MessageFormat.format("{0", new Date());
  // Invalid format string: the argument index is not an integer.
  MessageFormat.format("{0.2, time}", new Date());
  // Invalid format string: "#.#.#" subformat is invalid.
  MessageFormat.format("{0, number, #.#.#}", 3.1415);
</pre><p>For instructions on how to run the Internationalization Format String
Checker, see Section&#XA0;<a href="#i18n-format-running">11.5</a>.</p><p>The Internationalization Checker or I18n Checker (Chapter&#XA0;<a href="#i18n-checker">12.2</a>)
has a different purpose. It verifies that your code is properly
internationalized: any user-visible text should be obtained from a
localization resource and all keys exist in that resource.</p>
<!--TOC section id="i18n-format-annotation" Internationalization Format String Checker annotations-->
<h2 id="i18n-format-annotation" class="section">11.1&#XA0;&#XA0;Internationalization Format String Checker annotations</h2><!--SEC END --><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<img src="i18n-format-type-hierarchy.svg">
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 11.1: The
Internationalization
Format String Checker type qualifier hierarchy.
The figure does not show the subtyping rules among different
<a href="api/org/checkerframework/checker/i18nformatter/qual/I18nFormat.html"><span style="font-family:monospace">@I18nFormat</span></a><span style="font-family:monospace">(...)</span>
qualifiers; see
Section&#XA0;<a href="#i18n-format-conversion-catgeories">11.2</a>.
All <a href="api/org/checkerframework/checker/i18nformatter/qual/I18nFormatFor.html"><span style="font-family:monospace">@I18nFormatFor</span></a> annotations are unrelated by subtyping.
The qualifiers in gray are used internally by
the checker and should never be written by a programmer.
</td></tr>
</table></div>
<a id="i18n-format-type-hierarchy"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p>The <a href="http://docs.oracle.com/javase/8/docs/api/java/text/MessageFormat.html"><span style="font-family:monospace">MessageFormat</span></a> documentation
specifies the syntax of the i18n format string.</p><p>These are the qualifiers that make up the I18n Format String type system.
Figure&#XA0;<a href="#i18n-format-type-hierarchy">11.1</a> shows their subtyping relationships.</p><dl class="description"><dt class="dt-description"><a href="api/org/checkerframework/checker/i18nformatter/qual/I18nFormat.html"><span style="font-weight:bold"><span style="font-family:monospace">@I18nFormat</span></span></a></dt><dd class="dd-description">
represents a valid i18n format string. For example,
<span style="font-family:monospace">@I18nFormat({GENERAL, NUMBER, UNUSED, DATE})</span> is a legal type for
<span style="font-family:monospace">"{0}{1, number} {3, date}"</span>, indicating that when the format
string is used,
the first argument should be of <span style="font-family:monospace">GENERAL</span> conversion category,
the second argument should be of <span style="font-family:monospace">NUMBER</span> conversion category, and so on.
Conversion categories such as <span style="font-family:monospace">GENERAL</span> are described in
Section&#XA0;<a href="#i18n-format-conversion-catgeories">11.2</a>.</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/i18nformatter/qual/I18nFormatFor.html"><span style="font-weight:bold"><span style="font-family:monospace">@I18nFormatFor</span></span></a></dt><dd class="dd-description">
indicates that the qualified type is a valid i18n format string for use
with some array of values. For example,
<span style="font-family:monospace">@I18nFormatFor("#2")</span> indicates that the string can be used to
format the contents of the second parameter array.
The argument is a Java expression whose syntax
is explained in Section&#XA0;<a href="#java-expressions-as-arguments">23.5</a>.
An example of its use is:<pre class="verbatim">  static void method(@I18nFormatFor("#2") String format, Object... args) {
    // the body may use the parameters like this:
    MessageFormat.format(format, args);
  }

  method("{0, number} {1}", 3.1415, "A string");  // OK
  // error: The string "hello" cannot be formatted as a Number.
  method("{0, number} {1}", "hello", "goodbye");
</pre></dd><dt class="dt-description"><a href="api/org/checkerframework/checker/i18nformatter/qual/I18nInvalidFormat.html"><span style="font-weight:bold"><span style="font-family:monospace">@I18nInvalidFormat</span></span></a></dt><dd class="dd-description">
represents an invalid i18n format string. Programmers are not allowed to
write this annotation. It is only used internally by the type checker.</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/i18nformatter/qual/I18nUnknownFormat.html"><span style="font-weight:bold"><span style="font-family:monospace">@I18nUnknownFormat</span></span></a></dt><dd class="dd-description">
represents any string. The string might or might not be a valid i18n
format string. Programmers are not allowed to write this annotation.</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/i18nformatter/qual/I18nFormatBottom.html"><span style="font-weight:bold"><span style="font-family:monospace">@I18nFormatBottom</span></span></a></dt><dd class="dd-description">
indicates that the value is definitely <span style="font-family:monospace">null</span>. Programmers are not allowed
to write this annotation.
</dd></dl>
<!--TOC section id="i18n-format-conversion-catgeories" Conversion categories-->
<h2 id="i18n-format-conversion-catgeories" class="section">11.2&#XA0;&#XA0;Conversion categories</h2><!--SEC END --><p>In a message string, the optional second element within the curly braces is
called a <em>format type</em> and must be one of <span style="font-family:monospace">number</span>, <span style="font-family:monospace">date</span>,
<span style="font-family:monospace">time</span>, and <span style="font-family:monospace">choice</span>. These four format types correspoond to different
conversion categories. <span style="font-family:monospace">date</span> and <span style="font-family:monospace">time</span> correspond to <em>DATE</em> in the
conversion categories figure. <span style="font-family:monospace">choice</span> corresponds to <em>NUMBER</em>.
The format type restricts what arguments are legal.
For example, a date argument is not compatible with
the <span style="font-family:monospace">number</span> format type, i.e., <span style="font-family:monospace">MessageFormat.format("{0, number}",
new Date())</span> will throw an exception.</p><p>The I18n Checker represents the possible arguments via <em>conversion
categories</em>. A conversion category defines a set of restrictions or a
subtyping rule.</p><p>Figure&#XA0;<a href="#i18n-format-category">11.2</a> summarizes the subset
relationship among all conversion categories.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<img src="i18n-format-category.svg">
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 11.2: The subset relationship among
i18n
conversion categories.</td></tr>
</table></div>
<a id="i18n-format-category"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p><a id="i18n-formatter-format-subtyping"></a>
Here are the subtyping rules among different
<span style="font-family:monospace">@I18nFormat</span>
qualifiers.
It is legal to:</p><ul class="itemize"><li class="li-itemize">
use a format string with a weaker (less restrictive) conversion category than required.
</li><li class="li-itemize">use a format string with fewer format specifiers than required, but a warning is issued.
</li></ul><p>The following example shows the subtyping rules in action:</p><pre class="verbatim">  @I18nFormat({NUMBER, NUMBER}) String format;
  // OK.
  format = "{0, number, #.#} {1, number}";
  // OK, GENERAL is weaker (less restrictive) than NUMBER.
  format = "{0, number} {1}";
  // Error, the right-hand-side is stronger (more restrictive) than the left-hand-side's type.
  format = "{0} {1} {2}";
</pre><p>The conversion categories are:</p><dl class="description"><dt class="dt-description"><a href="api/org/checkerframework/checker/i18nformatter/qual/I18nConversionCategory.html#UNUSED"><span style="font-weight:bold"><span style="font-family:monospace">UNUSED</span></span></a></dt><dd class="dd-description">
indicates an unused argument. For example, in
<span style="font-family:monospace">MessageFormat.format("{0, number} {2, number}", 3.14, "Hello", 2.718)</span>
, the second argument <span style="font-family:monospace">Hello</span> is unused. Thus, the conversion
categories for the format, <span style="font-family:monospace">0, number</span><span style="font-family:monospace"> </span><span style="font-family:monospace">2, number</span>, is
<span style="font-family:monospace">(NUMBER, UNUSED, NUMBER)</span>.</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/i18nformatter/qual/I18nConversionCategory.html#GENERAL"><span style="font-weight:bold"><span style="font-family:monospace">GENERAL</span></span></a></dt><dd class="dd-description">
means that any value can be supplied as an argument.</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/i18nformatter/qual/I18nConversionCategory.html#DATE"><span style="font-weight:bold"><span style="font-family:monospace">DATE</span></span></a></dt><dd class="dd-description">
is applicable for date, time, and number types. An argument needs to be
of <a href="http://docs.oracle.com/javase/8/docs/api/java/sql/Date.html"><span style="font-family:monospace">Date</span></a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/sql/Time.html"><span style="font-family:monospace">Time</span></a>, or <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Number.html"><span style="font-family:monospace">Number</span></a> type or a subclass of them,
including <a href="http://docs.oracle.com/javase/8/docs/api/java/sql/Timestamp.html"><span style="font-family:monospace">Timestamp</span></a> and the classes
listed immediately below.</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/i18nformatter/qual/I18nConversionCategory.html#NUMBER"><span style="font-weight:bold"><span style="font-family:monospace">NUMBER</span></span></a></dt><dd class="dd-description">
means that the argument needs to be of <span style="font-family:monospace">Number</span>
type or a subclass:
<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Number.html"><span style="font-family:monospace">Number</span></a>,
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicInteger.html"><span style="font-family:monospace">AtomicInteger</span></a>,
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicLong.html"><span style="font-family:monospace">AtomicLong</span></a>,
<a href="http://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html"><span style="font-family:monospace">BigDecimal</span></a>,
<a href="http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html"><span style="font-family:monospace">BigInteger</span></a>,
<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Byte.html"><span style="font-family:monospace">Byte</span></a>,
<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Double.html"><span style="font-family:monospace">Double</span></a>,
<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Float.html"><span style="font-family:monospace">Float</span></a>,
<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html"><span style="font-family:monospace">Integer</span></a>,
<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Long.html"><span style="font-family:monospace">Long</span></a>,
<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Short.html"><span style="font-family:monospace">Short</span></a>.</dd></dl>
<!--TOC section id="i18n-format-checks" What the Internationalization Format String Checker checks-->
<h2 id="i18n-format-checks" class="section">11.3&#XA0;&#XA0;What the Internationalization Format String Checker checks</h2><!--SEC END --><p>The Internationalization Format String Checker checks calls to the i18n
formatting method <a href="http://docs.oracle.com/javase/8/docs/api/java/text/MessageFormat.html#format-java.lang.String-java.lang.Object...-"><span style="font-family:monospace">MessageFormat.format</span></a>
and guarantees the following:</p><ol class="enumerate" type=1><li class="li-enumerate">
The checker issues a warning for the following cases:
<ol class="enumerate" type=a><li class="li-enumerate">
There are missing arguments from what is required by the format string.<p><span style="font-family:monospace">MessageFormat.format("{0, number} {1, number}", 3.14); // Output: 3.14 {1}</span></p></li><li class="li-enumerate">More arguments are passed than what is required by the format string.<p><span style="font-family:monospace">MessageFormat.format("{0, number}", 1, new Date());</span></p><p><span style="font-family:monospace">MessageFormat.format("{0, number} {0, number}", 3.14, 3.14);</span></p><p>This does not cause an error at run time, but it often indicates a
programmer mistake. If it is intentional, then you should suppress
the warning (see Chapter&#XA0;<a href="#suppressing-warnings">24</a>).</p></li><li class="li-enumerate">Some argument is an array of objects.<p><span style="font-family:monospace">MessageFormat.format("{0, number} {1}", array);</span></p><p>The checker cannot verify whether the format string is valid, so
the checker conservatively issues a warning. This is a limitation of
the Internationalization Format String Checker.</p></li></ol>
</li><li class="li-enumerate">The checker issues an error for the following cases:
<ol class="enumerate" type=a><li class="li-enumerate">
The format string is invalid.<ul class="itemize"><li class="li-itemize">
Unmatched braces.<p><span style="font-family:monospace">MessageFormat.format("{0, time", new Date());</span></p></li><li class="li-itemize">The argument index is not an integer or is negative.<p><span style="font-family:monospace">MessageFormat.format("{0.2, time}", new Date());</span></p><p><span style="font-family:monospace">MessageFormat.format("{-1, time}", new Date());</span></p></li><li class="li-itemize">Unknown format type.<p><span style="font-family:monospace">MessageFormat.format("{0, foo}", 3.14);</span></p></li><li class="li-itemize">Missing a format style required for <span style="font-family:monospace">choice</span> format.<p><span style="font-family:monospace">MessageFormat.format("{0, choice}", 3.14);</span></p></li><li class="li-itemize">Wrong format style.<p><span style="font-family:monospace">MessageFormat.format("{0, time, number}", 3.14);</span></p></li><li class="li-itemize">Invalid subformats.<p><span style="font-family:monospace">MessageFormat.format("{0, number, #.#.#}", 3.14)</span>
</p></li></ul></li><li class="li-enumerate">Some argument&#X2019;s type doesn&#X2019;t satisfy its conversion category.<p><span style="font-family:monospace">MessageFormat.format("{0, number}", new Date());</span>
</p></li></ol>
</li></ol><p>The Checker also detects illegal assignments: assigning a non-format-string
or an incompatible format string to a variable declared as containing a
specific type of format string. For example,</p><pre class="verbatim">  @I18nFormat({GENERAL, NUMBER}) String format;
  // OK.
  format = "{0} {1, number}";
  // OK, GENERAL is weaker (less restrictive) than NUMBER.
  format = "{0} {1}";
  // OK, it is legal to have fewer arguments than required (less restrictive).
  // But the warning will be issued instead.
  format = "{0}";

  // Error, the format string is stronger (more restrictive) than the specifiers.
  format = "{0} {1} {2}";
  // Error, the format string is more restrictive. NUMBER is a subtype of GENERAL.
  format = "{0, number} {1, number}";
</pre>
<!--TOC section id="i18n-format-resource-files" Resource files-->
<h2 id="i18n-format-resource-files" class="section">11.4&#XA0;&#XA0;Resource files</h2><!--SEC END --><p>A programmer rarely writes an i18n format string literally. (The examples
in this chapter show that for simplicity.) Rather, the i18n format strings are
read from a resource file. The program chooses a resource file at run time
depending on the locale (for example, different resource files for English
and Spanish users).</p><p>For example, suppose that the <span style="font-family:monospace">resource1.properties</span> file contains</p><pre class="verbatim">  key1 = The number is {0, number}.
</pre><p>Then code such as the following:</p><pre class="verbatim">  String formatPattern = ResourceBundle.getBundle("resource1").getString("key1");
  System.out.println(MessageFormat.format(formatPattern, 2.2361));
</pre><p>will output &#X201C;The number is 2.2361.&#X201D; A different resource file would contain
<span style="font-family:monospace">key1 = El n&#XFA;mero es {0, number}.</span></p><p>When you run the I18n Format String Checker, you need to indicate which resource file it
should check. If you change the resource file or use a different resource
file, you should re-run the checker
to ensure that you did not make an error. The I18n Format String Checker supports two types of
resource files: ResourceBundles and property files. The example above shows use of
resource bundles.
For more about checking property files, see Chapter&#XA0;<a href="#propkey-checker">12</a>.</p>
<!--TOC section id="i18n-format-running" Running the Internationalization Format Checker-->
<h2 id="i18n-format-running" class="section">11.5&#XA0;&#XA0;Running the Internationalization Format Checker</h2><!--SEC END --><p>The checker can be invoked by running one of the following commands (with
the whole command on one line).</p><ul class="itemize"><li class="li-itemize">
Using ResourceBundles:<p>
<span style="font-family:monospace">javac -processor
org.checkerframework.checker.i18nformatter.I18nFormatterChecker
-Abundlenames=MyResource MyFile.java</span>
</p></li><li class="li-itemize">Using property files:<p>
<span style="font-family:monospace">javac -processor
org.checkerframework.checker.i18nformatter.I18nFormatterChecker
-Apropfiles=MyResource.properties MyFile.java</span>
</p></li><li class="li-itemize">Not using a property file. Use this if the programmer hard-coded the
format patterns without loading them from a property file.<p>
<span style="font-family:monospace">javac -processor
org.checkerframework.checker.i18nformatter.I18nFormatterChecker MyFile.java</span>

</p></li></ul>
<!--TOC section id="i18n-format-testing" Testing whether a string has an i18n format type-->
<h2 id="i18n-format-testing" class="section">11.6&#XA0;&#XA0;Testing whether a string has an i18n format type</h2><!--SEC END --><p>In the case that the checker cannot infer the i18n format type of a string,
you can use the <a href="api/org/checkerframework/checker/i18nformatter/I18nFormatUtil.html#hasFormat-java.lang.String-org.checkerframework.checker.i18nformatter.qual.I18nConversionCategory...-"><span style="font-family:monospace">I18nFormatUtil.hasFormat</span></a>
method to define the type of the string in the scope of a conditional statement.</p><dl class="description"><dt class="dt-description"><a href="api/org/checkerframework/checker/i18nformatter/I18nFormatUtil.html#hasFormat-java.lang.String-org.checkerframework.checker.i18nformatter.qual.I18nConversionCategory...-"><span style="font-weight:bold"><span style="font-family:monospace">I18nFormatUtil.hasFormat</span></span></a></dt><dd class="dd-description">
returns <span style="font-family:monospace">true</span> if the given string has the given i18n format type.</dd></dl><p>For an example, see Section&#XA0;<a href="#i18n-format-examples">11.7</a>.</p>
<!--TOC section id="i18n-format-examples" Examples of using the Internationalization Format Checker-->
<h2 id="i18n-format-examples" class="section">11.7&#XA0;&#XA0;Examples of using the Internationalization Format Checker</h2><!--SEC END --><ul class="itemize"><li class="li-itemize">
Using <a href="http://docs.oracle.com/javase/8/docs/api/java/text/MessageFormat.html#format-java.lang.String-java.lang.Object...-"><span style="font-family:monospace">MessageFormat.format</span></a>.
<pre class="verbatim">      // suppose the bundle "MyResource" contains:  key1={0, number} {1, date}
      String value = ResourceBundle.getBundle("MyResource").getString("key1");
      MessageFormat.format(value, 3.14, new Date());  // OK
      // error: incompatible types in argument; found String, expected number
      MessageFormat.format(value, "Text", new Date());
</pre></li><li class="li-itemize">Using the
<a href="api/org/checkerframework/checker/i18nformatter/I18nFormatUtil.html#hasFormat-java.lang.String-org.checkerframework.checker.i18nformatter.qual.I18nConversionCategory...-"><span style="font-family:monospace">I18nFormatUtil.hasFormat</span></a>
method to check whether a format
string has particular conversion categories.
<pre class="verbatim">      void test1(String format) {
        if (I18nFormatUtil.hasFormat(format, I18nConversionCategory.GENERAL,
                                             I18nConversionCategory.NUMBER)) {
          MessageFormat.format(format, "Hello", 3.14);  // OK
          // error: incompatible types in argument; found String, expected number
          MessageFormat.format(format, "Hello", "Bye");
          // error: missing arguments; expected 2 but 1 given
          MessageFormat.format(format, "Bye");
          // error: too many arguments; expected 2 but 3 given
          MessageFormat.format(format, "A String", 3.14, 3.14);
        }
      }
</pre></li><li class="li-itemize">Using <a href="api/org/checkerframework/checker/i18nformatter/qual/I18nFormatFor.html"><span style="font-family:monospace">@I18nFormatFor</span></a>
to ensure that an argument is a particular type of format string.
<pre class="verbatim">      static void method(@I18nFormatFor("#2") String f, Object... args) {...}

      // OK, MessageFormat.format(...) would return "3.14 Hello greater than one"
      method("{0, number} {1} {2, choice,0#zero|1#one|1&lt;greater than one}",
             3.14, "Hello", 100);

      // error: incompatible types in argument; found String, expected number
      method("{0, number} {1}", "Bye", "Bye");
</pre></li><li class="li-itemize">Annotating a string with
<a href="api/org/checkerframework/checker/i18nformatter/qual/I18nFormat.html"><span style="font-family:monospace">@I18nFormat</span></a>.
<pre class="verbatim">      @I18nFormat({I18nConversionCategory.DATE}) String;
      s1 = "{0}";
      s1 = "{0, number}";        // error: incompatible types in assignment
</pre></li></ul><hr>
<!--TOC chapter id="propkey-checker" Property File Checker-->
<h1 id="propkey-checker" class="chapter">Chapter&#XA0;12&#XA0;&#XA0;Property File Checker</h1><!--SEC END --><p>The Property File Checker ensures that a property file or resource bundle (both
of which act like maps from keys to values) is only accessed with valid keys.
Accesses without a valid key either return <span style="font-family:monospace">null</span> or a default value, which
can lead to a <span style="font-family:monospace">NullPointerException</span> or hard-to-trace behavior.
The Property File Checker (Section <a href="#genpropkey-checker">12.1</a>) ensures
that the used keys are found in the corresponding property file or resource
bundle.</p><p>We also provide two specialized checkers.
An Internationalization Checker (Section <a href="#i18n-checker">12.2</a>)
verifies that code is properly internationalized.
A Compiler Message Key Checker (Section <a href="#compilermsgs-checker">12.3</a>)
verifies that compiler message keys used in the Checker Framework are
declared in a property file;
This is an example of a simple specialization of the property
file checker, and the Checker Framework source code shows how it is used.</p><p>It is easy to customize the property key checker for other related purposes.
Take a look at the source code of the Compiler Message Key Checker and adapt it for
your purposes.</p>
<!--TOC section id="genpropkey-checker" General Property File Checker-->
<h2 id="genpropkey-checker" class="section">12.1&#XA0;&#XA0;General Property File Checker</h2><!--SEC END --><p>The general Property File Checker ensures that a resource key is located
in a specified property file or resource bundle.</p><p>The annotation <a href="api/org/checkerframework/checker/propkey/qual/PropertyKey.html"><span style="font-family:monospace">@PropertyKey</span></a>
indicates that the qualified <span style="font-family:monospace">String</span> is a valid key
found in the property file or resource bundle.
You do not need to annotate <span style="font-family:monospace">String</span> literals.
The checker looks up every <span style="font-family:monospace">String</span> literal in the specified
property file or resource bundle, and adds annotations as appropriate.</p><p>If you pass a <span style="font-family:monospace">String</span> variable to be eventually used as a key, you
also need to annotate all these variables with <span style="font-family:monospace">@PropertyKey</span>.</p><p>The checker can be invoked by running the following
command:</p><pre class="verbatim">  javac -processor org.checkerframework.checker.propkey.PropertyKeyChecker
        -Abundlenames=MyResource MyFile.java ...
</pre><p>You must specify the resources, which map keys to strings.
The checker supports two types of resource:
resource bundles and property files. You can specify one or both of the
following two command-line options:</p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">-Abundlenames=</span><span style="font-family:monospace"><em>resource_name</em></span><p><em>resource_name</em> is the name of the resource to be used with
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html#getBundle-java.lang.String-java.util.Locale-java.lang.ClassLoader-"><span style="font-family:monospace">ResourceBundle.getBundle()</span></a>.
The checker uses the default <span style="font-family:monospace">Locale</span> and <span style="font-family:monospace">ClassLoader</span> in the
compilation system.
(For a tutorial about <span style="font-family:monospace">ResourceBundle</span>s, see
<a href="https://docs.oracle.com/javase/tutorial/i18n/resbundle/concept.html"><span style="font-family:monospace">https://docs.oracle.com/javase/tutorial/i18n/resbundle/concept.html</span></a>.)
Multiple resource bundle names are separated by colons &#X2019;<span style="font-family:monospace">:</span>&#X2019;.</p></li><li class="li-enumerate"><span style="font-family:monospace">-Apropfiles=</span><span style="font-family:monospace"><em>prop_file</em></span><p><em>prop_file</em> is the name of a properties file that maps
keys to values. The file format is described in
the Javadoc for
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Properties.html#load-java.io.Reader-"><span style="font-family:monospace">Properties.load()</span></a>.
Multiple files are separated by colons &#X2019;<span style="font-family:monospace">:</span>&#X2019;.</p></li></ol>
<!--TOC section id="i18n-checker" Internationalization Checker-->
<h2 id="i18n-checker" class="section">12.2&#XA0;&#XA0;Internationalization Checker</h2><!--SEC END --><p>The Internationalization Checker, or I18n Checker, verifies that your code is properly
internationalized. Internationalization is the process of designing software so that
it can be adapted to different languages and locales without needing to change the code.
Localization is the process of adapting internationalized software to specific languages
and locales.</p><p>Internationalization is sometimes called i18n, because the word starts with &#X201C;i&#X201D;,
ends with &#X201C;n&#X201D;, and has 18 characters in between. Localization is similarly
sometimes abbreviated as l10n.</p><p>The checker focuses on one aspect of internationalization: user-visible strings
should be presented in the user&#X2019;s own language, such as English, French, or
German. This is achieved by looking up keys in a localization resource,
which maps keys to user-visible strings. For instance, one version of a
resource might map <span style="font-family:monospace">"CANCEL_STRING"</span> to
<span style="font-family:monospace">"Cancel"</span>, and another version of the same resource might map
<span style="font-family:monospace">"CANCEL_STRING"</span> to <span style="font-family:monospace">"Abbrechen"</span>.</p><p>There are other aspects to localization, such as formatting of dates (3/5
vs.&#XA0;5/3 for March 5), that the checker does not check.</p><p>The Internationalization Checker verifies these two properties:</p><ol class="enumerate" type=1><li class="li-enumerate">Any user-visible text should be obtained from a localization resource.
For example, <span style="font-family:monospace">String</span> literals should not be output to the user.</li><li class="li-enumerate">When looking up keys in a localization resource, the key should exist in
that resource. This check catches incorrect or misspelled localization
keys.</li></ol><p>If you use the Internationalization Checker, you may want to also use the
Internationalization Format String Checker, or I18n Format String Checker
(Chapter&#XA0;<a href="#i18n-formatter-checker">11</a>).
It verifies that internationalization format strings are well-formed and
used with arguments of the proper type, so that
<a href="http://docs.oracle.com/javase/8/docs/api/java/text/MessageFormat.html#format-java.lang.String-java.lang.Object...-"><span style="font-family:monospace">MessageFormat.format</span></a>
does not fail at run time.</p>
<!--TOC subsection id="i18n-annotations" Internationalization annotations-->
<h3 id="i18n-annotations" class="subsection">12.2.1&#XA0;&#XA0;Internationalization annotations</h3><!--SEC END --><p>The Internationalization Checker supports two annotations:</p><ol class="enumerate" type=1><li class="li-enumerate">
<a href="api/org/checkerframework/checker/i18n/qual/Localized.html"><span style="font-family:monospace">@Localized</span></a>: indicates that the qualified
<span style="font-family:monospace">String</span> is a message that has been localized and/or formatted with
respect to the used locale.</li><li class="li-enumerate"><a href="api/org/checkerframework/checker/i18n/qual/LocalizableKey.html"><span style="font-family:monospace">@LocalizableKey</span></a>: indicates that the
qualified <span style="font-family:monospace">String</span> or <span style="font-family:monospace">Object</span> is a valid key found in the
localization resource.
This annotation is a specialization of the <span style="font-family:monospace">@PropertyKey</span> annotation, that
gets checked by the general Property Key Checker.
</li></ol><p>You may need to add the <span style="font-family:monospace">@Localized</span> annotation to more methods in the
JDK or other libraries, or in your own code.</p>
<!--TOC subsection id="i18n-running" Running the Internationalization Checker-->
<h3 id="i18n-running" class="subsection">12.2.2&#XA0;&#XA0;Running the Internationalization Checker</h3><!--SEC END --><p>The Internationalization Checker can be invoked by running the following
command:</p><pre class="verbatim">  javac -processor org.checkerframework.checker.i18n.I18nChecker -Abundlenames=MyResource MyFile.java ...
</pre><p>You must specify the localization resource, which maps keys to user-visible
strings. Like the general Property Key Checker, the Internationalization Checker
supports two types of localization resource:
<span style="font-family:monospace">ResourceBundle</span>s using the
<span style="font-family:monospace">-Abundlenames=</span><span style="font-family:monospace"><em>resource_name</em></span> option
or property files using the
<span style="font-family:monospace">-Apropfiles=</span><span style="font-family:monospace"><em>prop_file</em></span> option.</p>
<!--TOC section id="compilermsgs-checker" Compiler Message Key Checker-->
<h2 id="compilermsgs-checker" class="section">12.3&#XA0;&#XA0;Compiler Message Key Checker</h2><!--SEC END --><p>The Checker Framework uses compiler message keys to output error messages.
These keys are substituted by localized strings for user-visible error messages.
Using keys instead of the localized strings in the source code enables easier
testing, as the expected error keys can stay unchanged while the localized
strings can still be modified.
We use the Compiler Message Key Checker to ensure that all internal
keys are correctly localized.
Instead of using the Property File Checker, we use a specialized checker,
giving us more precise documentation of the intended use of <span style="font-family:monospace">String</span>s.</p><p>The single annotation used by this checker is
<a href="api/org/checkerframework/checker/compilermsgs/qual/CompilerMessageKey.html"><span style="font-family:monospace">@CompilerMessageKey</span></a>.
The Checker Framework is completely annotated;
for example, class <span style="font-family:monospace">org.checkerframework.framework.source.Result</span>
uses <span style="font-family:monospace">@CompilerMessageKey</span> in methods <span style="font-family:monospace">failure</span> and <span style="font-family:monospace">warning</span>.
For most users of the Checker Framework there will be no need to annotate any
<span style="font-family:monospace">String</span>s, as the checker looks up all <span style="font-family:monospace">String</span> literals and adds
annotations as appropriate.</p><p>The Compiler Message Key Checker can be invoked by running the following
command:</p><pre class="verbatim">  javac -processor org.checkerframework.checker.compilermsgs.CompilerMessagesChecker
        -Apropfiles=messages.properties MyFile.java ...
</pre><p>You must specify the resource, which maps compiler message keys to user-visible
strings. The checker supports the same options as the general property key checker.
Within the Checker Framework we only use property files,
so the <span style="font-family:monospace">-Apropfiles=</span><span style="font-family:monospace"><em>prop_file</em></span> option should be used.</p><hr>
<!--TOC chapter id="signature-checker" Signature String Checker for string representations of types-->
<h1 id="signature-checker" class="chapter">Chapter&#XA0;13&#XA0;&#XA0;Signature String Checker for string representations of types</h1><!--SEC END --><p>The Signature String Checker, or Signature Checker for short, verifies that
string representations of types and signatures are used correctly.</p><p>Java defines multiple different string representations for types (see
Section&#XA0;<a href="#signature-annotations">13.1</a>), and it is easy to
misuse them or to miss bugs during testing. Using the wrong string format
leads to a run-time exception or an incorrect result. This is a particular
problem for fully qualified and binary names, which are nearly the same &#X2014;
they differ only for nested classes and arrays.</p>
<!--TOC section id="signature-annotations" Signature annotations-->
<h2 id="signature-annotations" class="section">13.1&#XA0;&#XA0;Signature annotations</h2><!--SEC END --><p>Java defines six formats for the string representation of a type.
There is an annotation for each of these representations.
Figure&#XA0;<a href="#fig-signature-hierarchy">13.1</a> shows how they are related;
examples appear in a table below.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<img src="signature-types.svg">
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 13.1: Partial type hierarchy for the Signature type system, showing
string representations of a Java type. Programmers only need to write
the boldfaced qualifiers, in the second row; qualifiers below those are
included to improve the internal handling of String literals.</td></tr>
</table></div>
<a id="fig-signature-hierarchy"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><dl class="description"><dt class="dt-description"><a href="api/org/checkerframework/checker/signature/qual/FullyQualifiedName.html"><span style="font-weight:bold"><span style="font-family:monospace">@FullyQualifiedName</span></span></a></dt><dd class="dd-description">
A <em>fully qualified name</em> (<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-6.html#jls-6.7">JLS &#XA7;6.7</a>), such as
<span style="font-family:monospace">package.Outer.Inner</span>, is used in Java code and in messages to
the user.</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/signature/qual/BinaryName.html"><span style="font-weight:bold"><span style="font-family:monospace">@BinaryName</span></span></a></dt><dd class="dd-description">
A <em>binary name</em> (<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-13.html#jls-13.1">JLS &#XA7;13.1</a>), such as
<span style="font-family:monospace">package.Outer$Inner</span>, is
the conceptual name of a type in its own <span style="font-family:monospace">.class</span> file.</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/signature/qual/FieldDescriptor.html"><span style="font-weight:bold"><span style="font-family:monospace">@FieldDescriptor</span></span></a></dt><dd class="dd-description">
A <em>field descriptor</em> (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.2">JVMS &#XA7;4.3.2</a>), such as
<span style="font-family:monospace">Lpackage/Outer$Inner;</span>, is used in a <span style="font-family:monospace">.class</span> file&#X2019;s constant pool,
for example to refer to other types. It abbreviates primitives and
arrays. It uses internal form (binary names, but with <span style="font-family:monospace">/</span> instead of
<span style="font-family:monospace">.</span>; see
<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.2.1">JVMS
&#XA7;4.2</a>) for class names. See examples below.</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/signature/qual/ClassGetName.html"><span style="font-weight:bold"><span style="font-family:monospace">@ClassGetName</span></span></a></dt><dd class="dd-description">

The type representation used by the
<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getName--"><span style="font-family:monospace">Class.getName()</span></a>, <span style="font-family:monospace">Class.forName(String)</span>,
and <span style="font-family:monospace">Class.forName(String, boolean, ClassLoader)</span> methods. This format
is: for any non-array type, the binary name; and for any array type, a
format like the
<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.2">FieldDescriptor
field descriptor</a>, but using
&#X201C;<span style="font-family:monospace">.</span>&#X201D;&#XA0;where the field descriptor uses &#X201C;<span style="font-family:monospace">/</span>&#X201D;. See examples below.
</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/signature/qual/InternalForm.html"><span style="font-weight:bold"><span style="font-family:monospace">@InternalForm</span></span></a></dt><dd class="dd-description">
The <em>internal form</em>
(<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.2">JVMS
&#XA7;4.2</a>), such as <span style="font-family:monospace">package/Outer$Inner</span>, is how a class name is
actually represented in its own <span style="font-family:monospace">.class</span> file. It is also known as the
&#X201C;syntax of binary names that appear in class file structures&#X201D;. It is
the same as the binary name, but with periods (<span style="font-family:monospace">.</span>) replaced by slashes
(<span style="font-family:monospace">/</span>). Programmers more often use the binary name, leaving the internal
form as a JVM implementation detail.</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/signature/qual/ClassGetSimpleName.html"><span style="font-weight:bold"><span style="font-family:monospace">@ClassGetSimpleName</span></span></a></dt><dd class="dd-description">
The type representation returned by the
<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getSimpleName--"><span style="font-family:monospace">Class.getSimpleName()</span></a>
method. This format is not required by any method in the JDK, so you
will rarely write it in source code. The string can be empty. This
is not the same as the &#X201C;simple name&#X201D; defined in
(<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-6.html#jls-6.2">JLS
&#XA7;6.2</a>), which is the same as
<a href="api/org/checkerframework/checker/signature/qual/Identifier.html"><span style="font-family:monospace">@Identifier</span></a>.</dd></dl><p>Other type qualifiers are the intersection of two or more qualifiers listed
above; for example, a
<a href="api/org/checkerframework/checker/signature/qual/SourceNameForNonInner.html"><span style="font-family:monospace">@SourceNameForNonInner</span></a> is a string
that is a valid fully qualified name <em>and</em> a valid binary name. A
programmer should never or rarely use these qualifiers, and you can ignore
them as implementation details of the Signature Checker, though you might
occasionally see them in an error message. These qualifiers exist to give
literals sufficiently precise types that they can be used in any
appropriate context.</p><p>Java also defines other string formats for a type: qualified names
(<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-6.html#jls-6.2">JLS
&#XA7;6.2</a>) and canonical names
(<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-6.html#jls-6.7">JLS
&#XA7;6.7</a>). The Signature Checker does not include annotations for these.</p><p>Here are examples of the supported formats:</p><div class="center">
<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >fully-qualified name</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >binary name</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >Class.getName</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >field descriptor</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >internal form</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >Class.getSimpleName </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >int</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >int</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >int</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >I</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >int</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >int </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >int[][]</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >int[][]</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >[[I</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >[[I</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >int[][]</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >int[][] </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >MyClass</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >MyClass</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >MyClass</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >LMyClass;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >MyClass</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >MyClass </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >MyClass[]</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >MyClass[]</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >[LMyClass;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >[LMyClass;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >MyClass[]</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >MyClass[] </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><em>n/a </em><em>for anonymous class</em></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >MyClass$22</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >MyClass$22</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >LMyClass$22;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >MyClass$22</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><em>(empty string)</em> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><em>n/a </em><em>for
array of anon.&#XA0;class</em></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >MyClass$22[]</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >[LMyClass$22;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >[LMyClass$22;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >MyClass$22[]</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >[] </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >java.lang.Integer</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >java.lang.Integer</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >java.lang.Integer</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >Ljava/lang/Integer;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >java/lang/Integer</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >Integer </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >java.lang.Integer[]</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >java.lang.Integer[]</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >[Ljava.lang.Integer;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >[Ljava/lang/Integer;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >java/lang/Integer[]</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >Integer[] </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >package.Outer.Inner</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >package.Outer$Inner</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >package.Outer$Inner</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >Lpackage/Outer$Inner;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >package/Outer$Inner</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >Inner </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >package.Outer.Inner[]</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >package.Outer$Inner[]</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >[Lpackage.Outer$Inner;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >[Lpackage/Outer$Inner;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >package/Outer$Inner[]</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >Inner[] </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><em>n/a </em><em>for anonymous class</em></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >package.Outer$22</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >package.Outer$22</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >Lpackage/Outer$22;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >package/Outer$22</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><em>(empty string)</em> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><em>n/a </em><em>for
array of anon.&#XA0;class</em></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >package.Outer$22[]</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >[Lpackage.Outer$22;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >[Lpackage/Outer$22;</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >package/Outer$22[]</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >[] </td></tr>
</table>
</div><p>Java defines one format for the string representation of a method signature:</p><dl class="description"><dt class="dt-description"><a href="api/org/checkerframework/checker/signature/qual/MethodDescriptor.html"><span style="font-weight:bold"><span style="font-family:monospace">@MethodDescriptor</span></span></a></dt><dd class="dd-description">
A <em>method descriptor</em> (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3">JVMS &#XA7;4.3.3</a>) identifies a method&#X2019;s signature (its parameter and return
types), just as a field descriptor identifies a
type. The method descriptor for the method
<pre class="verbatim">    Object mymethod(int i, double d, Thread t)
</pre>is
<pre class="verbatim">    (IDLjava/lang/Thread;)Ljava/lang/Object;
</pre></dd></dl>
<!--TOC section id="signature-checks" What the Signature Checker checks-->
<h2 id="signature-checks" class="section">13.2&#XA0;&#XA0;What the Signature Checker checks</h2><!--SEC END --><p>Certain methods in the JDK, such as <span style="font-family:monospace">Class.forName</span>, are annotated
indicating the type they require. The Signature Checker ensures that
clients call them with the proper arguments. The Signature Checker does
not reason about string operations such as concatenation, substring,
parsing, etc.</p><p>
To run the Signature Checker, supply the
<span style="font-family:monospace">-processor org.checkerframework.checker.signature.SignatureChecker</span>
command-line option to javac.
</p><hr>
<!--TOC chapter id="guieffect-checker" GUI Effect Checker-->
<h1 id="guieffect-checker" class="chapter">Chapter&#XA0;14&#XA0;&#XA0;GUI Effect Checker</h1><!--SEC END --><p>One of the most prevalent GUI-related bugs is <em>invalid UI update</em> or <em>invalid thread access</em>: accessing the UI directly from a
background thread.</p><p>Most GUI frameworks (including Android, AWT, Swing, and SWT) create
a single distinguished thread &#X2014; the UI event thread
&#X2014; that handles all GUI events and updates.
To keep the interface responsive, any expensive computation should be
offloaded to <em>background threads</em> (also called <em>worker threads</em>).
If a background thread accesses a UI
element such as a JPanel (by calling a JPanel method or reading/writing a
field of JPanel),
the GUI framework raises an exception that terminates the program.
To fix the bug, the background thread should send a request to the
UI thread to perform the access on its behalf.</p><p>It is difficult for a programmer to remember which methods may be called on
which thread(s).
The GUI Effect Checker solves this problem.
The programmer annotates each method to indicate whether:
</p><ul class="itemize"><li class="li-itemize">
It accesses no UI elements (and may run on any thread);
such a method is said to have the &#X201C;safe effect&#X201D;.
</li><li class="li-itemize">It may access UI elements (and must run on the UI thread);
such a method is said to have the &#X201C;UI effect&#X201D;.
</li></ul><p>The GUI Effect Checker verifies these effects and statically enforces that UI methods are only
called from the correct thread. A method with the safe effect is prohibited from calling a method
with the UI effect.
</p><p>For example, the effect system can reason about when method calls must be dispatched to the UI
thread via a message such as <span style="font-family:monospace">Display.syncExec</span>.
</p><pre>
@SafeEffect
public void calledFromBackgroundThreads(JLabel l) {
    l.setText("Foo");       // Error: calling a @UIEffect method from a @SafeEffect method
    Display.syncExec(new @UI Runnable {
        @UIEffect // inferred by default
        public void run() {
            l.setText("Bar");  // OK: accessing JLabel from code run on the UI thread
        }
    });

}
</pre><p>The GUI Effect Checker&#X2019;s annotations fall into three categories:</p><ul class="itemize"><li class="li-itemize">
effect annotations on methods (Section&#XA0;<a href="#guieffect-annotations">14.1</a>),
</li><li class="li-itemize">class or package annotations controlling the default effect (Section&#XA0;<a href="#guieffect-defaults">14.4</a>), and
</li><li class="li-itemize"><em>effect-polymorphism</em>: code that works for both the safe effect and
the UI effect (Section&#XA0;<a href="#guieffect-polymorphism">14.5</a>).
</li></ul>
<!--TOC section id="guieffect-annotations" GUI effect annotations-->
<h2 id="guieffect-annotations" class="section">14.1&#XA0;&#XA0;GUI effect annotations</h2><!--SEC END --><p>There are two primary GUI effect annotations:
</p><ul class="itemize"><li class="li-itemize">
<a href="api/org/checkerframework/checker/guieffect/qual/SafeEffect.html"><span style="font-family:monospace">@SafeEffect</span></a>
is a method annotation marking code that must not
access UI objects.
</li><li class="li-itemize"><a href="api/org/checkerframework/checker/guieffect/qual/UIEffect.html"><span style="font-family:monospace">@UIEffect</span></a>
is a method annotation marking code that may access
UI objects. Most UI object methods (e.g., methods of <span style="font-family:monospace">JPanel</span>) are
annotated as <span style="font-family:monospace">@UIEffect</span>.
</li></ul><p><span style="font-family:monospace">@SafeEffect</span> is a sub-effect of <span style="font-family:monospace">@UIEffect</span>, in that it is always safe to
call a <span style="font-family:monospace">@SafeEffect</span> method anywhere it is permitted to call a
<span style="font-family:monospace">@UIEffect</span> method. We write this relationship as</p><div class="center"><span style="font-family:monospace">@SafeEffect</span> &#X227A; <span style="font-family:monospace">@UIEffect</span></div>
<!--TOC section id="guieffect-checks" What the GUI Effect Checker checks-->
<h2 id="guieffect-checks" class="section">14.2&#XA0;&#XA0;What the GUI Effect Checker checks</h2><!--SEC END --><p>The GUI Effect Checker ensures that only the UI thread accesses UI objects.
This prevents GUI errors such
as invalid UI update and invalid thread access.</p><p>The GUI Effect Checker issues errors in the following cases:</p><ul class="itemize"><li class="li-itemize">
A <span style="font-family:monospace">@UIEffect</span> method is invoked by a <span style="font-family:monospace">@SafeEffect</span> method.</li><li class="li-itemize">Method declarations violate subtyping restrictions: a supertype declares
a <span style="font-family:monospace">@SafeEffect</span> method, and a subtype annotates an overriding
version as <span style="font-family:monospace">@UIEffect</span>.</li></ul><p>Additionally, if a method implements or overrides a method in two
supertypes (two interfaces, or an interface and parent class), and those
supertypes give different effects for the methods, the GUI Effect Checker
issues a warning (not an error).</p>
<!--TOC section id="guieffect-running" Running the GUI Effect Checker-->
<h2 id="guieffect-running" class="section">14.3&#XA0;&#XA0;Running the GUI Effect Checker</h2><!--SEC END --><p>The GUI Effect Checker can be invoked by running the following command:
</p><pre class="verbatim">  javac -processor org.checkerframework.checker.guieffect.GuiEffectChecker MyFile.java ...
</pre>
<!--TOC section id="guieffect-defaults" Annotation defaults-->
<h2 id="guieffect-defaults" class="section">14.4&#XA0;&#XA0;Annotation defaults</h2><!--SEC END --><p>
The default method annotation is <span style="font-family:monospace">@SafeEffect</span>, since most code in most programs is not related
to the UI. This also means that typically, code that is unrelated to the UI need not be annotated
at all.</p><p>The GUI Effect Checker provides three primary ways to change the default method effect for a class
or package:
</p><ul class="itemize"><li class="li-itemize">
<a href="api/org/checkerframework/checker/guieffect/qual/UIType.html"><span style="font-family:monospace">@UIType</span></a>
is a class annotation that makes the effect for unannotated methods in that
class default to
<span style="font-family:monospace">@UIEffect</span>. (See also <span style="font-family:monospace">@UI</span> in Section&#XA0;<a href="#guieffect-polymorphism-using">14.5.2</a>.)
</li><li class="li-itemize"><a href="api/org/checkerframework/checker/guieffect/qual/UIPackage.html"><span style="font-family:monospace">@UIPackage</span></a>
is a <em>package</em> annotation, that makes the effect for unannotated
methods in that package default to <span style="font-family:monospace">@UIEffect</span>. It is not transitive; a package nested inside
a package marked <span style="font-family:monospace">@UIPackage</span> does not inherit the changed default.
</li><li class="li-itemize"><a href="api/org/checkerframework/checker/guieffect/qual/SafeType.html"><span style="font-family:monospace">@SafeType</span></a> is a class annotation that makes the effect for unannotated methods in that
class default to <span style="font-family:monospace">@SafeEffect</span>. Because <span style="font-family:monospace">@SafeEffect</span> is already the default
effect, <span style="font-family:monospace">@SafeType</span> is only useful for class types inside a package marked <span style="font-family:monospace">@UIPackage</span>.
</li></ul><p>There is one other place where the default annotation is not automatically <span style="font-family:monospace">@SafeEffect</span>:
anonymous inner classes. Since anonymous inner classes exist primarily for brevity, it would be
unfortunate to spoil that brevity with extra annotations. By default, an anonymous inner class
method that overrides or implements a method of the parent type inherits that method&#X2019;s effect.
For example, an anonymous inner class implementing an interface with method <span style="font-family:monospace">@UIEffect void
m()</span> need not explicitly annotate its implementation of <span style="font-family:monospace">m()</span>; the implementation will inherit
the parent&#X2019;s effect. Methods of the anonymous inner class that are not inherited from a parent type
follow the standard defaulting rules.</p>
<!--TOC section id="guieffect-polymorphism" Polymorphic effects-->
<h2 id="guieffect-polymorphism" class="section">14.5&#XA0;&#XA0;Polymorphic effects</h2><!--SEC END --><p>
Sometimes a type is reused for both UI-specific and background-thread work. A good example is the
<span style="font-family:monospace">Runnable</span> interface, which is used both for creating new background threads (in which case the
<span style="font-family:monospace">run()</span> method must have the <span style="font-family:monospace">@SafeEffect</span>) and for sending code to the UI thread to
execute (in which case the <span style="font-family:monospace">run()</span> method may have the
<span style="font-family:monospace">@UIEffect</span>). But the declaration of
<span style="font-family:monospace">Runnable.run()</span> may have only one effect annotation in the source code.
How do we reconcile these
conflicting use cases?</p><p><em>Effect-polymorphism</em> permits a type to be used for both UI and non-UI
purposes. It is similar to Java&#X2019;s generics in that you define, then use, the
effect-polymorphic type.
Recall that to <em>define</em> a generic type, you write a type parameter such as
<span style="font-family:monospace">&lt;T&gt;</span> and use it in the body of the type definition; for example,
<span style="font-family:monospace">class List&lt;T&gt; </span><span style="font-family:monospace">{</span><span style="font-family:monospace"> ...  T get() </span><span style="font-family:monospace">{</span><span style="font-family:monospace">...</span><span style="font-family:monospace">}</span><span style="font-family:monospace">  ...  </span><span style="font-family:monospace">}</span>.
To <em>instantiate</em> a generic type, you write its name along with a type
argument; for example, <span style="font-family:monospace">List&lt;Date&gt; myDates;</span>.</p>
<!--TOC subsection id="guieffect-polymorphism-defining" Defining an effect-polymorphic type-->
<h3 id="guieffect-polymorphism-defining" class="subsection">14.5.1&#XA0;&#XA0;Defining an effect-polymorphic type</h3><!--SEC END --><p>To declare that a class is effect-polymorphic, annotate its definition with
<a href="api/org/checkerframework/checker/guieffect/qual/PolyUIType.html"><span style="font-family:monospace">@PolyUIType</span></a>.
To use the effect variable in the class body, annotate a method with <a href="api/org/checkerframework/checker/guieffect/qual/PolyUIEffect.html"><span style="font-family:monospace">@PolyUIEffect</span></a>.
It is an error to use <span style="font-family:monospace">@PolyUIEffect</span> in a class that is not
effect-polymorphic.</p><p>Consider the following example:</p><pre>
@PolyUIType
public interface Runnable {
    @PolyUIEffect
    void run();
}
</pre><p>This declares that class <span style="font-family:monospace">Runnable</span> is parameterized over one
generic effect, and that when <span style="font-family:monospace">Runnable</span> is instantiated, the effect
argument will be used as the effect for the <span style="font-family:monospace">run</span> method.</p>
<!--TOC subsection id="guieffect-polymorphism-using" Using an effect-polymorphic type-->
<h3 id="guieffect-polymorphism-using" class="subsection">14.5.2&#XA0;&#XA0;Using an effect-polymorphic type</h3><!--SEC END --><p>To instantiate an effect-polymorphic type, write one of these three type
qualifiers before a use of the type:
</p><ul class="itemize"><li class="li-itemize">
<a href="api/org/checkerframework/checker/guieffect/qual/AlwaysSafe.html"><span style="font-family:monospace">@AlwaysSafe</span></a>
instantiates the type&#X2019;s effect to <span style="font-family:monospace">@SafeEffect</span>.
</li><li class="li-itemize"><a href="api/org/checkerframework/checker/guieffect/qual/UI.html"><span style="font-family:monospace">@UI</span></a>
instantiates the type&#X2019;s effect to <span style="font-family:monospace">@UIEffect</span>.
<em>Additionally</em>, it changes the
default method effect for the class to <span style="font-family:monospace">@UIEffect</span>.
</li><li class="li-itemize"><a href="api/org/checkerframework/checker/guieffect/qual/PolyUI.html"><span style="font-family:monospace">@PolyUI</span></a> instantiates the type&#X2019;s
effect to <span style="font-family:monospace">@PolyUIEffect</span> for the same instantiation as the current
(containing) class. For example, this is the qualifier of the receiver
<span style="font-family:monospace">this</span> inside a method of a <span style="font-family:monospace">@PolyUIType</span> class, which is how
one method of an effect-polymorphic class may call an effect-polymorphic
method of the same class.
</li></ul><p>As an example:</p><pre>
@AlwaysSafe Runnable s = ...;    s.run();    // s.run() is @SafeEffect
@PolyUI Runnable p = ...;        p.run();    // p.run() is @PolyUIEffect (context-dependent)
@UI Runnable u = ...;            u.run();    // u.run() is @UIEffect
</pre><p>It is an error to apply an effect instantiation qualifier to a type that is not effect-polymorphic.</p>
<!--TOC subsection id="guieffect-subclassing" Subclassing a specific instantiation of an effect-polymorphic type-->
<h3 id="guieffect-subclassing" class="subsection">14.5.3&#XA0;&#XA0;Subclassing a specific instantiation of an effect-polymorphic type</h3><!--SEC END --><p>
Sometimes you may wish to subclass a specific instantiation of an effect-polymorphic type, just as
you may extend <span style="font-family:monospace">List&lt;String&gt;</span>.</p><p>To do this, simply place the effect instantiation qualifier by the name of the type you are
defining, e.g.:</p><pre>
@UI
public class UIRunnable extends Runnable {...}
@AlwaysSafe
public class SafeRunnable extends Runnable {...}
</pre><p>
The GUI Effect Checker will automatically apply the qualifier to all classes and interfaces the class
being defined extends or implements. (This means you cannot write a class that is a subtype of a
<span style="font-family:monospace">@AlwaysSafe Foo</span> and a <span style="font-family:monospace">@UI Bar</span>, but this has not been a problem in our experience.)</p>
<!--TOC subsection id="guieffect-subtyping" Subtyping with polymorphic effects-->
<h3 id="guieffect-subtyping" class="subsection">14.5.4&#XA0;&#XA0;Subtyping with polymorphic effects</h3><!--SEC END --><p>
With three effect annotations, we must extend the static sub-effecting relationship:</p><div class="center"><span style="font-family:monospace">@SafeEffect</span> &#X227A; <span style="font-family:monospace">@PolyUIEffect</span> &#X227A; <span style="font-family:monospace">@UIEffect</span></div><p>This is the correct sub-effecting relation because it is always safe to
call a <span style="font-family:monospace">@SafeEffect</span>
method (whether from an effect-polymorphic method or a UI method), and a <span style="font-family:monospace">@UIEffect</span> method
may safely call any other method.
</p><p>This induces a subtyping hierarchy on type qualifiers:</p><div class="center"><span style="font-family:monospace">@AlwaysSafe</span> &#X227A; <span style="font-family:monospace">@PolyUI</span> &#X227A; <span style="font-family:monospace">@UI</span></div><p>This is sound because a method instantiated according to any qualifier will always be
safe to call in place of a method instantiated according to one of its super-qualifiers.
This allows clients to pass &#X201C;safer&#X201D; instances of some object type to a given method.</p>
<!--TOC section id="guieffect-references" References-->
<h2 id="guieffect-references" class="section">14.6&#XA0;&#XA0;References</h2><!--SEC END --><p>The ECOOP 2013 paper &#X201C;JavaUI: Effects for Controlling UI Object Access&#X201D;
includes some case
studies on the checker&#X2019;s efficacy, including descriptions of the relatively few false warnings
we encountered.
It also contains a more formal description of the effect system.
You can obtain the paper at: <br>
 <a href="http://homes.cs.washington.edu/~mernst/pubs/gui-thread-ecoop2013-abstract.html"><span style="font-family:monospace">http://homes.cs.washington.edu/~mernst/pubs/gui-thread-ecoop2013-abstract.html</span></a></p><hr>
<!--TOC chapter id="units-checker" Units Checker-->
<h1 id="units-checker" class="chapter">Chapter&#XA0;15&#XA0;&#XA0;Units Checker</h1><!--SEC END --><p>For many applications, it is important to use the correct units of
measurement for primitive types. For example, NASA&#X2019;s Mars Climate Orbiter
(cost: $327 million) was lost because of a discrepancy between use
of the metric unit Newtons and the imperial measure Pound-force.</p><p>The <em>Units Checker</em> ensures consistent usage of units.
For example, consider the following code:</p><pre>
@m int meters = 5 * UnitsTools.m;
@s int secs = 2 * UnitsTools.s;
@mPERs int speed = meters / secs;
</pre><p>Due to the annotations <span style="font-family:monospace">@m</span> and <span style="font-family:monospace">@s</span>, the variables <span style="font-family:monospace">meters</span> and <span style="font-family:monospace">secs</span> are guaranteed to contain
only values with meters and seconds as units of measurement.
Utility class <span style="font-family:monospace">UnitsTools</span> provides constants with which
unqualified integer are multiplied to get values of the corresponding unit.
The assignment of an unqualified value to <span style="font-family:monospace">meters</span>, as in
<span style="font-family:monospace">meters = 99</span>, will be flagged as an error by the Units Checker.</p><p>The division <span style="font-family:monospace">meters/secs</span> takes the types of the two operands
into account and determines that the result is of type
meters per second, signified by the <span style="font-family:monospace">@mPERs</span> qualifier.
We provide an extensible framework to define the result of operations
on units.</p>
<!--TOC section id="units-annotations" Units annotations-->
<h2 id="units-annotations" class="section">15.1&#XA0;&#XA0;Units annotations</h2><!--SEC END --><p>The checker currently supports three varieties of units annotations:
kind annotations (<a href="api/org/checkerframework/checker/units/qual/Length.html"><span style="font-family:monospace">@Length</span></a>,
<a href="api/org/checkerframework/checker/units/qual/Mass.html"><span style="font-family:monospace">@Mass</span></a>, &#X2026;),
the SI units (<a href="api/org/checkerframework/checker/units/qual/m.html"><span style="font-family:monospace">@m</span></a>, <a href="api/org/checkerframework/checker/units/qual/kg.html"><span style="font-family:monospace">@kg</span></a>, &#X2026;), and polymorphic annotations
(<a href="api/org/checkerframework/checker/units/qual/PolyUnit.html"><span style="font-family:monospace">@PolyUnit</span></a>).</p><p>Kind annotations can be used to declare what the expected unit of
measurement is, without fixing the particular unit used.
For example, one could write a method taking a <span style="font-family:monospace">@Length</span> value,
without specifying whether it will take meters or kilometers.
The following kind annotations are defined:</p><dl class="description"><dt class="dt-description">
<a href="api/org/checkerframework/checker/units/qual/Acceleration.html"><span style="font-weight:bold"><span style="font-family:monospace">@Acceleration</span></span></a></dt><dd class="dd-description"></dd><dt class="dt-description"><a href="api/org/checkerframework/checker/units/qual/Angle.html"><span style="font-weight:bold"><span style="font-family:monospace">@Angle</span></span></a></dt><dd class="dd-description"></dd><dt class="dt-description"><a href="api/org/checkerframework/checker/units/qual/Area.html"><span style="font-weight:bold"><span style="font-family:monospace">@Area</span></span></a></dt><dd class="dd-description"></dd><dt class="dt-description"><a href="api/org/checkerframework/checker/units/qual/Current.html"><span style="font-weight:bold"><span style="font-family:monospace">@Current</span></span></a></dt><dd class="dd-description"></dd><dt class="dt-description"><a href="api/org/checkerframework/checker/units/qual/Length.html"><span style="font-weight:bold"><span style="font-family:monospace">@Length</span></span></a></dt><dd class="dd-description"></dd><dt class="dt-description"><a href="api/org/checkerframework/checker/units/qual/Luminance.html"><span style="font-weight:bold"><span style="font-family:monospace">@Luminance</span></span></a></dt><dd class="dd-description"></dd><dt class="dt-description"><a href="api/org/checkerframework/checker/units/qual/Mass.html"><span style="font-weight:bold"><span style="font-family:monospace">@Mass</span></span></a></dt><dd class="dd-description"></dd><dt class="dt-description"><a href="api/org/checkerframework/checker/units/qual/Speed.html"><span style="font-weight:bold"><span style="font-family:monospace">@Speed</span></span></a></dt><dd class="dd-description"></dd><dt class="dt-description"><a href="api/org/checkerframework/checker/units/qual/Substance.html"><span style="font-weight:bold"><span style="font-family:monospace">@Substance</span></span></a></dt><dd class="dd-description"></dd><dt class="dt-description"><a href="api/org/checkerframework/checker/units/qual/Temperature.html"><span style="font-weight:bold"><span style="font-family:monospace">@Temperature</span></span></a></dt><dd class="dd-description"></dd><dt class="dt-description"><a href="api/org/checkerframework/checker/units/qual/Time.html"><span style="font-weight:bold"><span style="font-family:monospace">@Time</span></span></a></dt><dd class="dd-description">
</dd></dl><p>For each kind of unit, the corresponding SI unit of
measurement is defined:</p><ol class="enumerate" type=1><li class="li-enumerate">
For <span style="font-family:monospace">@Acceleration</span>:
Meter Per Second Square <a href="api/org/checkerframework/checker/units/qual/mPERs2.html"><span style="font-family:monospace">@mPERs2</span></a></li><li class="li-enumerate">For <span style="font-family:monospace">@Angle</span>:
Radians <a href="api/org/checkerframework/checker/units/qual/radians.html"><span style="font-family:monospace">@radians</span></a>,
and the derived unit
Degrees <a href="api/org/checkerframework/checker/units/qual/degrees.html"><span style="font-family:monospace">@degrees</span></a></li><li class="li-enumerate">For <span style="font-family:monospace">@Area</span>:
the derived units
square millimeters <a href="api/org/checkerframework/checker/units/qual/mm2.html"><span style="font-family:monospace">@mm2</span></a>,
square meters <a href="api/org/checkerframework/checker/units/qual/m2.html"><span style="font-family:monospace">@m2</span></a>, and
square kilometers <a href="api/org/checkerframework/checker/units/qual/km2.html"><span style="font-family:monospace">@km2</span></a></li><li class="li-enumerate">For <span style="font-family:monospace">@Current</span>:
Ampere <a href="api/org/checkerframework/checker/units/qual/A.html"><span style="font-family:monospace">@A</span></a></li><li class="li-enumerate">For <span style="font-family:monospace">@Length</span>:
Meters <a href="api/org/checkerframework/checker/units/qual/m.html"><span style="font-family:monospace">@m</span></a>
and the derived units
millimeters <a href="api/org/checkerframework/checker/units/qual/mm.html"><span style="font-family:monospace">@mm</span></a> and
kilometers <a href="api/org/checkerframework/checker/units/qual/km.html"><span style="font-family:monospace">@km</span></a></li><li class="li-enumerate">For <span style="font-family:monospace">@Luminance</span>:
Candela <a href="api/org/checkerframework/checker/units/qual/cd.html"><span style="font-family:monospace">@cd</span></a></li><li class="li-enumerate">For <span style="font-family:monospace">@Mass</span>:
kilograms <a href="api/org/checkerframework/checker/units/qual/kg.html"><span style="font-family:monospace">@kg</span></a>
and the derived unit
grams <a href="api/org/checkerframework/checker/units/qual/g.html"><span style="font-family:monospace">@g</span></a></li><li class="li-enumerate">For <span style="font-family:monospace">@Speed</span>:
meters per second <a href="api/org/checkerframework/checker/units/qual/mPERs.html"><span style="font-family:monospace">@mPERs</span></a> and
kilometers per hour <a href="api/org/checkerframework/checker/units/qual/kmPERh.html"><span style="font-family:monospace">@kmPERh</span></a></li><li class="li-enumerate">For <span style="font-family:monospace">@Substance</span>:
Mole <a href="api/org/checkerframework/checker/units/qual/mol.html"><span style="font-family:monospace">@mol</span></a></li><li class="li-enumerate">For <span style="font-family:monospace">@Temperature</span>:
Kelvin <a href="api/org/checkerframework/checker/units/qual/K.html"><span style="font-family:monospace">@K</span></a>
and the derived unit
Celsius <a href="api/org/checkerframework/checker/units/qual/C.html"><span style="font-family:monospace">@C</span></a></li><li class="li-enumerate">For <span style="font-family:monospace">@Time</span>:
seconds <a href="api/org/checkerframework/checker/units/qual/s.html"><span style="font-family:monospace">@s</span></a>
and the derived units
minutes <a href="api/org/checkerframework/checker/units/qual/min.html"><span style="font-family:monospace">@min</span></a> and
hours <a href="api/org/checkerframework/checker/units/qual/h.html"><span style="font-family:monospace">@h</span></a>
</li></ol><p>You may specify SI unit prefixes, using enumeration <a href="api/org/checkerframework/checker/units/qual/Prefix.html"><span style="font-family:monospace">Prefix</span></a>.
The basic SI units
(<span style="font-family:monospace">@s</span>, <span style="font-family:monospace">@m</span>, <span style="font-family:monospace">@g</span>, <span style="font-family:monospace">@A</span>, <span style="font-family:monospace">@K</span>,
<span style="font-family:monospace">@mol</span>, <span style="font-family:monospace">@cd</span>)
take an optional <span style="font-family:monospace">Prefix</span> enum as argument.
For example, to use nanoseconds as unit, you could use
<span style="font-family:monospace">@s(Prefix.nano)</span> as a unit type.
You can sometimes use a different annotation instead of a prefix;
for example, <span style="font-family:monospace">@mm</span> is equivalent to <span style="font-family:monospace">@m(Prefix.milli)</span>.</p><p>Class <span style="font-family:monospace">UnitsTools</span> contains a constant for each SI unit.
To create a value of the particular unit, multiply an unqualified
value with one of these constants.
By using static imports, this allows very natural notation; for
example, after statically importing <span style="font-family:monospace">UnitsTools.m</span>,
the expression <span style="font-family:monospace">5 * m</span> represents five meters.
As all these unit constants are public, static, and final with value
one, the compiler will optimize away these multiplications.</p><p>The polymorphic annotation <a href="api/org/checkerframework/checker/units/qual/PolyUnit.html"><span style="font-family:monospace">@PolyUnit</span></a>
enables you to write a method that takes an argument of any unit type and
returns a result of that same type. For more about polymorphic qualifiers,
see Section&#XA0;<a href="#qualifier-polymorphism">22.2</a>. For an example of it use, see
<span style="font-family:monospace">@PolyUnit</span>, see the
<a href="api/org/checkerframework/checker/units/qual/PolyUnit.html"><span style="font-family:monospace">@PolyUnit</span>
Javadoc</a>.</p>
<!--TOC section id="extending-units" Extending the Units Checker-->
<h2 id="extending-units" class="section">15.2&#XA0;&#XA0;Extending the Units Checker</h2><!--SEC END --><p>You can create new kind annotations and unit annotations that are specific
to the particular needs of your project. An easy way to do this is by
copying and adapting an existing annotation. (In addition, search for all
uses of the annotation&#X2019;s name throughout the Units Checker implementation,
to find other code to adapt; read on for details.)</p><p>Here is an example of a new unit annotation.</p><pre>
@Documented
@Retention(RetentionPolicy.RUNTIME)
@SubtypeOf( <span style="font-family:monospace">{</span> Time.class <span style="font-family:monospace">}</span> )
@UnitsMultiple(quantity=s.class, prefix=Prefix.nano)
@Target(ElementType.TYPE_USE, ElementType.TYPE_PARAMETER)
public @interface ns <span style="font-family:monospace">{</span><span style="font-family:monospace">}</span>
</pre><p>The <span style="font-family:monospace">@SubtypeOf</span> meta-annotation specifies that this annotation
introduces an additional unit of time.
The <span style="font-family:monospace">@UnitsMultiple</span> meta-annotation specifies that this annotation
should be a nano multiple of the basic unit <span style="font-family:monospace">@s</span>: <span style="font-family:monospace">@ns</span> and
<span style="font-family:monospace">@s(Prefix.nano)</span>
behave equivalently and interchangeably.
Most annotation definitions do not have a <span style="font-family:monospace">@UnitsMultiple</span> meta-annotation.</p><p>Note that all custom annotations must have the
<span style="font-family:monospace">@Target(</span><span style="font-family:monospace">ElementType.TYPE_USE</span><span style="font-family:monospace">)</span> meta-annotation. See section
<a href="#define-type-qualifiers">28.3.1</a>.</p><p>To take full advantage of the additional unit qualifier, you need to
do two additional steps.
(1)&#XA0;Provide constants that convert from unqualified types to types that use
the new unit.
See class <span style="font-family:monospace">UnitsTools</span> for examples (you will need to suppress a
checker warning in just those few locations).
(2)&#XA0;Put the new unit in relation to existing units.
Provide an
implementation of the <span style="font-family:monospace">UnitsRelations</span> interface as a
meta-annotation to one of the units.</p><p>See demonstration <span style="font-family:monospace">examples/units-extension/</span> for an example
extension that defines Hertz (hz) as scalar per second, and defines an
implementation of <span style="font-family:monospace">UnitsRelations</span> to enforce it.</p>
<!--TOC section id="units-checks" What the Units Checker checks-->
<h2 id="units-checks" class="section">15.3&#XA0;&#XA0;What the Units Checker checks</h2><!--SEC END --><p>The Units Checker ensures that unrelated types are not mixed.</p><p>All types with a particular unit annotation are
disjoint from all unannotated types, from all types with a different unit
annotation, and from all types with the same unit annotation but a
different prefix.</p><p>Subtyping between the units and the unit kinds is taken into account,
as is the <span style="font-family:monospace">@UnitsMultiple</span> meta-annotation.</p><p>Multiplying a scalar with a unit type results in the same unit type.</p><p>The division of a unit type by the same unit type
results in the unqualified type.</p><p>Multiplying or dividing different unit types, for which no unit
relation is known to the system, will result in a <span style="font-family:monospace">MixedUnits</span>
type, which is separate from all other units.
If you encounter a <span style="font-family:monospace">MixedUnits</span> annotation in an error message,
ensure that your operations are performed on correct units or refine
your <span style="font-family:monospace">UnitsRelations</span> implementation.</p><p>The Units Checker does <em>not</em> change units based on multiplication; for
example, if variable <span style="font-family:monospace">mass</span> has the type <span style="font-family:monospace">@kg double</span>, then <span style="font-family:monospace">mass *
1000</span> has that same type rather than the type <span style="font-family:monospace">@g double</span>. (The Units
Checker has no way of knowing whether you intended a conversion, or you
were computing the mass of 1000 items. You need to make all conversions
explicit in your code, and it&#X2019;s good style to minimize the number of
conversions.)</p>
<!--TOC section id="units-running" Running the Units Checker-->
<h2 id="units-running" class="section">15.4&#XA0;&#XA0;Running the Units Checker</h2><!--SEC END --><p>The Units Checker can be invoked by running the following commands.</p><ul class="itemize"><li class="li-itemize">
If your code uses only the SI units that are provided by the
framework, simply invoke the checker:<pre class="verbatim">  javac -processor org.checkerframework.checker.units.UnitsChecker MyFile.java ...
</pre></li><li class="li-itemize">If you define your own units, provide the fully-qualified class names of the
annotations through the <span style="font-family:monospace">-Aunits</span> option, using a comma-no-space-separated
notation:<pre>
  javac -Xbootclasspath/p:<span style="font-style:italic">/full/path/to/myProject/bin</span>:<span style="font-style:italic">/full/path/to/myLibrary/bin</span> <span style="font-family:monospace">\</span>
        -processor org.checkerframework.checker.units.UnitsChecker <span style="font-family:monospace">\</span>
        -Aunits=<span style="font-style:italic">myModule.qual.MyUnit</span>,<span style="font-style:italic">myModule.qual.MyOtherUnit</span> MyFile.java ...
</pre><p>The annotations listed in <span style="font-family:monospace">-Aunits</span> must be accessible to
the compiler during compilation in the classpath. In other words, they must
already be compiled (and, typically, be on the javac bootclasspath)
before you run the Units Checker with <span style="font-family:monospace">javac</span>. It
is not sufficient to supply their source files on the command line.</p></li><li class="li-itemize">You can also provide the fully-qualified paths to a set of directories
that contain units qualifiers through the <span style="font-family:monospace">-AunitsDirs</span> option,
using a colon-no-space-separated notation. For example:<pre>
  javac -Xbootclasspath/p:<span style="font-style:italic">/full/path/to/myProject/bin</span>:<span style="font-style:italic">/full/path/to/myLibrary/bin</span> <span style="font-family:monospace">\</span>
        -processor org.checkerframework.checker.units.UnitsChecker <span style="font-family:monospace">\</span>
        -AunitsDirs=<span style="font-style:italic">/full/path/to/myProject/bin</span>:<span style="font-style:italic">/full/path/to/myLibrary/bin</span> MyFile.java ...
</pre><p>Note that in these two examples, the compiled class file of the
<span style="font-family:monospace">myModule.qual.MyUnit</span> and <span style="font-family:monospace">myModule.qual.MyOtherUnit</span> annotations
must exist in either the <span style="font-family:monospace">myProject/bin</span> directory or the
<span style="font-family:monospace">myLibrary/bin</span> directory. The following placement of the class files
will work with the above commands:</p><pre>
  .../myProject/bin/myModule/qual/MyUnit.class
  .../myProject/bin/myModule/qual/MyOtherUnit.class
</pre><p>The two options can be used at the same time to provide groups of annotations
from directories, and individually named annotations.</p></li></ul><p>Also, see the example project in the <span style="font-family:monospace">checker/examples/units-extension</span> directory.</p>
<!--TOC section id="units-suppressing" Suppressing warnings-->
<h2 id="units-suppressing" class="section">15.5&#XA0;&#XA0;Suppressing warnings</h2><!--SEC END --><p>One example of when you need to suppress warnings is when you
initialize a variable with a unit type by a literal value.
To remove this warning message, it is best to introduce a
constant that represents the unit and to
add a <span style="font-family:monospace">@SuppressWarnings</span>
annotation to that constant.
For examples, see class <span style="font-family:monospace">UnitsTools</span>.</p>
<!--TOC section id="units-references" References-->
<h2 id="units-references" class="section">15.6&#XA0;&#XA0;References</h2><!--SEC END --><ul class="itemize"><li class="li-itemize">
The GNU Units tool provides a comprehensive list of units:<br>
 <a href="http://www.gnu.org/software/units/"><span style="font-family:monospace">http://www.gnu.org/software/units/</span></a></li><li class="li-itemize">The F# units of measurement system inspired some of our syntax:<br>
 <a href="https://en.wikibooks.org/wiki/F_Sharp_Programming/Units_of_Measure"><span style="font-family:monospace">https://en.wikibooks.org/wiki/F_Sharp_Programming/Units_of_Measure</span></a></li></ul><hr>
<!--TOC chapter id="constant-value-checker" Constant Value Checker-->
<h1 id="constant-value-checker" class="chapter">Chapter&#XA0;16&#XA0;&#XA0;Constant Value Checker</h1><!--SEC END --><p>The Constant Value Checker is a constant propagation analysis: for
each variable, it determines whether that variable&#X2019;s value can be
known at compile time.</p><p>There are two ways to run the Constant Value Checker.
</p><ul class="itemize"><li class="li-itemize">
Typically, it is automatically run by another type checker.
When using the Constant Value Checker as part of another checker, the
<span style="font-family:monospace">statically-executable.astub</span> file in the Constant Value Checker directory must
be passed as a stub file for the checker.
</li><li class="li-itemize">Alternately, you can run just the Constant Value Checker, by
supplying the following command-line options to javac:
<span style="font-family:monospace">-processor org.checkerframework.common.value.ValueChecker -Astubs=statically-executable.astub</span>
</li></ul>
<!--TOC section id="constant-value-checker-annotations" Annotations-->
<h2 id="constant-value-checker-annotations" class="section">16.1&#XA0;&#XA0;Annotations</h2><!--SEC END --><p>The Constant Value Checker uses type annotations to indicate the value of
an expression (Section&#XA0;<a href="#constant-value-checker-type-annotations">16.1.1</a>), and
it uses method annotations to indicate methods that the Constant Value
Checker can execute at compile time
(Section&#XA0;<a href="#staticallyexecutable-annotation">16.1.2</a>).</p>
<!--TOC subsection id="constant-value-checker-type-annotations" Type Annotations-->
<h3 id="constant-value-checker-type-annotations" class="subsection">16.1.1&#XA0;&#XA0;Type Annotations</h3><!--SEC END --><p>Typically, the programmer does not write any type annotations. Rather, the
type annotations are inferred by the Constant Value Checker.
The programmer is also permitted to write type annotations. This is only necessary in
locations where the Constant Value Checker does not infer annotations: on fields
and method signatures.</p><p>The type annotations are
<a href="api/org/checkerframework/common/value/qual/BoolVal.html"><span style="font-family:monospace">@BoolVal</span></a>,
<a href="api/org/checkerframework/common/value/qual/IntVal.html"><span style="font-family:monospace">@IntVal</span></a>,
<a href="api/org/checkerframework/common/value/qual/DoubleVal.html"><span style="font-family:monospace">@DoubleVal</span></a>, and
<a href="api/org/checkerframework/common/value/qual/StringVal.html"><span style="font-family:monospace">@StringVal</span></a>.</p><p>Each type annotation takes as an argument a set of values, and its meaning
is that at run time, the expression evaluates to one of the values. For
example, an expression of type
<a href="api/org/checkerframework/common/value/qual/StringVal.html"><span style="font-family:monospace">@StringVal</span></a><span style="font-family:monospace">("a", "b")</span> evaluates to
one of the values <span style="font-family:monospace">"a"</span>, <span style="font-family:monospace">"b"</span>, or <span style="font-family:monospace">null</span>.
The set is limited to 10 entries; if a variable
could be more than 10 different values, the Constant Value
Checker gives up and its type becomes
<a href="api/org/checkerframework/common/value/qual/UnknownVal.html"><span style="font-family:monospace">@UnknownVal</span></a> instead.</p><p>Figure&#XA0;<a href="#fig-value-hierarchy">16.1</a> shows the
subtyping relationship among the type annotations.
For two annotations of the same type, subtypes have a smaller set of
possible values, as also shown in the figure.
Because <span style="font-family:monospace">int</span> can be casted to <span style="font-family:monospace">double</span>, an <span style="font-family:monospace">@IntVal</span> annotation is a
subtype of a <span style="font-family:monospace">@DoubleVal</span> annotation with the same values.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<img src="value-subtyping.svg">
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 16.1: The type qualifier hierarchy of the Constant Value Checker
annotations. Qualifiers in gray are used
internally by the type system but should never be written by a
programmer. On the right are examples of additional subtyping
relationships that depend on the annotations&#X2019; arguments.</td></tr>
</table></div>
<a id="fig-value-hierarchy"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p>Figure&#XA0;<a href="#fig-value-multivalue">16.2</a> shows how the Constant Value Checker
infers type annotations (using flow-sensitive type qualifier refinement, Section&#XA0;<a href="#type-refinement">23.4</a>).</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<pre class="verbatim">public void foo(boolean b) {
    int i = 1;     // i has type:  @IntVal({1}) int
    if (b) {
        i = 2;     // i now has type:  @IntVal({2}) int
    }
                   // i now has type:  @IntVal({1,2}) int
    i = i + 1;     // i now has type:  @IntVal({2,3}) int
}
</pre><div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 16.2: The Constant Value Checker infers different types
for a variable on different lines of the program.</td></tr>
</table></div>
<a id="fig-value-multivalue"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote>
<!--TOC subsection id="staticallyexecutable-annotation" Compile-time execution of expressions-->
<h3 id="staticallyexecutable-annotation" class="subsection">16.1.2&#XA0;&#XA0;Compile-time execution of expressions</h3><!--SEC END --><p>Whenever all the operands of an expression are compile-time constants (that
is, their types have constant-value type annotations), the Constant Value
Checker attempts to execute the expression. This is independent of any
optimizations performed by the compiler and does not affect the code that
is generated.</p><p>The Constant Value Checker statically executes operators that do
not throw exceptions (e.g., <span style="font-family:monospace">+</span>, <span style="font-family:monospace">-</span>, <span style="font-family:monospace">&lt;&lt;</span>, <span style="font-family:monospace">!=</span>), and also
calls to methods annotated with
<a href="api/org/checkerframework/common/value/qual/StaticallyExecutable.html"><span style="font-family:monospace">@StaticallyExecutable</span></a>.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<pre class="verbatim">@StaticallyExecutable @Pure
public int foo(int a, int b) {
    return a + b;
}

public void bar() {
    int a = 5;          // a has type:  @IntVal({5}) int
    int b = 4;          // b has type:  @IntVal({4}) int
    int c = foo(a, b);  // c has type:  @IntVal({9}) int
}
</pre><div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 16.3: The
<a href="api/org/checkerframework/common/value/qual/StaticallyExecutable.html"><span style="font-family:monospace">@StaticallyExecutable</span></a> annotation enables
constant propagation through method calls.</td></tr>
</table></div>
<a id="fig-staticallyexecutable"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p>
A <span style="font-family:monospace">@StaticallyExecutable</span> method must
be <a href="api/org/checkerframework/dataflow/qual/Pure.html"><span style="font-family:monospace">@Pure</span></a> (side-effect-free and
deterministic).
Additionally, a <span style="font-family:monospace">@StaticallyExecutable</span> method and any method it calls must be on
the classpath for the compiler, because they are reflectively called at
compile-time to perform the constant value analysis. Any standard
library methods (such as those annotated as <span style="font-family:monospace">@StaticallyExecutable</span> in file
<span style="font-family:monospace">statically-executable.astub</span>) will already be on the
classpath.
</p><p>
To use <span style="font-family:monospace">@StaticallyExecutable</span> on methods in your own code, you should
first compile the code without the Constant Value Checker and then add
the location of the resulting <span style="font-family:monospace">.class</span> files to the
classpath. This can be done by either adding the destination path to
your environment variable <span style="font-family:monospace">CLASSPATH</span> or by passing the
argument <span style="font-family:monospace">-classpath path/to/class/files</span> to the call. The latter
would look similar to:
<span style="font-family:monospace">-processor org.checkerframework.common.value.ValueChecker
-Astubs=statically-executable.astub -classpath $CLASSPATH:$MY_PROJECT/build/</span>
</p>
<!--TOC section id="value-checker-warnings" Warnings-->
<h2 id="value-checker-warnings" class="section">16.2&#XA0;&#XA0;Warnings</h2><!--SEC END --><p>The Constant Value Checker issues a warning if it cannot load and run, at
compile time, a method marked as <span style="font-family:monospace">@StaticallyExecutable</span>. If it issues
such a warning, then the return value of the method will be <span style="font-family:monospace">@UnknownVal</span>
instead of being able to be resolved to a specific value annotation.
Some examples of these:</p><ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">[class.find.failed] Failed to find class named Test.</span><p>The checker could not find the class
specified for resolving a <span style="font-family:monospace">@StaticallyExecutable</span> method. Typically
this is caused by not providing the path of a class-file needed to
the classpath.</p></li><li class="li-itemize"><span style="font-family:monospace">[method.find.failed] Failed to find a method named foo with argument types [@IntVal(3) int]. Treating result as @UnknownVal</span><p>The checker could not find the method <span style="font-family:monospace">foo(int)</span> specified for
resolving a <span style="font-family:monospace">@StaticallyExecutable</span> method, but could find the
class. This is usually due to providing an outdated version of the
class-file that does not contain the <span style="font-family:monospace">@StaticallyExecutable</span>
method.</p></li><li class="li-itemize"><span style="font-family:monospace">[method.evaluation.exception] Failed to evaluate method public static int Test.foo(int) because it threw an exception: java.lang.ArithmeticException: / by zero. Treating result as @UnknownVal</span><p>An exception was thrown when trying to statically execute the
method. In this case it was a divide-by-zero exception. If the
arguments to the method each only had one value in their annotations
then this exception will always occur when the program is actually
run as well. If there are multiple possible values then the exception
might not be thrown on every execution, depending on the run-time values.</p></li></ul><p>There is one other situation in which the Constant Value Checker produces a
warning message:</p><ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">[too.many.values.given] Annotation ignored because the maximum
number of values tracked is 10.</span><p>The Constant Value Checker only tracks up to 10 possible values for an
expression. If you write an annotation with more values than will be
tracked, the annotation is ignored.</p></li></ul><hr>
<!--TOC chapter id="aliasing-checker" Aliasing Checker-->
<h1 id="aliasing-checker" class="chapter">Chapter&#XA0;17&#XA0;&#XA0;Aliasing Checker</h1><!--SEC END --><p>The Aliasing Checker identifies expressions that definitely have no
aliases.</p><p>Two expressions are aliased when they have the same non-primitive value;
that is, they are references to the identical Java object
in the heap. Another way of saying this is that two expressions,
<span style="font-style:italic">exprA</span> and <span style="font-style:italic">exprB</span>, are aliases of each other when
<span style="font-style:italic">exprA</span> <span style="font-family:monospace">==</span> <span style="font-style:italic">exprB</span> at the same program point.</p><p>Assigning to a variable or field typically creates an alias. For example,
after the statement <span style="font-family:monospace">a = b;</span>, the variables <span style="font-family:monospace">a</span> and <span style="font-family:monospace">b</span> are aliased.</p><p>Knowing that an expression is not aliased permits more accurate reasoning
about how side effects modify the expression&#X2019;s value.</p><p>To run the Aliasing Checker, supply the
<span style="font-family:monospace">-processor org.checkerframework.common.aliasing.AliasingChecker</span>
command-line option to javac.
However, a user rarely runs the Aliasing Checker directly.
This type system is mainly intended to be used together with other type systems.
For example, the SPARTA information flow type-checker
(Section&#XA0;<a href="#sparta-checker">21.8</a>) uses the Aliasing Checker to improve its
type refinement &#X2014; if an expression has no aliases, a more refined type
can often be inferred, otherwise the type-checker makes conservative
assumptions.</p>
<!--TOC section id="aliasing-annotations" Aliasing annotations-->
<h2 id="aliasing-annotations" class="section">17.1&#XA0;&#XA0;Aliasing annotations</h2><!--SEC END --><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<img src="aliasing.svg">
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 17.1: Type hierarchy for the Aliasing type system.</td></tr>
</table></div>
<a id="fig-aliasing-hierarchy"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p>There are two possible types for an expression:</p><dl class="description"><dt class="dt-description"><a href="api/org/checkerframework/common/aliasing/qual/MaybeAliased.html"><span style="font-weight:bold"><span style="font-family:monospace">@MaybeAliased</span></span></a></dt><dd class="dd-description">
is the type of an expression that might have an alias.
This is the default, so every unannotated type is
<span style="font-family:monospace">@MaybeAliased</span>. (This includes the type of <span style="font-family:monospace">null</span>.)</dd><dt class="dt-description"><a href="api/org/checkerframework/common/aliasing/qual/Unique.html"><span style="font-weight:bold"><span style="font-family:monospace">@Unique</span></span></a></dt><dd class="dd-description">
is the type of an expression that has no aliases.<p>The <span style="font-family:monospace">@Unique</span> annotation is only allowed at local variables, method
parameters, constructor results, and method returns.
A constructor&#X2019;s result should be annotated with <span style="font-family:monospace">@Unique</span> only if the
constructor&#X2019;s body does not creates an alias to the constructed object.</p></dd></dl><p>There are also two annotations, which are currently trusted instead of verified,
that can be used on formal parameters (including
the receiver parameter, <span style="font-family:monospace">this</span>):</p><dl class="description"><dt class="dt-description"><a href="api/org/checkerframework/common/aliasing/qual/NonLeaked.html"><span style="font-weight:bold"><span style="font-family:monospace">@NonLeaked</span></span></a></dt><dd class="dd-description">
identifies a formal parameter that is not leaked nor
returned by the method body.
For example, the formal parameter of the String copy constructor,
<span style="font-family:monospace">String(String s)</span>, is <span style="font-family:monospace">@NonLeaked</span> because the body of the method
only makes a copy of the parameter.</dd><dt class="dt-description"><a href="api/org/checkerframework/common/aliasing/qual/LeakedToResult.html"><span style="font-weight:bold"><span style="font-family:monospace">@LeakedToResult</span></span></a></dt><dd class="dd-description">
is used when the parameter may be returned, but it is not
otherwise leaked.
For example, the receiver parameter of <span style="font-family:monospace">StringBuffer.append(StringBuffer
this, String s)</span> is
<span style="font-family:monospace">@LeakedToResult</span>, because the method returns the updated receiver.</dd></dl>
<!--TOC section id="aliasing-leaking-contexts" Leaking contexts-->
<h2 id="aliasing-leaking-contexts" class="section">17.2&#XA0;&#XA0;Leaking contexts</h2><!--SEC END --><p>
This section lists the expressions that create aliases. These are also
called &#X201C;leaking contexts&#X201D;.</p><dl class="description"><dt class="dt-description">
<span style="font-weight:bold">Assignments</span></dt><dd class="dd-description">
After an assignment, the left-hand side and the right-hand side are
typically aliased. (The only counterexample is when the right-hand side is
a fresh expression; see Section&#XA0;<a href="#aliasing-refinement">17.4</a>.)<pre class="verbatim">  @Unique Object u = ...;
  Object o = u;                    // (not.unique) type-checking error!
</pre><p>If this example type-checked, then <span style="font-family:monospace">u</span> and <span style="font-family:monospace">o</span> would be aliased.
For this example to type-check, either the <span style="font-family:monospace">@Unique</span> annotation on the
type of <span style="font-family:monospace">u</span>, or the <span style="font-family:monospace">o = u;</span> assignment, must be removed.</p></dd><dt class="dt-description"><span style="font-weight:bold">Method calls and returns (pseudo-assignments)</span></dt><dd class="dd-description">
Passing an argument to a method is a &#X201C;pseudo-assignment&#X201D; because it effectively
assigns the argument to the formal parameter. Return statements are also
pseudo-assignments.
As with assignments, the left-hand side and right-hand side of
pseudo-assignments are typically aliased.<p>Here is an example for argument-passing:</p><pre class="verbatim">  void foo(Object o) { ... }

  @Unique Object u = ...;
  foo(u);   // type-checking error, because foo may create an alias of the passed argument
</pre><p>Passing a non-aliased
reference to a method does not necessarily create an alias.
However, the body of the method might create an alias or leak the
reference. Thus, the Aliasing Checker always treats a method call as
creating aliases for each argument unless the corresponding formal
parameter is marked as
@<a href="api/org/checkerframework/common/aliasing/qual/NonLeaked.html"><span style="font-family:monospace">@NonLeaked</span></a> or
@<a href="api/org/checkerframework/common/aliasing/qual/LeakedToResult.html"><span style="font-family:monospace">@LeakedToResult</span></a>.</p><p>Here is an example for a return statement:</p><pre class="verbatim">Object id(@Unique Object p) {
    return p;     // (not.unique) type-checking error!
}
</pre><p>If this code type-checked, then it would be possible for clients to write
code like this:</p><pre class="verbatim">@Unique Object u = ...;
Object o = id(u);
</pre><p>after which there is an alias to <span style="font-family:monospace">u</span> even though it is declared as <span style="font-family:monospace">@Unique</span>.</p><p>However, it is permitted to write</p><pre class="verbatim">Object id(@LeakedToResult Object p) {
    return p;
}
</pre><p>after which the following code type-checks:</p><pre class="verbatim">@Unique Object u = ...;
id(u);                   // method call result is not used
Object o1 = ...;
Object o2 = id(o1);      // argument is not @Unique
</pre></dd><dt class="dt-description"><span style="font-weight:bold">Throws</span></dt><dd class="dd-description">
A thrown exception can be captured by a catch block, which creates an
alias of the thrown exception.<pre class="verbatim">void foo() {
    @Unique Exception uex = new Exception();
    try {
        throw uex;    // (not.unique) type-checking error!
    } catch (Exception ex) {
        // uex and ex refer to the same object here.
    }
}
</pre></dd><dt class="dt-description"><span style="font-weight:bold">Array initializers</span></dt><dd class="dd-description"><p>Array initializers assign the elements in the initializers to corresponding
indexes in the array, therefore expressions in an array initializer are leaked.</p><pre class="verbatim">void foo() {
    @Unique Object o = new Object();
    Object[] ar = new Object[] { o };  // (not.unique) type-checking error!
    // The expressions o and ar[0] are now aliased.
}
</pre></dd></dl>
<!--TOC section id="aliasing-unique-restrictions" Restrictions on where <span style="font-family:monospace">@Unique</span> may be written-->
<h2 id="aliasing-unique-restrictions" class="section">17.3&#XA0;&#XA0;Restrictions on where <span style="font-family:monospace">@Unique</span> may be written</h2><!--SEC END --><p>The <span style="font-family:monospace">@Unique</span> qualifier may not be written on locations such as fields,
array elements, and type parameters.</p><p>As an example of why <span style="font-family:monospace">@Unique</span> may not be written on a field&#X2019;s type,
consider the following code:</p><pre class="verbatim">class MyClass {
    @Unique Object field;
    void foo() {
        MyClass myClass2 = this;
        // this.field is now an alias of myClass2.field
    }
}
</pre><p>That code must not type-check, because <span style="font-family:monospace">field</span> is declared as <span style="font-family:monospace">@Unique</span>
but has an alias. The Aliasing Checker solves the problem by forbidding
the <span style="font-family:monospace">@Unique</span> qualifier on subcomponents of a structure, such as fields.
Other solutions might be possible; they would be more complicated but would
permit more code to type-check.</p><p><span style="font-family:monospace">@Unique</span> may not be written on a type parameter for similar reasons.
The assignment</p><pre class="verbatim">List&lt;@Unique Object&gt; l1 = ...;
List&lt;@Unique Object&gt; l2 = l1;
</pre><p>must be forbidden because it would alias <span style="font-family:monospace">l1.get(0)</span> with <span style="font-family:monospace">l2.get(0)</span>
even though both have type <span style="font-family:monospace">@Unique</span>. The Aliasing Checker forbids this
code by rejecting the type <span style="font-family:monospace">List&lt;@Unique Object&gt;</span>.</p>
<!--TOC section id="aliasing-refinement" Aliasing type refinement-->
<h2 id="aliasing-refinement" class="section">17.4&#XA0;&#XA0;Aliasing type refinement</h2><!--SEC END --><p>Type refinement enables a type checker to treat an expression as a subtype
of its declared type. For example, even if you declare a local variable as
<span style="font-family:monospace">@MaybeAliased</span> (or don&#X2019;t write anything, since <span style="font-family:monospace">@MaybeAliased</span> is the
default), sometimes the Aliasing Checker can determine that it is actually
<span style="font-family:monospace">@Unique</span>.
For more details, see Section&#XA0;<a href="#type-refinement">23.4</a>.</p><p>The Aliasing Checker treats type refinement in the usual way,
except that at (pseudo-)assignments
the right-hand-side (RHS) may lose its type refinement, before the
left-hand-side (LHS) is type-refined.
The RHS always loses its type refinement (it is widened to
<span style="font-family:monospace">@MaybeAliased</span>, and its declared type must have been
<span style="font-family:monospace">@MaybeAliased</span>) except in the following cases:</p><ul class="itemize"><li class="li-itemize">
The RHS is a fresh expression &#X2014; an expression that returns a different value
each time it is evaluated. In practice, this is only method/constructor calls
with <span style="font-family:monospace">@Unique</span> return type. A variable/field is not fresh because it can
return the same value when evaluated twice.
</li><li class="li-itemize">The LHS is a <span style="font-family:monospace">@NonLeaked</span> formal parameter and the RHS is an argument in a
method call or constructor invocation.
</li><li class="li-itemize">The LHS is a <span style="font-family:monospace">@LeakedToResult</span> formal parameter, the RHS is an argument in
a method call or constructor invocation, and the method&#X2019;s return value is
discarded &#X2014; that is, the method call or constructor invocation is written
syntactically as a statement rather than as a part of a larger expression or
statement.
</li></ul><p>A consequence of the above rules is that most method calls are treated conservatively.
If a variable with declared type <span style="font-family:monospace">@MaybeAliased</span> has been refined
to <span style="font-family:monospace">@Unique</span> and is used as an argument of a method call, it usually loses its
<span style="font-family:monospace">@Unique</span> refined type.</p><p>Figure&#XA0;<a href="#fig-aliasing-refinement-example">17.2</a> gives an example of the Aliasing Checker&#X2019;s
type refinement rules.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<pre class="verbatim">// Annotations on the StringBuffer class, used in the examples below.
// class StringBuffer {
//  @Unique StringBuffer();
//  StringBuffer append(@LeakedToResult StringBuffer this, @NonLeaked String s);
// }

void foo() {
    StringBuffer sb = new StringBuffer();    // sb is refined to @Unique.

    StringBuffer sb2 = sb;                   // sb loses its refinement.
    // Both sb and sb2 have aliases and because of that have type @MaybeAliased.
}

void bar() {
    StringBuffer sb = new StringBuffer();     // sb is refined to @Unique.

    sb.append("someString");
    // sb stays @Unique, as no aliases are created.

    StringBuffer sb2 = sb.append("someString");
    // sb is leaked and becomes @MaybeAliased.

    // Both sb and sb2 have aliases and because of that have type @MaybeAliased.
}

</pre><div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 17.2: Example of Aliasing Checker&#X2019;s type refinement rules.</td></tr>
</table></div>
<a id="fig-aliasing-refinement-example"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><hr>
<!--TOC chapter id="linear-checker" Linear Checker for preventing aliasing-->
<h1 id="linear-checker" class="chapter">Chapter&#XA0;18&#XA0;&#XA0;Linear Checker for preventing aliasing</h1><!--SEC END --><p>The Linear Checker implements type-checking for a linear type system. A
linear type system prevents aliasing: there is only one (usable) reference
to a given object at any time. Once a reference appears on the right-hand
side of an assignment, it may not be used any more. The same rule applies
for pseudo-assignments such as procedure argument-passing (including as the
receiver) or return.</p><p>One way of thinking about this is that a reference can only be used once,
after which it is &#X201C;used up&#X201D;. This property is checked statically at
compile time. The single-use property only applies to use in an
assignment, which makes a new reference to the object; ordinary field
dereferencing does not use up a reference.</p><p>By forbidding aliasing, a linear type system can prevent problems such as
unexpected modification (by an alias), or ineffectual modification (after a
reference has already been passed to, and used by, other code).</p><p>To run the Linear Checker, supply the
<span style="font-family:monospace">-processor org.checkerframework.checker.linear.LinearChecker</span>
command-line option to javac.</p><p>Figure&#XA0;<a href="#fig-linear-example">18.1</a> gives an example of the Linear Checker&#X2019;s rules.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<pre class="verbatim">class Pair {
  Object a;
  Object b;
  public String toString() {
    return "&lt;" + String.valueOf(a) + "," + String.valueOf(b) + "&gt;";
  }
}

void print(@Linear Object arg) {
  System.out.println(arg);
}

@Linear Pair printAndReturn(@Linear Pair arg) {
  System.out.println(arg.a);
  System.out.println(arg.b);      // OK: field dereferencing does not use up the reference arg
  return arg;
}

@Linear Object m(Object o, @Linear Pair lp) {
  @Linear Object lo2 = o;         // ERROR: aliases may exist
  @Linear Pair lp3 = lp;
  @Linear Pair lp4 = lp;          // ERROR: reference lp was already used
  lp3.a;
  lp3.b;                          // OK: field dereferencing does not use up the reference
  print(lp3);
  print(lp3);                     // ERROR: reference lp3 was already used
  lp3.a;                          // ERROR: reference lp3 was already used
  @Linear Pair lp4 = new Pair(...);
  lp4.toString();
  lp4.toString();                 // ERROR: reference lp4 was already used
  lp4 = new Pair();               // OK to reassign to a used-up reference
  // If you need a value back after passing it to a procedure, that
  // procedure must return it to you.
  lp4 = printAndReturn(lp4);
  if (...) {
    print(lp4);
  }
  if (...) {
    return lp4;                   // ERROR: reference lp4 may have been used
  } else {
    return new Object();
  }
}
</pre><div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 18.1: Example of Linear Checker rules.</td></tr>
</table></div>
<a id="fig-linear-example"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote>
<!--TOC section id="linear-annotations" Linear annotations-->
<h2 id="linear-annotations" class="section">18.1&#XA0;&#XA0;Linear annotations</h2><!--SEC END --><p>The linear type system uses one user-visible annotation:
<a href="api/org/checkerframework/checker/linear/qual/Linear.html"><span style="font-family:monospace">@Linear</span></a>. The annotation indicates
a type for which each value may only have a single reference &#X2014;
equivalently, may only be used once on the right-hand side of an
assignment.</p><p>The full qualifier hierarchy for the linear type system includes three
types:
</p><ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">@UsedUp</span> is the type of references whose object has been assigned to
another reference. The reference may not be used in any way, including
having its fields dereferenced, being tested for equality with <span style="font-family:monospace">==</span>, or
being assigned to another reference. Users never need to write this
qualifier.
</li><li class="li-itemize"><span style="font-family:monospace">@Linear</span> is the type of references that have no aliases, and that may
be dereferenced at most once in the future. The type of <span style="font-family:monospace">new </span><span style="font-family:monospace"><em>T</em></span><span style="font-family:monospace">()</span> is
<span style="font-family:monospace">@Linear </span><span style="font-family:monospace"><em>T</em></span> (the analysis does not account for the slim
possibility that an alias to <span style="font-family:monospace">this</span> escapes the constructor).
</li><li class="li-itemize"><span style="font-family:monospace">@NonLinear</span> is the type of references that may be dereferenced, and
aliases made, as many times as desired. This is the default, so users only
need to write <span style="font-family:monospace">@NonLinear</span> if they change the default.
</li></ul><p><span style="font-family:monospace">@UsedUp</span> is a supertype of <span style="font-family:monospace">@NonLinear</span>, which is a
supertype of <span style="font-family:monospace">@Linear</span>.</p><p>This hierarchy makes an assignment like</p><pre class="verbatim">  @Linear Object l = new Object();
  @NonLinear Object nl = l;
  @NonLinear Object nl2 = nl;
</pre><p>legal. In other words, the fact that an object is referenced by a
<span style="font-family:monospace">@Linear</span> type means that there is only one usable reference to it <em>now</em>,
not that there will <em>never</em> be multiple usable references to it.
(The latter guarantee would be possible to enforce, but it is not what the
Linear Checker currently does.)</p>
<!--TOC section id="linear-limitations" Limitations-->
<h2 id="linear-limitations" class="section">18.2&#XA0;&#XA0;Limitations</h2><!--SEC END --><p>The <span style="font-family:monospace">@Linear</span> annotation is supported and checked only on method
parameters (including the receiver), return types, and local variables.
Supporting <span style="font-family:monospace">@Linear</span> on fields would require a sophisticated alias
analysis or type system, and is future work.
</p><p>No annotated libraries are provided for linear types. Most libraries would
not be able to use linear types in their purest form. For example, you
cannot put a linearly-typed object in a hash table, because hash table
insertion calls <span style="font-family:monospace">hashCode</span>; <span style="font-family:monospace">hashCode</span> uses up the reference and does not
return the object, even though it does not retain any pointers to the
object. For similar reasons, a collection of linearly-typed objects could
not be sorted or searched.</p><p>Our lightweight implementation is intended for use in the parts of your
program where errors relating to aliasing and object reuse are most likely.
You can use manual reasoning (and possibly an unchecked cast or warning
suppression) when objects enter or exit those portions of your program, or
when that portion of your program uses an unannotated library.</p><hr>
<!--TOC chapter id="reflection-resolution" Reflection resolution-->
<h1 id="reflection-resolution" class="chapter">Chapter&#XA0;19&#XA0;&#XA0;Reflection resolution</h1><!--SEC END --><p>A call to
<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-"><span style="font-family:monospace">Method.invoke</span></a>
might reflectively invoke any method, so the annotated JDK contains
conservative annotations for <span style="font-family:monospace">Method.invoke</span>.
These conservative library annotations often cause a checker to issue false
positive warnings when type-checking code that uses reflection.</p><p>If you supply the <span style="font-family:monospace">-AresolveReflection</span> command-line option, the Checker
Framework attempts to resolve reflection. At each call to <span style="font-family:monospace">Method.invoke</span>
or <span style="font-family:monospace">Constructor.newInstance</span>, the Checker Framework first soundly estimates
which methods might be invoked at runtime. When type-checking the call, the
Checker Framework uses a library annotation that indicates the parameter
and return types of the possibly-invoked methods.</p><p>If the estimate of invoked methods is small, these types are precise and
the checker issues fewer false positive warnings.
If the estimate of invoked methods is large, these types are no better than the
conservative library annotations.</p><p>Reflection resolution is disabled by default, because it increases the time
to type-check a program.
You should enable reflection resolution with the <span style="font-family:monospace">-AresolveReflection</span>
command-line option if, for some call site of <span style="font-family:monospace">Method.invoke</span> or
<span style="font-family:monospace">Constructor.newInstance</span> in your program:
</p><ol class="enumerate" type=1><li class="li-enumerate">
the conservative library annotations on <span style="font-family:monospace">Method.invoke</span> or
<span style="font-family:monospace">Constructor.newInstance</span> cause false positive warnings,
</li><li class="li-enumerate">the set of possibly-invoked methods or constructors can be known at
compile time,
and
</li><li class="li-enumerate">the reflectively invoked methods/constructors are on the class path at
compile time.
</li></ol><p>Reflection resolution does not change your source code or generated code.
In particular, it does not replace the <span style="font-family:monospace">Method.invoke</span> or
<span style="font-family:monospace">Constructor.newInstance</span> calls.</p><p>The command-line option <span style="font-family:monospace">-AresolveReflection=debug</span> outputs verbose information about the reflection resolution process.</p><p>Section&#XA0;<a href="#methodval-and-classval-checkers">19.1</a> first describes the MethodVal
and ClassVal Checkers, which reflection resolution uses internally. Then,
Section&#XA0;<a href="#reflection-examples">19.2</a> gives examples of reflection resolution.</p>
<!--TOC section id="methodval-and-classval-checkers" MethodVal and ClassVal Checkers-->
<h2 id="methodval-and-classval-checkers" class="section">19.1&#XA0;&#XA0;MethodVal and ClassVal Checkers</h2><!--SEC END --><p>The implementation of reflection resolution internally uses the ClassVal
Checker (Section&#XA0;<a href="#classval-checker">19.1.1</a>) and the MethodVal Checker
(Section&#XA0;<a href="#methodval-checker">19.1.2</a>). They are very similar to the Constant
Value Checker (Section&#XA0;<a href="#constant-value-checker">16</a>) in that their
annotations estimate the run-time value of an expression.</p><p>In some cases, you may need to write annotations such as <span style="font-family:monospace">@ClassVal</span>,
<span style="font-family:monospace">@MethodVal</span>, <span style="font-family:monospace">@StringVal</span> and <span style="font-family:monospace">@ArrayLen</span> (from the Constant Value Checker,
Section&#XA0;<a href="#constant-value-checker">16</a>) to aid in reflection resolution.
Often, though, these annotations can be inferred
(Section&#XA0;<a href="#methodval-and-classval-inference">19.1.3</a>).</p>
<!--TOC subsection id="classval-checker" ClassVal Checker-->
<h3 id="classval-checker" class="subsection">19.1.1&#XA0;&#XA0;ClassVal Checker</h3><!--SEC END --><p>The ClassVal Checker defines the following annotations:</p><dl class="description"><dt class="dt-description">
<a href="api/org/checkerframework/common/reflection/qual/ClassVal.html"><span style="font-weight:bold"><span style="font-family:monospace">@ClassVal</span></span></a><span style="font-weight:bold"><span style="font-family:monospace">(String[] value)</span></span></dt><dd class="dd-description">
If an expression has <span style="font-family:monospace">@ClassVal</span> type with a single argument,
then its exact run-time value is known at compile time.
For example, <span style="font-family:monospace">@ClassVal(</span><span style="font-family:monospace">"java.util.HashMap"</span><span style="font-family:monospace">)</span>
indicates that the <span style="font-family:monospace">Class</span> object represents the <span style="font-family:monospace">java.util.HashMap</span> class.<p>If multiple arguments are given, then the expression&#X2019;s run-time value is
known to be in that set.</p><p>The arguments are binary names
(<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-13.html#jls-13.1">JLS &#XA7;13.1</a>).</p></dd><dt class="dt-description"><a href="api/org/checkerframework/common/reflection/qual/ClassBound.html"><span style="font-weight:bold"><span style="font-family:monospace">@ClassBound</span></span></a><span style="font-weight:bold"><span style="font-family:monospace">(String[] value)</span></span></dt><dd class="dd-description">
If an expression has <span style="font-family:monospace">@ClassBound</span> type, then its run-time value is known
to be upper-bounded by that type.
For example,
<span style="font-family:monospace">@ClassBound(</span><span style="font-family:monospace">"java.util.HashMap"</span><span style="font-family:monospace">)</span> indicates that the <span style="font-family:monospace">Class</span> object
represents <span style="font-family:monospace">java.util.HashMap</span> or a subclass of it.<p>If multiple arguments are given, then the run-time value is equal to or a
subclass of some class in that set.</p><p>The arguments are binary names
(<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-13.html#jls-13.1">JLS &#XA7;13.1</a>).</p></dd><dt class="dt-description"><a href="api/org/checkerframework/common/reflection/qual/UnknownClass.html"><span style="font-weight:bold"><span style="font-family:monospace">@UnknownClass</span></span></a></dt><dd class="dd-description"> Indicates that there is no
compile-time information about the run-time value of the class &#X2014; or
that the Java type is not <span style="font-family:monospace">Class</span>.
This is the default qualifier, and it may not be written in source code.</dd><dt class="dt-description"><a href="api/org/checkerframework/common/reflection/qual/ClassValBottom.html"><span style="font-weight:bold"><span style="font-family:monospace">@ClassValBottom</span></span></a></dt><dd class="dd-description"> Type given to the <span style="font-family:monospace">null</span> literal.
It may not be written in source code.
</dd></dl><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<img src="classval.svg">
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 19.1: Partial type hierarchy for the ClassVal type system. The type qualifiers in gray (<span style="font-family:monospace">@UnknownClass</span>
and <span style="font-family:monospace">@ClassValBottom</span>) should never be written in source code; they are used internally by the type system.</td></tr>
</table></div>
<a id="fig-classval-hierarchy"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote>
<!--TOC subsubsection id="classval-subtyping-rules" Subtyping rules-->
<h4 id="classval-subtyping-rules" class="subsubsection">Subtyping rules</h4><!--SEC END --><p>
Figure&#XA0;<a href="#fig-classval-hierarchy">19.1</a> shows part of the type hierarchy of the
ClassVal type system.
<span style="font-family:monospace">@ClassVal(A)</span> is a subtype of <span style="font-family:monospace">@ClassVal(B)</span> if A is a subset of B.
<span style="font-family:monospace">@ClassBound(A)</span> is a subtype of <span style="font-family:monospace">@ClassBound(B)</span> if A is a subset of B.
<span style="font-family:monospace">@ClassVal(A)</span> is a subtype of <span style="font-family:monospace">@ClassBound(B)</span> if A is a subset of B.</p>
<!--TOC subsection id="methodval-checker" MethodVal Checker-->
<h3 id="methodval-checker" class="subsection">19.1.2&#XA0;&#XA0;MethodVal Checker</h3><!--SEC END --><p>The MethodVal Checker defines the following annotations:</p><dl class="description"><dt class="dt-description">
<a href="api/org/checkerframework/common/reflection/qual/MethodVal.html"><span style="font-weight:bold"><span style="font-family:monospace">@MethodVal</span></span></a><span style="font-weight:bold"><span style="font-family:monospace">(String[] className, String[] methodName, int[] params)</span></span></dt><dd class="dd-description">
Indicates that an expression of type <span style="font-family:monospace">Method</span> or <span style="font-family:monospace">Constructor</span> has a
run-time value in a given set. If the set has size <span style="font-style:italic">n</span>, then each of
<span style="font-family:monospace">@MethodVal</span>&#X2019;s arguments is an array of size <span style="font-style:italic">n</span>, and the <span style="font-style:italic">i</span>th method in the set is
represented by { className[i], methodName[i], params[i] }.
For a constructor, the method name is &#X201C;<span style="font-family:monospace">&lt;init&gt;</span>&#X201D;.
<p>Consider the following example:</p><pre class="verbatim">@MethodVal(className={"java.util.HashMap", "java.util.HashMap"},
           methodName={"containsKey", "containsValue"},
           params={1, 1})
</pre><p>This <span style="font-family:monospace">@MethodVal</span> annotation indicates that the <span style="font-family:monospace">Method</span>
is either <span style="font-family:monospace">HashMap.containsKey</span> with 1 formal parameter or
<span style="font-family:monospace">HashMap.containsValue</span> with 1 formal parameter.</p><p>The <span style="font-family:monospace">@MethodVal</span> type qualifier indicates the number of
parameters that the method takes, but not their type. This means that the
Checker Framework&#X2019;s reflection resolution cannot distinguish among
overloaded methods.</p></dd><dt class="dt-description"><a href="api/org/checkerframework/common/reflection/qual/UnknownMethod.html"><span style="font-weight:bold"><span style="font-family:monospace">@UnknownMethod</span></span></a></dt><dd class="dd-description"> Indicates that there is no
compile-time information about the run-time value of the method &#X2014; or
that the Java type is not <span style="font-family:monospace">Method</span> or <span style="font-family:monospace">Constructor</span>.
This is the default qualifier, and it may not be written in source code.</dd><dt class="dt-description"><a href="api/org/checkerframework/common/reflection/qual/MethodValBottom.html"><span style="font-weight:bold"><span style="font-family:monospace">@MethodValBottom</span></span></a></dt><dd class="dd-description"> Type given to the <span style="font-family:monospace">null</span> literal.
It may not be written in source code.
</dd></dl><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<img src="methodval.svg">
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 19.2: Partial type hierarchy for the MethodVal type system. The type qualifiers in gray (<span style="font-family:monospace">@UnknownMethod</span>
and <span style="font-family:monospace">@MethodValBottom</span>) should never be written in source code; they are used internally by the type system.</td></tr>
</table></div>
<a id="fig-methodval-hierarchy"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote>
<!--TOC subsubsection id="methodval-subtyping-rules" Subtyping rules-->
<h4 id="methodval-subtyping-rules" class="subsubsection">Subtyping rules</h4><!--SEC END --><p>
Figure&#XA0;<a href="#fig-methodval-hierarchy">19.2</a> shows part of the type hierarchy of the
MethodVal type system. <span style="font-family:monospace">@MethodVal(classname=CA, methodname=MA, params=PA)</span> is a subtype of
<span style="font-family:monospace">@MethodVal(classname=CB, methodname=MB, params=PB)</span> if</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">&#X2200;&#XA0;indexes&#XA0;<span style="font-style:italic">i</span>&#XA0;&#X2203;&#XA0;an index&#XA0;<span style="font-style:italic">j</span>:&#XA0;&#XA0;<span style="font-style:italic">CA</span>[<span style="font-style:italic">i</span>]&#XA0;=&#XA0;<span style="font-style:italic">CB</span>[<span style="font-style:italic">j</span>],&#XA0;<span style="font-style:italic">MA</span>[<span style="font-style:italic">i</span>]&#XA0;=&#XA0;<span style="font-style:italic">MA</span>[<span style="font-style:italic">j</span>],&#XA0;<span style="font-style:italic">and</span>&#XA0;<span style="font-style:italic">PA</span>[<span style="font-style:italic">i</span>]&#XA0;=&#XA0;<span style="font-style:italic">PB</span>[<span style="font-style:italic">j</span>]</td></tr>
</table><p>where CA, MA, and PA are lists of equal size and CB, MB, and PB are lists of equal size.</p>
<!--TOC subsection id="methodval-and-classval-inference" MethodVal and ClassVal inference-->
<h3 id="methodval-and-classval-inference" class="subsection">19.1.3&#XA0;&#XA0;MethodVal and ClassVal inference</h3><!--SEC END --><p>The developer rarely has to write <span style="font-family:monospace">@ClassVal</span> or <span style="font-family:monospace">@MethodVal</span>
annotations, because the Checker Framework infers them according to
Figure&#XA0;<a href="#fig%3Areflection-inference">19.3</a>. Most readers can skip this
section, which explains the inference rules.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div><div class="center">
<span style="font-size:small">
<img src="manual001.png" height="300" width="505">
</span>
</div><div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 19.3: <a id="fig:reflection-inference"></a>Example inference rules for @ClassVal, @ClassBound, and @MethodVal.
Additional rules exist for expressions with similar semantics but that call
methods with different names or signatures.
</td></tr>
</table></div><div class="center"><hr style="width:80%;height:2"></div></blockquote><p>The ClassVal Checker infers the exact class name (<span style="font-family:monospace">@ClassVal</span>) for a
<span style="font-family:monospace">Class</span> literal (<span style="font-family:monospace">C.class</span>), and for a static method call (e.g.,
<span style="font-family:monospace">Class.forName(arg)</span>, <span style="font-family:monospace">ClassLoader.loadClass(arg)</span>, ...) if the argument is a
statically computable expression. In contrast, it infers an upper bound
(<span style="font-family:monospace">@ClassBound</span>) for instance method calls (e.g., <span style="font-family:monospace">obj.getClass()</span>).</p><p>The MethodVal Checker infers <span style="font-family:monospace">@MethodVal</span> annotations for <span style="font-family:monospace">Method</span> and
<span style="font-family:monospace">Constructor</span> types that have been created using a method call to Java&#X2019;s Reflection
API:
</p><ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">Class.getMethod(String name, Class&lt;?&gt;...&#XA0;paramTypes)</span>
</li><li class="li-itemize"><span style="font-family:monospace">Class.getConstructor(Class&lt;?&gt;...&#XA0;paramTypes)</span>
</li></ul><p>Note that an exact class name is necessary to precisely resolve
reflectively-invoked constructors since a constructor in a subclass does not
override a constructor in its superclass. This means that the MethodVal Checker
does not infer a <span style="font-family:monospace">@MethodVal</span> annotation for <span style="font-family:monospace">Class.getConstructor</span> if the
type of that class is <span style="font-family:monospace">@ClassBound</span>. In contrast, either an exact class name or a bound
is adequate to resolve reflectively-invoked methods because of the subtyping
rules for overridden methods.</p>
<!--TOC section id="reflection-examples" Reflection resolution example-->
<h2 id="reflection-examples" class="section">19.2&#XA0;&#XA0;Reflection resolution example</h2><!--SEC END --><p>Consider the following example, in which the Nullness Checker employs
reflection resolution to avoid issuing a false positive warning.</p><pre class="verbatim">public class LocationInfo {
    @NonNull Location getCurrentLocation() {  ...  }
}

public class Example {
    LocationInfo privateLocation = ... ;
    String getCurrentCity() throws Exception {
        Method getCurrentLocationObj = LocationInfo.class.getMethod("getCurrentLocation");
        Location currentLocation = (Location) getCurrentLocationObj.invoke(privateLocation);
        return currentLocation.nameOfCity();
    }
}
</pre><p>When reflection resolution is not enabled, the Nullness Checker uses conservative
annotations on the <span style="font-family:monospace">Method.invoke</span> method signature:</p><p>&#XA0;&#XA0;<span style="font-family:monospace"><span style="font-weight:bold">@Nullable</span></span><span style="font-family:monospace"> Object invoke(</span><span style="font-family:monospace"><span style="font-weight:bold">@NonNull</span></span><span style="font-family:monospace"> Object recv, </span><span style="font-family:monospace"><span style="font-weight:bold">@NonNull</span></span><span style="font-family:monospace"> Object ... args)</span></p><p>This causes the Nullness Checker to issue the following warning even though
<span style="font-family:monospace">currentLocation</span> cannot be null.</p><pre class="verbatim">error: [dereference.of.nullable] dereference of possibly-null reference currentLocation
        return currentLocation.nameOfCity();
               ^
1 error
</pre><p>
When reflection resolution is enabled, the MethodVal Checker infers that the <span style="font-family:monospace">@MethodVal</span> annotation for <span style="font-family:monospace">getCurrentLocationObj</span> is:

</p><div class="center">
<span style="font-family:monospace">@MethodVal(className="LocationInfo", methodName="getCurrentLocation", params=0)</span>
</div><p>
Based on this <span style="font-family:monospace">@MethodVal</span> annotation, the reflection resolver determines that
the reflective method call represents a call to <span style="font-family:monospace">getCurrentLocation</span> in class
<span style="font-family:monospace">LocationInfo</span>.
The reflection resolver uses this information to provide the
following precise procedure summary to the Nullness Checker, for this
call site only:</p><p>&#XA0;&#XA0;<span style="font-family:monospace"><span style="font-weight:bold">@NonNull</span></span><span style="font-family:monospace"> Object invoke(</span><span style="font-family:monospace"><span style="font-weight:bold">@NonNull</span></span><span style="font-family:monospace"> Object recv, </span><span style="font-family:monospace"><span style="font-weight:bold">@Nullable</span></span><span style="font-family:monospace"> Object ... args)</span></p><p>Using this more precise signature, the Nullness Checker does not issue the false positive warning shown above.</p><hr>
<!--TOC chapter id="subtyping-checker" Subtyping Checker-->
<h1 id="subtyping-checker" class="chapter">Chapter&#XA0;20&#XA0;&#XA0;Subtyping Checker</h1><!--SEC END --><p>The Subtyping Checker enforces only subtyping rules. It operates over
annotations specified by a user on the command line. Thus, users can
create a simple type-checker without writing any code beyond definitions of
the type qualifier annotations.</p><p>The Subtyping Checker can accommodate all of the type system enhancements that
can be declaratively specified (see Chapter&#XA0;<a href="#writing-a-checker">28</a>).
This includes type introduction rules (implicit
annotations, e.g., literals are implicitly considered <a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a>) via
the <a href="api/org/checkerframework/framework/qual/ImplicitFor.html"><span style="font-family:monospace">@ImplicitFor</span></a> meta-annotation, and other features such as
flow-sensitive type qualifier inference (Section&#XA0;<a href="#type-refinement">23.4</a>) and
qualifier polymorphism (Section&#XA0;<a href="#qualifier-polymorphism">22.2</a>).</p><p>The Subtyping Checker is also useful to type system designers who wish to
experiment with a checker before writing code; the Subtyping Checker
demonstrates the functionality that a checker inherits from the Checker
Framework.</p><p>If you need typestate analysis, then you can extend a typestate checker,
much as you would extend the Subtyping Checker if you do not need typestate
analysis. For more details (including a definition of &#X201C;typestate&#X201D;), see
Chapter&#XA0;<a href="#typestate-checker">21.1</a>.
See Section&#XA0;<a href="#faq-typestate">30.6.2</a> for a simpler alternative.</p><p>For type systems that require special checks (e.g., warning about
dereferences of possibly-null values), you will need to write code and
extend the framework as discussed in Chapter&#XA0;<a href="#writing-a-checker">28</a>.</p>
<!--TOC section id="subtyping-using" Using the Subtyping Checker-->
<h2 id="subtyping-using" class="section">20.1&#XA0;&#XA0;Using the Subtyping Checker</h2><!--SEC END --><p>
The Subtyping Checker is used in the same way as other checkers (using the
<span style="font-family:monospace">-processor org.checkerframework.common.subtyping.SubtypingChecker</span> option; see Chapter&#XA0;<a href="#using-a-checker">2</a>), except that it
requires an additional annotation processor argument via the standard
&#X201C;<span style="font-family:monospace">-A</span>&#X201D; switch. One of the two following arguments must be used with the
Subtyping Checker:
</p><ul class="itemize"><li class="li-itemize">Provide the fully-qualified class name(s) of the annotation(s) in the custom
type system through the <span style="font-family:monospace">-Aquals</span> option, using a comma-no-space-separated
notation:<pre>
  javac -Xbootclasspath/p:<span style="font-style:italic">/full/path/to/myProject/bin</span>:<span style="font-style:italic">/full/path/to/myLibrary/bin</span> <span style="font-family:monospace">\</span>
        -processor org.checkerframework.common.subtyping.SubtypingChecker <span style="font-family:monospace">\</span>
        -Aquals=<span style="font-style:italic">myModule.qual.MyQual</span>,<span style="font-style:italic">myModule.qual.OtherQual</span> MyFile.java ...
</pre><p>The annotations listed in <span style="font-family:monospace">-Aquals</span> must be accessible to
the compiler during compilation in the classpath. In other words, they must
already be compiled (and, typically, be on the javac bootclasspath)
before you run the Subtyping Checker with <span style="font-family:monospace">javac</span>. It
is not sufficient to supply their source files on the command line.</p></li><li class="li-itemize">Provide the fully-qualified paths to a set of directories that contain the
annotations in the custom type system through the <span style="font-family:monospace">-AqualDirs</span> option,
using a colon-no-space-separated notation. For example:<pre>
  javac -Xbootclasspath/p:<span style="font-style:italic">/full/path/to/myProject/bin</span>:<span style="font-style:italic">/full/path/to/myLibrary/bin</span> <span style="font-family:monospace">\</span>
        -processor org.checkerframework.common.subtyping.SubtypingChecker <span style="font-family:monospace">\</span>
        -AqualDirs=<span style="font-style:italic">/full/path/to/myProject/bin</span>:<span style="font-style:italic">/full/path/to/myLibrary/bin</span> MyFile.java
</pre><p>Note that in these two examples, the compiled class file of the
<span style="font-family:monospace">myModule.qual.MyQual</span> and <span style="font-family:monospace">myModule.qual.OtherQual</span> annotations must exist
in either the <span style="font-family:monospace">myProject/bin</span> directory or the <span style="font-family:monospace">myLibrary/bin</span> directory. The
following placement of the class files will work with the above commands:</p><pre>
  .../myProject/bin/myModule/qual/MyQual.class
  .../myLibrary/bin/myModule/qual/OtherQual.class
</pre><p>The two options can be used at the same time to provide groups of annotations
from directories, and individually named annotations.</p></li></ul><p>To suppress a warning issued by the Subtyping Checker, use a
<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/SuppressWarnings.html"><span style="font-family:monospace">@SuppressWarnings</span></a>
annotation, with the argument being the unqualified, uncapitalized name of
any of the annotations passed to <span style="font-family:monospace">-Aquals</span>. This will suppress all
warnings, regardless of which of the annotations is involved in the
warning. (As a matter of style, you should choose one of the annotations
as your <span style="font-family:monospace">@SuppressWarnings</span> key and stick with it for that entire type
hierarchy.)</p>
<!--TOC section id="subtyping-example" Subtyping Checker example-->
<h2 id="subtyping-example" class="section">20.2&#XA0;&#XA0;Subtyping Checker example<a id="encrypted-example"></a></h2><!--SEC END --><p>Consider a hypothetical <span style="font-family:monospace">Encrypted</span> type qualifier, which denotes that the
representation of an object (such as a <span style="font-family:monospace">String</span>, <span style="font-family:monospace">CharSequence</span>, or
<span style="font-family:monospace">byte[]</span>) is encrypted. To use the Subtyping Checker for the <span style="font-family:monospace">Encrypted</span>
type system, follow three steps.</p><ol class="enumerate" type=1><li class="li-enumerate">
Define two annotations for the <span style="font-family:monospace">Encrypted</span> and <span style="font-family:monospace">PossiblyUnencrypted</span> qualifiers:<pre>
package <span style="font-style:italic">myModule</span>.qual;

import org.checkerframework.framework.qual.*;
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

/**
 * Denotes that the representation of an object is encrypted.
 */
@SubtypeOf(PossiblyUnencrypted.class)
@ImplicitFor(literal=  LiteralKind.NULL )
@DefaultFor(TypeUseLocation.LOWER_BOUND)
@Target(ElementType.TYPE_USE, ElementType.TYPE_PARAMETER)
public @interface Encrypted 
</pre><pre>
package <span style="font-style:italic">myModule</span>.qual;

import org.checkerframework.framework.qual.DefaultQualifierInHierarchy;
import org.checkerframework.framework.qual.SubtypeOf;
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

/**
 * Denotes that the representation of an object might not be encrypted.
 */
@DefaultQualifierInHierarchy
@SubtypeOf()
@Target(ElementType.TYPE_USE, ElementType.TYPE_PARAMETER)
public @interface PossiblyUnencrypted 
</pre><p>Note that all custom annotations must have the
<span style="font-family:monospace">@Target(</span><span style="font-family:monospace">ElementType.TYPE_USE</span><span style="font-family:monospace">)</span> meta-annotation. See section
<a href="#define-type-qualifiers">28.3.1</a>.</p><p>Don&#X2019;t forget to compile these classes:</p><pre class="verbatim">$ javac myModule/qual/Encrypted.java myModule/qual/PossiblyUnencrypted.java
</pre><p>The resulting <span style="font-family:monospace">.class</span> files should either be on your classpath, or on the
processor path (set via the <span style="font-family:monospace">-processorpath</span> command-line option to javac).</p></li><li class="li-enumerate">Write <span style="font-family:monospace">@Encrypted</span> annotations in your program (say, in file
<span style="font-family:monospace">YourProgram.java</span>):<pre>
import <span style="font-style:italic">myModule</span>.qual.Encrypted;

...

public @Encrypted String encrypt(String text) 
    // ...


// Only send encrypted data!
public void sendOverInternet(@Encrypted String msg) 
    // ...


void sendText() 
    // ...
    @Encrypted String ciphertext = encrypt(plaintext);
    sendOverInternet(ciphertext);
    // ...


void sendPassword() 
    String password = getUserPassword();
    sendOverInternet(password);

</pre><p>You may also need to add <span style="font-family:monospace">@SuppressWarnings</span> annotations to the
<span style="font-family:monospace">encrypt</span> and <span style="font-family:monospace">decrypt</span> methods. Analyzing them is beyond the
capability of any realistic type system.</p></li><li class="li-enumerate">Invoke the compiler with the Subtyping Checker, specifying the
<span style="font-family:monospace">@Encrypted</span> annotation using the <span style="font-family:monospace">-Aquals</span> option.
You should add the <span style="font-family:monospace">Encrypted</span> classfile to the processor classpath:<pre>
  javac -processorpath <span style="font-style:italic">myqualpath</span> -processor org.checkerframework.common.subtyping.SubtypingChecker 
        -Aquals=<span style="font-style:italic">myModule.qual.Encrypted</span>,<span style="font-style:italic">myModule.qual.PossiblyUnencrypted</span> YourProgram.java

YourProgram.java:42: incompatible types.
found   : @myModule.qual.PossiblyUnencrypted java.lang.String
required: @myModule.qual.Encrypted java.lang.String
    sendOverInternet(password);
                     ^
</pre></li><li class="li-enumerate">You can also provide the fully-qualified paths to a set of directories
that contain the qualifiers using the <span style="font-family:monospace">-AqualDirs</span> option, and add
the directories to the boot classpath, for example:<pre>
  javac -Xbootclasspath/p:<span style="font-style:italic">/full/path/to/myProject/bin</span>:<span style="font-style:italic">/full/path/to/myLibrary/bin</span> <span style="font-family:monospace">\</span>
        -processor org.checkerframework.common.subtyping.SubtypingChecker <span style="font-family:monospace">\</span>
        -AqualDirs=<span style="font-style:italic">/full/path/to/myProject/bin</span>:<span style="font-style:italic">/full/path/to/myLibrary/bin</span> YourProgram.java
</pre><p>
Note that in these two examples, the compiled class file of the
<span style="font-family:monospace">myModule.qual.Encrypted</span> and <span style="font-family:monospace">myModule.qual.PossiblyUnencrypted</span> annotations
must exist in either the <span style="font-family:monospace">myProject/bin</span> directory or the <span style="font-family:monospace">myLibrary/bin</span>
directory. The following placement of the class files will work with the above
commands:
</p><pre>
  .../myProject/bin/myModule/qual/Encrypted.class
  .../myProject/bin/myModule/qual/PossiblyUnencrypted.class
</pre></li></ol><p>Also, see the example project in the <span style="font-family:monospace">checker/examples/subtyping-extension</span> directory.</p><hr>
<!--TOC chapter id="third-party-checkers" Third-party checkers-->
<h1 id="third-party-checkers" class="chapter">Chapter&#XA0;21&#XA0;&#XA0;Third-party checkers<a id="external-checkers"></a></h1><!--SEC END --><p>The Checker Framework has been used to build other checkers that are not
distributed together with the framework. This chapter mentions just a few
of them. They are listed in chonological order; older ones appear first
and newer ones appear last.</p><p>They are externally-maintained, so if you have problems or questions, you
should contact their maintainers rather than the Checker Framework
maintainers.</p><p>If you want a reference to your checker included in this chapter,
send us a link and a short description.</p>
<!--TOC section id="typestate-checker" Typestate checkers-->
<h2 id="typestate-checker" class="section">21.1&#XA0;&#XA0;Typestate checkers</h2><!--SEC END --><p>In a regular type system, a variable has the same type throughout its
scope.
In a typestate system, a variable&#X2019;s type can change as operations
are performed on it.</p><p>The most common example of typestate is for a <span style="font-family:monospace">File</span> object. Assume a file
can be in two states, <span style="font-family:monospace">@Open</span> and <span style="font-family:monospace">@Closed</span>. Calling the <span style="font-family:monospace">close()</span> method
changes the file&#X2019;s state. Any subsequent attempt to read, write, or close
the file will lead to a run-time error. It would be better for the type
system to warn about such problems, or guarantee their absence, at compile
time.</p><p>Just as you can extend the Subtyping Checker to create a type-checker, you can
extend a typestate checker to create a type-checker that supports typestate
analysis. An extensible typestate analysis by Adam Warski that builds on
the Checker Framework is available at
<a href="http://www.warski.org/typestate.html"><span style="font-family:monospace">http://www.warski.org/typestate.html</span></a>.</p>
<!--TOC subsection id="typestate-vs-type-refinement" Comparison to flow-sensitive type refinement-->
<h3 id="typestate-vs-type-refinement" class="subsection">21.1.1&#XA0;&#XA0;Comparison to flow-sensitive type refinement</h3><!--SEC END --><p>The Checker Framework&#X2019;s flow-sensitive type refinement
(Section&#XA0;<a href="#type-refinement">23.4</a>) implements a form of typestate analysis.
For example, after code that tests a variable against null, the Nullness
Checker (Chapter&#XA0;<a href="#nullness-checker">3</a>) treats the variable&#X2019;s type as
<span style="font-family:monospace">@NonNull </span><span style="font-family:monospace"><em>T</em></span>, for some <span style="font-family:monospace"><em>T</em></span>.</p><p>For many type systems, flow-sensitive type refinement is sufficient. But
sometimes, you need full typestate analysis. This section compares the
two.
(Unused variables
(Section&#XA0;<a href="#unused-fields">23.6</a>)
also have similarities
with typestate analysis and can occasionally substitute for it. For
brevity, this discussion omits them.)</p><p>A typestate analysis is easier for a user to create or extend.
Flow-sensitive type refinement is built into the Checker Framework and is
optionally extended by each checker. Modifying the rules requires writing
Java code in your checker. By contrast, it is possible to write a simple
typestate checker declaratively, by writing annotations on the methods
(such as <span style="font-family:monospace">close()</span>) that change a reference&#X2019;s typestate.</p><p>A typestate analysis can change a reference&#X2019;s type to something that is not
consistent with its original definition. For example, suppose that a
programmer decides that the <span style="font-family:monospace">@Open</span> and <span style="font-family:monospace">@Closed</span> qualifiers are
incomparable &#X2014; neither is a subtype of the other. A typestate analysis
can specify that the <span style="font-family:monospace">close()</span> operation converts an <span style="font-family:monospace">@Open File</span> into a
<span style="font-family:monospace">@Closed File</span>. By contrast, flow-sensitive type refinement can only give
a new type that is a subtype of the declared type &#X2014; for flow-sensitive
type refinement to be effective, <span style="font-family:monospace">@Closed</span> would need to be a child of
<span style="font-family:monospace">@Open</span> in the qualifier hierarchy (and <span style="font-family:monospace">close()</span> would need to be
treated specially by the checker).</p>
<!--TOC section id="units-and-dimensions-checker" Units and dimensions checker-->
<h2 id="units-and-dimensions-checker" class="section">21.2&#XA0;&#XA0;Units and dimensions checker</h2><!--SEC END --><p>A checker for units and dimensions is available at
<a href="http://www.lexspoon.org/expannots/"><span style="font-family:monospace">http://www.lexspoon.org/expannots/</span></a>.</p><p>Unlike the Units Checker that is distributed with the Checker Framework
(see Section&#XA0;<a href="#units-checker">15</a>), this checker includes dynamic checks and
permits annotation arguments that are Java expressions. This added
flexibility, however, requires that you use a special version both of the
Checker Framework and of the javac compiler.</p>
<!--TOC section id="loci-thread-locality-checker" Thread locality checker-->
<h2 id="loci-thread-locality-checker" class="section">21.3&#XA0;&#XA0;Thread locality checker</h2><!--SEC END --><p>Loci&#XA0;[<a href="#WrigstadPMZV2009">WPM+09</a>], a checker for thread locality, is available at
<a href="http://www.it.uu.se/research/upmarc/loci/"><span style="font-family:monospace">http://www.it.uu.se/research/upmarc/loci/</span></a>.
Developer resources are available at the project page
<a href="http://java.net/projects/loci/"><span style="font-family:monospace">http://java.net/projects/loci/</span></a>.</p>
<!--TOC section id="safety-critical-java-checker" Safety-Critical Java checker-->
<h2 id="safety-critical-java-checker" class="section">21.4&#XA0;&#XA0;Safety-Critical Java checker</h2><!--SEC END --><p>A checker for Safety-Critical Java (SCJ, JSR 302)&#XA0;[<a href="#TangPJ2010">TPV10</a>] is available at
<a href="http://sss.cs.purdue.edu/projects/oscj/checker/checker.html"><span style="font-family:monospace">http://sss.cs.purdue.edu/projects/oscj/checker/checker.html</span></a>.
Developer resources are available at the project page
<a href="https://code.google.com/archive/p/scj-jsr302/"><span style="font-family:monospace">https://code.google.com/archive/p/scj-jsr302/</span></a>.</p>
<!--TOC section id="gut-checker" Generic Universe Types checker-->
<h2 id="gut-checker" class="section">21.5&#XA0;&#XA0;Generic Universe Types checker</h2><!--SEC END --><p>A checker for Generic Universe Types&#XA0;[<a href="#DietlEM2011">DEM11</a>], a lightweight ownership type
system, is available from
<a href="https://ece.uwaterloo.ca/~wdietl/ownership/"><span style="font-family:monospace">https://ece.uwaterloo.ca/~wdietl/ownership/</span></a>.</p>
<!--TOC section id="enerj-checker" EnerJ checker-->
<h2 id="enerj-checker" class="section">21.6&#XA0;&#XA0;EnerJ checker</h2><!--SEC END --><p>A checker for EnerJ&#XA0;[<a href="#SampsonDFGCG2011">SDF+11</a>], an extension to Java that exposes hardware faults
in a safe, principled manner to save energy with only
slight sacrifices to the quality of service, is available from
<a href="http://sampa.cs.washington.edu/research/approximation/enerj.html"><span style="font-family:monospace">http://sampa.cs.washington.edu/research/approximation/enerj.html</span></a>.</p>
<!--TOC section id="checklt-checker" CheckLT taint checker-->
<h2 id="checklt-checker" class="section">21.7&#XA0;&#XA0;CheckLT taint checker</h2><!--SEC END --><p>CheckLT uses taint tracking to detect illegal information flows, such as
unsanitized data that could result in a SQL injection attack.
CheckLT is available from <a href="http://checklt.github.io/"><span style="font-family:monospace">http://checklt.github.io/</span></a>.</p>
<!--TOC section id="sparta-checker" SPARTA information flow type-checker for Android-->
<h2 id="sparta-checker" class="section">21.8&#XA0;&#XA0;SPARTA information flow type-checker for Android</h2><!--SEC END --><p>SPARTA is a security toolset aimed at preventing malware from appearing in
an app store. SPARTA provides an information-flow type-checker that is
customized to Android but can also be applied to other domains.
The SPARTA toolset is available from
<a href="http://types.cs.washington.edu/sparta/"><span style="font-family:monospace">http://types.cs.washington.edu/sparta/</span></a>.
The paper
<a href="http://homes.cs.washington.edu/~mernst/pubs/infoflow-ccs2014.pdf">&#X201C;Collaborative
verification of information flow for a high-assurance app store&#X201D;</a>
appeared in CCS 2014.</p>
<!--TOC section id="igj-checker" Immutability checkers: IGJ, OIGJ, and Javari-->
<h2 id="igj-checker" class="section">21.9&#XA0;&#XA0;Immutability checkers: IGJ, OIGJ, and Javari<a id="javari-checker"></a></h2><!--SEC END --><p>Javari&#XA0;[<a href="#TschantzE2005">TE05</a>], IGJ&#XA0;[<a href="#ZibinPAAKE2007">ZPA+07</a>], and
OIGJ&#XA0;[<a href="#ZibinPLAE2010">ZPL+10</a>] are type systems that enforce immutability
constraints. They were distributed with the Checker Framework through
release 1.9.13, then removed because the implementations were not being
maintained. If you wish to use them, install
<a href="http://types.cs.washington.edu/checker-framework/releases/1.9.13/">Checker
Framework version 1.9.13</a>.</p><hr>
<!--TOC chapter id="polymorphism" Generics and polymorphism-->
<h1 id="polymorphism" class="chapter">Chapter&#XA0;22&#XA0;&#XA0;Generics and polymorphism</h1><!--SEC END --><p>This chapter describes support for Java generics (also known as
&#X201C;parametric polymorphism&#X201D;) and polymorphism over type qualifiers.</p><p>The Checker Framework currently supports two schemes for polymorphism over
type qualifiers.</p><p>Section&#XA0;<a href="#qualifier-polymorphism">22.2</a> describes the
original scheme, which uses method-based annotations that are meta-annotated
with <a href="api/org/checkerframework/framework/qual/PolymorphicQualifier.html"><span style="font-family:monospace">@PolymorphicQualifier</span></a>.</p><p>Section&#XA0;<a href="#qualifier-parameters">22.3</a> describes the qualifier parameters
scheme, in which qualifier parameters are specified for classes and methods
similarly to Java generics.
The qualifier
parameter scheme is more powerful than the original approach, but
it incurs a
50% performance penalty.
Currently, only the Tainting Checker
(Chapter&#XA0;<a href="#tainting-checker">8</a>) and the Regex Checker
(Chapter&#XA0;<a href="#regex-checker">9</a>) support qualifier parameters.</p>
<!--TOC section id="generics" Generics (parametric polymorphism or type polymorphism)-->
<h2 id="generics" class="section">22.1&#XA0;&#XA0;Generics (parametric polymorphism or type polymorphism)</h2><!--SEC END --><p>The Checker Framework fully supports
type-qualified Java generic types and methods (also known in the research literature as &#X201C;parametric
polymorphism&#X201D;).
When instantiating a generic type,
clients supply the qualifier along with the type argument, as in
<span style="font-family:monospace">List&lt;@NonNull String&gt;</span>.</p>
<!--TOC subsection id="generics-raw-types" Raw types-->
<h3 id="generics-raw-types" class="subsection">22.1.1&#XA0;&#XA0;Raw types</h3><!--SEC END --><p>Before running any pluggable type-checker, we recommend that you eliminate
raw types from your code (e.g., your code should use <span style="font-family:monospace">List&lt;...&gt;</span> as
opposed to <span style="font-family:monospace">List</span>).
Your code should compile without warnings when using the standard Java
compiler and the <span style="font-family:monospace">-Xlint:unchecked -Xlint:rawtypes</span> command-line options.
Using generics helps prevent type errors just as using a pluggable
type-checker does, and makes the Checker Framework&#X2019;s warnings easier to
understand.</p><p>If your code uses raw types, then the Checker Framework will do its best to
infer the Java type parameters and the type qualifiers. If it infers
imprecise types that lead to type-checking warnings elsewhere, then you have
two options. You can convert the raw types such as <span style="font-family:monospace">List</span> to
parameterized types such as <span style="font-family:monospace">List&lt;String&gt;</span>, or you can supply the
<span style="font-family:monospace">-AignoreRawTypeArguments</span> command-line option. That option causes the
Checker Framework to ignore all subtype tests for type arguments that
were inferred for a raw type.</p>
<!--TOC subsection id="generics-instantiation" Restricting instantiation of a generic class-->
<h3 id="generics-instantiation" class="subsection">22.1.2&#XA0;&#XA0;Restricting instantiation of a generic class</h3><!--SEC END --><p>When you define a generic class in Java, the <span style="font-family:monospace">extends</span> clause
of the generic type parameter (known as the &#X201C;upper bound&#X201D;) requires that
the corresponding type argument must be a subtype of the bound.
For example, given the definition
<code>class G&lt;T extends Number&gt; {...}</code>,
the upper bound is <span style="font-family:monospace">Number</span>
and a client can instantiate it as <span style="font-family:monospace">G&lt;Number&gt;</span> or <span style="font-family:monospace">G&lt;Integer&gt;</span>
but not <span style="font-family:monospace">G&lt;Date&gt;</span>.</p><p>You can write a type qualifier on the <span style="font-family:monospace">extends</span> clause to make the upper
bound a qualified type. For example, you can declare that a generic list class can hold only non-null values:
</p><pre class="verbatim">  class MyList&lt;T extends @NonNull Object&gt; {...}

  MyList&lt;@NonNull String&gt; m1;       // OK
  MyList&lt;@Nullable String&gt; m2;      // error
</pre><p>That is, in the above example, all
arguments that replace <span style="font-family:monospace">T</span> in <span style="font-family:monospace">MyList&lt;T&gt;</span> must be subtypes of
<span style="font-family:monospace">@NonNull Object</span>.</p><p>Conceptually, each generic type parameter has two bounds &#X2014; a lower bound
and an upper bound &#X2014; and at instantiation, the type argument must be
within the bounds. Java only allows you to specify the upper bound; the
lower bound is implicitly the bottom type <span style="font-family:monospace">void</span>. The Checker Framework
gives you more power: you can specify both an upper and lower bound for
type parameters and wildcards. For the upper bound, write a type qualifier
on the <span style="font-family:monospace">extends</span> clause, and for the lower bound, write a type qualifier
on the type variable.</p><pre class="verbatim">  class MyList&lt;@LowerBound T extends @UpperBound Object&gt; { ... }
</pre><p>For a concrete example, recall the type system of the Regex Checker (see
Figure&#XA0;<a href="#regex-checker">9</a>) in which
<span style="font-family:monospace">@Regex(0)</span> :&gt;
<span style="font-family:monospace">@Regex(1)</span> :&gt;
<span style="font-family:monospace">@Regex(2)</span> :&gt;
<span style="font-family:monospace">@Regex(3)</span> :&gt; &#X2026;.</p><pre class="verbatim">  class MyRegexes&lt;@Regex(5) T extends @Regex(1) String&gt; { ... }

  MyRegexes&lt;@Regex(0) String&gt; mu;   // error - @Regex(0) is not a subtype of @Regex(1)
  MyRegexes&lt;@Regex(1) String&gt; m1;   // OK
  MyRegexes&lt;@Regex(3) String&gt; m3;   // OK
  MyRegexes&lt;@Regex(5) String&gt; m5;   // OK
  MyRegexes&lt;@Regex(6) String&gt; m6;   // error - @Regex(6) is not a supertype of @Regex(5)
</pre><p>The above declaration states that the upper bound of the type variable
is <span style="font-family:monospace">@Regex(1) String</span> and the lower bound is <span style="font-family:monospace">@Regex(5) void</span>. That is,
arguments that replace <span style="font-family:monospace">T</span> in <span style="font-family:monospace">MyList&lt;T&gt;</span> must be subtypes of
<span style="font-family:monospace">@Regex(1) String</span> and supertypes of <span style="font-family:monospace">@Regex(5) void</span>.
Since <span style="font-family:monospace">void</span> cannot be used to instantiate a generic class, <span style="font-family:monospace">MyList</span> may
be instantiated with <span style="font-family:monospace">@Regex(1) String</span> through <span style="font-family:monospace">@Regex(5) String</span>.</p><p>To specify an exact bound, place the same annotation on both bounds. For example:</p><pre class="verbatim">  class MyListOfNonNulls&lt;@NonNull T extends @NonNull Object&gt; { ... }
  class MyListOfNullables&lt;@Nullable T extends @Nullable Object&gt; { ... }

  MyListOfNonNulls&lt;@NonNull Number&gt; v1;      // OK
  MyListOfNonNulls&lt;@Nullable Number&gt; v2;     // error
  MyListOfNullables&lt;@NonNull Number&gt; v4;     // error
  MyListOfNullables&lt;@Nullable Number&gt; v3;    // OK
</pre><p>It is an error if the lower bound is not a subtype of the upper bound.</p><pre class="verbatim">  class MyClass&lt;@Nullable T extends @NonNull Object&gt;  // error: @Nullable is not a supertype of @NonNull
</pre>
<!--TOC subsubsection id="generics-defaults" Defaults-->
<h4 id="generics-defaults" class="subsubsection">Defaults</h4><!--SEC END --><p>
If the <span style="font-family:monospace">extends</span> clause is omitted,
then the upper bound defaults to <span style="font-family:monospace">@</span><span style="font-family:monospace"><em>TopType</em></span><span style="font-family:monospace"> Object</span>.
If no type annotation is written on the type parameter name,
then the lower bound defaults to <span style="font-family:monospace">@</span><span style="font-family:monospace"><em>BottomType</em></span><span style="font-family:monospace"> void</span>.
If the <span style="font-family:monospace">extends</span> clause is written but contains no type qualifier,
then the normal defaulting rules apply to the type in the <span style="font-family:monospace">extends</span>
clause (see Section&#XA0;<a href="#climb-to-top">23.3.2</a>).</p><p>These rules mean that even though in Java the following two declarations
are equivalent:</p><pre class="verbatim">  class MyClass&lt;T&gt;
  class MyClass&lt;T extends Object&gt;
</pre><p>they may specify different type qualifiers on the upper bound, depending on
the type system&#X2019;s defaulting rules.
</p>
<!--TOC subsection id="type-variable-use" Type annotations on a use of a generic type variable-->
<h3 id="type-variable-use" class="subsection">22.1.3&#XA0;&#XA0;Type annotations on a use of a generic type variable</h3><!--SEC END --><p>A type annotation on a use of a generic type variable overrides/ignores any type
qualifier (in the same type hierarchy) on the corresponding actual type
argument. For example, suppose that <span style="font-family:monospace">T</span> is a formal type parameter.
Then using <span style="font-family:monospace">@Nullable T</span> within the scope of <span style="font-family:monospace">T</span> applies the type
qualifier <span style="font-family:monospace">@Nullable</span> to the (unqualified) Java type of <span style="font-family:monospace">T</span>.
This feature is only rarely used.</p><p>Here is an example of applying a type annotation to a generic type
variable:</p><pre class="verbatim">  class MyClass2&lt;T&gt; {
    ...
    @Nullable T myField = null;
    ...
  }
</pre><p>The type annotation does not restrict how <span style="font-family:monospace">MyClass2</span> may be
instantiated. In other words, both
<span style="font-family:monospace">MyClass2&lt;@NonNull String&gt;</span> and <span style="font-family:monospace">MyClass2&lt;@Nullable String&gt;</span> are
legal, and in both cases <span style="font-family:monospace">@Nullable T</span> means <span style="font-family:monospace">@Nullable String</span>.
In <span style="font-family:monospace">MyClass2&lt;@Interned String&gt;</span>,
<span style="font-family:monospace">@Nullable T</span> means <span style="font-family:monospace">@Nullable @Interned String</span>.</p>
<!--TOC subsection id="annotations-on-wildcards" Annotations on wildcards-->
<h3 id="annotations-on-wildcards" class="subsection">22.1.4&#XA0;&#XA0;Annotations on wildcards</h3><!--SEC END --><p>At an instantiation of a generic type, a Java wildcard indicates that some
constraints are known on the type argument, but the type argument is not known
exactly.
For example, you can indicate that the type parameter for variable <span style="font-family:monospace">ls</span> is
some unknown subtype of <span style="font-family:monospace">CharSequence</span>:</p><pre class="verbatim">  List&lt;? extends CharSequence&gt; ls;
  ls = new ArrayList&lt;String&gt;();      // OK
  ls = new ArrayList&lt;Integer&gt;();     // error: Integer is not a subtype of CharSequence
</pre><p>For more details about wildcards, see the
<a href="https://docs.oracle.com/javase/tutorial/java/generics/wildcards.html">Java
tutorial on wildcards</a> or
<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1">JLS
&#XA7;4.5.1</a>.</p><p>You can write a type annotation on the bound of a wildcard:</p><pre class="verbatim">  List&lt;? extends @NonNull CharSequence&gt; ls;
  ls = new ArrayList&lt;@NonNull String&gt;();    // OK
  ls = new ArrayList&lt;@Nullable String&gt;();   // error: @Nullable is not a subtype of @NonNull
</pre><p>Conceptually, every wildcard has two bounds &#X2014; an upper bound and a lower
bound. Java only permits you to write the upper bound (with
<span style="font-family:monospace">&lt;? extends SomeType&gt;</span>) or the lower bound (with <span style="font-family:monospace">&lt;? super
OtherType&gt;</span>), but not both; the unspecified bound is implicitly the
top type
<span style="font-family:monospace">Object</span> or the bottom type <span style="font-family:monospace">void</span>. The Checker Framework is more
flexible: it lets you simultaneously write annotations on both the top and
the bottom type. To annotate the implicit bound, write the type annotation
before the <span style="font-family:monospace">?</span>. For example:</p><pre class="verbatim">  List&lt;@LowerBound ? extends @UpperBound CharSequence&gt; lo;
  List&lt;@UpperBound ? super @NonNull Number&gt; ls;
</pre><p>For an unbounded wildcard (<span style="font-family:monospace">&lt;?&gt;</span>, with neither
bound specified), the annotation in front of a wildcard applies
to both bounds. The following three declarations are equivalent (except
that you cannot write the bottom type <span style="font-family:monospace">void</span>; note that
<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Void.html"><span style="font-family:monospace">Void</span></a> does not denote the bottom type):</p><pre class="verbatim">  List&lt;@NonNull ?&gt; lnn;
  List&lt;@NonNull ? extends @NonNull Object&gt; lnn;
  List&lt;@NonNull ? super @NonNull void&gt; lnn;
</pre><p>Note that the annotation in front of a type parameter always applies to its
lower bound, because type parameters can only be written with <span style="font-family:monospace">extends</span>
and never <span style="font-family:monospace">super</span>.</p><p>The defaulting rules for
wildcards also differ from those of type parameters (see
Section&#XA0;<a href="#inherited-wildcard-annotations">23.3.4</a>).</p>
<!--TOC subsection id="type-parameter-qualifier-examples" Examples of qualifiers on a type parameter-->
<h3 id="type-parameter-qualifier-examples" class="subsection">22.1.5&#XA0;&#XA0;Examples of qualifiers on a type parameter</h3><!--SEC END --><p>Recall that <span style="font-family:monospace">@Nullable </span><span style="font-family:monospace"><em>X</em></span> is a supertype of <span style="font-family:monospace">@NonNull </span><span style="font-family:monospace"><em>X</em></span>,
for any <em>X</em>.
Most of of the following types mean different things:</p><pre class="verbatim">  class MyList1&lt;@Nullable T&gt; { ... }
  class MyList1a&lt;@Nullable T extends @Nullable Object&gt; { ... } // same as MyList1
  class MyList2&lt;@NonNull T extends @NonNull Object&gt; { ... }
  class MyList2a&lt;T extends @NonNull Object&gt; { ... } // same as MyList2
  class MyList3&lt;T extends @Nullable Object&gt; { ... }
</pre><p><span style="font-family:monospace">MyList1</span> and <span style="font-family:monospace">MyList1a</span> must be instantiated with a nullable type.
The implementation of <span style="font-family:monospace">MyList1</span> must be able to consume (store) a null
value and produce (retrieve) a null value.</p><p><span style="font-family:monospace">MyList2</span> and <span style="font-family:monospace">MyList2a</span> must be instantiated with non-null type.
The implementation of <span style="font-family:monospace">MyList2</span> has to account for only non-null values &#X2014; it
does not have to account for consuming or producing null.</p><p><span style="font-family:monospace">MyList3</span> may be instantiated either way:
with a nullable type or a non-null type. The implementation of <span style="font-family:monospace">MyList3</span> must consider
that it may be instantiated either way &#X2014; flexible enough to support either
instantiation, yet rigorous enough to impose the correct constraints of the
specific instantiation. It must also itself comply with the constraints of
the potential instantiations.</p><p>One way to express the difference among <span style="font-family:monospace">MyList1</span>, <span style="font-family:monospace">MyList2</span>, and
<span style="font-family:monospace">MyList3</span> is by comparing what expressions are legal in the implementation
of the list &#X2014; that is, what expressions may appear in the ellipsis in the
declarations above, such as inside a method&#X2019;s body. Suppose each class
has, in the ellipsis, these declarations:</p><pre class="verbatim">  T t;
  @Nullable T nble;      // Section "Type annotations on a use of a generic type variable", below,
  @NonNull T nn;         // further explains the meaning of "@Nullable T" and "@NonNull T".
  void add(T arg) { }
  T get(int i) { }
</pre><p>Then the following expressions would be legal, inside a given
implementation &#X2014; that is, also within the ellipses.
(Compilable source code appears as file
<span style="font-family:monospace">checker-framework/checker/tests/nullness/generics/GenericsExample.java</span>.)</p><table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >MyList1</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >MyList2</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >MyList3 </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > t = null;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >OK</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >error</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >error </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > t = nble;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >OK</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >error</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >error </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > nble = null;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >OK</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >OK</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >OK </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > nn = null;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >error</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >error</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >error </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > t = this.get(0);</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >OK</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >OK</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >OK </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > nble = this.get(0);</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >OK</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >OK</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >OK </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > nn = this.get(0);</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >error</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >OK</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >error </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > this.add(t);</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >OK</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >OK</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >OK </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > this.add(nble);</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >OK</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >error</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >error </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" > this.add(nn);</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >OK</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >OK</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >OK </td></tr>
</table><p>The differences are more
significant when the qualifier hierarchy is more complicated than just
<span style="font-family:monospace">@Nullable</span> and <span style="font-family:monospace">@NonNull</span>.</p>
<!--TOC subsection id="covariant-type-parameters" Covariant type parameters-->
<h3 id="covariant-type-parameters" class="subsection">22.1.6&#XA0;&#XA0;Covariant type parameters</h3><!--SEC END --><p>Java types are <em>invariant</em> in their type parameter. This means that
<span style="font-family:monospace">A&lt;X&gt;</span> is a subtype of <span style="font-family:monospace">B&lt;Y&gt;</span> only if <span style="font-family:monospace">X</span> is identical to <span style="font-family:monospace">Y</span>. For
example, <span style="font-family:monospace">ArrayList&lt;Number&gt;</span> is a subtype of <span style="font-family:monospace">List&lt;Number&gt;</span>, but
neither <span style="font-family:monospace">ArrayList&lt;Integer&gt;</span> nor <span style="font-family:monospace">List&lt;Integer&gt;</span> is a subtype of
<span style="font-family:monospace">List&lt;Number&gt;</span>. (If they were, there would be a type hole in the Java
type system.) For the same reason, type parameter annotations are treated
invariantly. For example, <span style="font-family:monospace">List&lt;@Nullable String&gt;</span> is not a subtype
of <span style="font-family:monospace">List&lt;String&gt;</span>.</p><p>When a type parameter is used in a read-only way &#X2014; that is, when values
of that type are read but are never assigned &#X2014; then it is safe for the
type to be <em>covariant</em> in the type parameter. Use the <a href="api/org/checkerframework/checker/nullness/qual/Covariant.html"><span style="font-family:monospace">@Covariant</span></a> annotation to indicate
this.
When a type parameter is covariant, two instantiations of the class with
different type arguments have the same subtyping relationship as the type
arguments do.</p><p>For example, consider <span style="font-family:monospace">Iterator</span>. Its elements can be read but not
written, so <span style="font-family:monospace">Iterator&lt;@Nullable String&gt;</span> can be a subtype of
<span style="font-family:monospace">Iterator&lt;String&gt;</span> without introducing a hole in the type system.
Therefore, its type parameter is annotated with <span style="font-family:monospace">@Covariant</span>.
The first type parameter of <span style="font-family:monospace">Map.Entry</span> is also covariant.
Another example would be the type parameter of a hypothetical class
<span style="font-family:monospace">ImmutableList</span>.</p><p>The <span style="font-family:monospace">@Covariant</span> annotation is trusted but not checked.
If you incorrectly specify as covariant a type parameter that that can be
written (say, the class performs a
<span style="font-family:monospace">set</span> operation or some other mutation on an object of that type), then
you have created an unsoundness in the type system.
For example, it would be incorrect to annotate the type parameter of
<span style="font-family:monospace">ListIterator</span> as covariant, because <span style="font-family:monospace">ListIterator</span> supports a <span style="font-family:monospace">set</span>
operation.</p>
<!--TOC subsection id="infer-method-type-qualifiers" Method type argument inference and type qualifiers-->
<h3 id="infer-method-type-qualifiers" class="subsection">22.1.7&#XA0;&#XA0;Method type argument inference and type qualifiers</h3><!--SEC END --><p>Sometimes method type argument inference does not interact well with
type qualifiers. In such situations, you might need to provide
explicit method type arguments, for which the syntax is as follows:</p><pre>
    Collections.&lt;/*@MyTypeAnnotation*/ Object&gt;sort(l, c);
</pre><p>This uses Java&#X2019;s existing syntax for specifying a method call&#X2019;s type arguments.</p>
<!--TOC section id="qualifier-polymorphism" Qualifier polymorphism-->
<h2 id="qualifier-polymorphism" class="section">22.2&#XA0;&#XA0;Qualifier polymorphism</h2><!--SEC END --><p>This section describes the original Checker Framework scheme for qualifier
polymorphism. Section&#XA0;<a href="#qualifier-parameters">22.3</a> describes an alternative
scheme that uses qualifier parameters.
Most type systems still use the original scheme described in this section.</p><p>The Checker Framework supports type <em>qualifier</em> polymorphism for
methods, which permits a single method to have multiple different qualified
type signatures. This is similar to Java&#X2019;s generics, but is used in
situations where you cannot use Java generics. If you can use generics,
you typically do not need to use a polymorphic qualifier such as <span style="font-family:monospace">@PolyNull</span>.</p><p>To <em>use</em> a polymorphic qualifier, just write it on a type.
For example, you can write <span style="font-family:monospace">@PolyNull</span> anywhere in a method that you would write
<span style="font-family:monospace">@NonNull</span> or <span style="font-family:monospace">@Nullable</span>.
A polymorphic qualifier can be used in a method signature or body.
It may not be used on a class or field.</p><p>A method written using a polymorphic qualifier conceptually has multiple
versions, somewhat like the generics feature of Java or a template in C++.
In each version, each instance of the polymorphic qualifier has been
replaced by the same other qualifier from the hierarchy. See the examples
below in Section&#XA0;<a href="#qualifier-polymorphism-examples">22.2.1</a>.</p><p>The method body must type-check with all signatures. A method call is
type-correct if it type-checks under any one of the signatures. If a call
matches multiple signatures, then the compiler uses the most specific
matching signature for the purpose of type-checking. This is the same as
Java&#X2019;s rule for resolving overloaded methods.</p><p>To <em>define</em> a polymorphic qualifier, mark the definition with
<a href="api/org/checkerframework/framework/qual/PolymorphicQualifier.html"><span style="font-family:monospace">@PolymorphicQualifier</span></a>. For example,
<a href="api/org/checkerframework/checker/nullness/qual/PolyNull.html"><span style="font-family:monospace">@PolyNull</span></a> is a polymorphic type
qualifier for the Nullness type system:</p><pre class="verbatim">  @PolymorphicQualifier
  @Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})
  public @interface PolyNull { }
</pre><p>See Section&#XA0;<a href="#polyall">22.2.3</a> for a way you can sometimes avoid defining a new
polymorphic qualifier.</p>
<!--TOC subsection id="qualifier-polymorphism-examples" Examples of using polymorphic qualifiers-->
<h3 id="qualifier-polymorphism-examples" class="subsection">22.2.1&#XA0;&#XA0;Examples of using polymorphic qualifiers</h3><!--SEC END --><p>As an example of the use of <span style="font-family:monospace">@PolyNull</span>, method
<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#cast-java.lang.Object-"><span style="font-family:monospace">Class.cast</span></a>
returns null if and only if its argument is <span style="font-family:monospace">null</span>:</p><pre class="verbatim">  @PolyNull T cast(@PolyNull Object obj) { ... }
</pre><p>This is like writing:</p><pre class="verbatim">   @NonNull T cast( @NonNull Object obj) { ... }
  @Nullable T cast(@Nullable Object obj) { ... }
</pre><p>except that the latter is not legal Java, since it defines two
methods with the same Java signature.</p><p>As another example, consider</p><pre class="verbatim">  // Returns null if either argument is null.
  @PolyNull T max(@PolyNull T x, @PolyNull T y);
</pre><p>which is like writing</p><pre class="verbatim">   @NonNull T max( @NonNull T x,  @NonNull T y);
  @Nullable T max(@Nullable T x, @Nullable T y);
</pre><p>At a call site, the most specific applicable signature is selected.</p><p>Another way of thinking about which one of the two <span style="font-family:monospace">max</span> variants is
selected is that the nullness annotations of (the declared types of) both
arguments are <em>unified</em> to a type that is a supertype of both, also
known as the <em>least upper bound</em> or lub. If both
arguments are <span style="font-family:monospace">@NonNull</span>, their unification (lub) is <span style="font-family:monospace">@NonNull</span>, and the
method return type is <span style="font-family:monospace">@NonNull</span>. But if even one of the arguments is <span style="font-family:monospace">@Nullable</span>,
then the unification (lub) is <span style="font-family:monospace">@Nullable</span>, and so is the return type.</p>
<!--TOC subsection id="qualifier-polymorhism-vs-subtyping" Relationship to subtyping and generics-->
<h3 id="qualifier-polymorhism-vs-subtyping" class="subsection">22.2.2&#XA0;&#XA0;Relationship to subtyping and generics</h3><!--SEC END --><p>Qualifier polymorphism has the same purpose and plays the same role as
Java&#X2019;s generics. If a method is written using generics, it usually does
not need qualifier polymorphism. If you have legacy code that is not
written generically, and you cannot change it to use generics, then you can
use qualifier polymorphism to achieve a similar effect, with respect to
type qualifiers only. The base Java types are still treated non-generically.</p><p>Why not use ordinary subtyping to handle qualifier polymorphism?
Ordinarily, when you want a method to work on multiple types, you can just
use Java&#X2019;s subtyping. For example, the <span style="font-family:monospace">equals</span> method is declared to
take an <span style="font-family:monospace">Object</span> as its first formal parameter, but it can be called on a
<span style="font-family:monospace">String</span> or a <span style="font-family:monospace">Date</span> because those are subtypes of <span style="font-family:monospace">Object</span>.</p><p>In most cases, the same subtyping mechanism works with type qualifiers.
<span style="font-family:monospace">String</span> is a supertype of <span style="font-family:monospace">@Interned String</span>, so a method <span style="font-family:monospace">toUpperCase</span>
that is declared to take a <span style="font-family:monospace">String</span> parameter can also be called on a
<span style="font-family:monospace">@Interned String</span> argument.</p><p>You use qualifier polymorphism in the same cases when you would use Java&#X2019;s
generics. (If you can use Java&#X2019;s generics, then that is often better and
you don&#X2019;t also need to use qualifier polymorphism.) One example is when
you want a method to operate on collections with different types of
elements. Another example is when you want two different formal parameters
to be of the same type, without constraining them to be one specific type.</p>
<!--TOC subsection id="polyall" The <span style="font-family:monospace">@PolyAll</span> qualifier applies to every type system-->
<h3 id="polyall" class="subsection">22.2.3&#XA0;&#XA0;The <span style="font-family:monospace">@PolyAll</span> qualifier applies to every type system</h3><!--SEC END --><p>Each type system has its own polymorphic type qualifier.
If some method is qualifier-polymorphic over every type qualifier
hierarchy, then it is tedious, and leads to an explosion in the number of
type annotations, to place every <span style="font-family:monospace">@Poly*</span> qualifier on that method.</p><p>For example, a method that only performs <span style="font-family:monospace">==</span> on array elements will work
no matter what the array&#X2019;s element types are:</p><pre class="verbatim">  /**
   * Searches for the first occurrence of the given element in the array,
   * testing for equality using == (not the equals method).
   */
  public static int indexOfEq(@PolyAll Object[] a, @Nullable Object elt) {
    for (int i=0; i&lt;a.length; i++) {
      if (elt == a[i]) {
        return i;
      }
    }
    return -1;
  }
</pre>
<!--TOC subsection id="qualifier-polymorphism-multiple-instances" Multiple instances of polymorphic qualifiers (the index argument)-->
<h3 id="qualifier-polymorphism-multiple-instances" class="subsection">22.2.4&#XA0;&#XA0;Multiple instances of polymorphic qualifiers (the index argument)</h3><!--SEC END --><p>Each polymorphic qualifier such as <a href="api/org/checkerframework/framework/qual/PolyAll.html"><span style="font-family:monospace">@PolyAll</span></a>
takes an optional argument so that you can
specify multiple, independent polymorphic type qualifiers. For example,
this signature is overly restrictive:</p><pre class="verbatim">  /**
   * Returns true if the arrays are elementwise equal,
   * testing for equality using == (not the equals method).
   */
  public static int eltwiseEqualUsingEq(@PolyAll Object[] a, @PolyAll Object elt) {
    for (int i=0; i&lt;a.length; i++) {
      if (elt != a[i]) {
        return false;
      }
    }
    return true;
  }
</pre><p>That signature requires the element type annotation to be identical for the
two arguments. For example, it forbids this invocation:</p><pre class="verbatim">  @Nullable Object[] x;
   @NonNull Object   y;
  ... indexOf(x, y) ...
</pre><p>A better signature lets the two arrays&#X2019; element types vary independently:</p><pre class="verbatim">  public static int eltwiseEqualUsingEq(@PolyAll(1) Object[] a, @PolyAll(2) Object elt)
</pre><p>Note that in this case, the <span style="font-family:monospace">@Nullable</span> annotation on <span style="font-family:monospace">elt</span>&#X2019;s type is no
longer necessary, since it is subsumed by <span style="font-family:monospace">@PolyAll</span>.</p><p>The <span style="font-family:monospace">@PolyAll</span> annotation at a location <span style="font-style:italic">l</span> applies to every type
qualifier hierarchy for which no explicit qualifier is written at location
<span style="font-style:italic">l</span>. For example, a declaration like
<span style="font-family:monospace">@PolyAll @NonNull Object elt</span> is polymorphic over every type system
<em>except</em> the nullness type system, for which the type is fixed at
<span style="font-family:monospace">@NonNull</span>. That would be the proper declaration for <span style="font-family:monospace">elt</span> if the body
had used <span style="font-family:monospace">elt.equals(a[i])</span> instead of <span style="font-family:monospace">elt == a[i]</span>.</p><p>If a method signature contains only indexless versions of a polymorphic
qualifier such as <a href="api/org/checkerframework/framework/qual/PolyAll.html"><span style="font-family:monospace">@PolyAll</span></a> or
<a href="api/org/checkerframework/checker/nullness/qual/PolyNull.html"><span style="font-family:monospace">@PolyNull</span></a>, then all of them refer to
the same type as described in
Section&#XA0;<a href="#qualifier-polymorphism-multiple-qualifiers">22.2.5</a>. If any indexed
version appears, then every occurrence of the polymorphic qualifier without
an index is considered to use a fresh index. For example, the following
two declarations are equivalent (where <span style="font-family:monospace">@PA</span> means <span style="font-family:monospace">@PolyAll</span>, for brevity):</p><pre class="verbatim">  @PA(1) foo(@PA(1) Object a, @PA(2) Object b, @PA(2) Object c, @PA    Object d, @PA    Object e) {...}

  @PA(1) foo(@PA(1) Object a, @PA(2) Object b, @PA(2) Object c, @PA(3) Object d, @PA(4) Object e) {...}
</pre><p>As described in Section&#XA0;<a href="#qualifier-polymorphism-return-type">22.2.5</a>, the
qualifier on a return type must be the same as that on some formal parameter.
Therefore, the first of these declarations is legal because it is
equivalent to the second, but the third is illegal because it it
equivalent to the fourth.</p><pre class="verbatim">  @PolyAll    m1(@PolyAll    Object a, @PolyAll    Object b) { ... } // OK
  @PolyAll(1) m2(@PolyAll(1) Object a, @PolyAll(1) Object b) { ... } // OK (same as m1)

  @PolyAll    m3(@PolyAll    Object a, @PolyAll(1) Object b) { ... } // illegal
  @PolyAll(2) m4(@PolyAll(3) Object a, @PolyAll(1) Object b) { ... } // illegal (same as m3)
</pre>
<!--TOC subsection id="qualifier-polymorphism-multiple-qualifiers" Using multiple polymorphic qualifiers in a method signature-->
<h3 id="qualifier-polymorphism-multiple-qualifiers" class="subsection">22.2.5&#XA0;&#XA0;Using multiple polymorphic qualifiers in a method signature</h3><!--SEC END --><p>Usually, it does not make sense to write only a single instance of a polymorphic
qualifier in a method definition: if you write one instance of (say)
<span style="font-family:monospace">@PolyNull</span>, then you should use at least two.
(Section&#XA0;<a href="#qualifier-polymorphism-single-qualifier">22.2.6</a> describes some
exceptions to this rule: times when it makes sense to write a single
polymorphic qualifier in a signature.)</p><p>For example, there is no point to writing</p><pre class="verbatim">  void m(@PolyNull Object obj)
</pre><p>which expands to</p><pre class="verbatim">  void m(@NonNull Object obj)
  void m(@Nullable Object obj)
</pre><p>This is no different (in terms of which calls to the method will
type-check) than writing just</p><pre class="verbatim">  void m(@Nullable Object obj)
</pre><p>The main benefit of polymorphic qualifiers comes when one is used multiple times
in a method, since then each instance turns into the same type qualifier.
Most frequently, the polymorphic qualifier appears on at least one formal
parameter and also on the return type. It can also be useful to have
polymorphic qualifiers on (only) multiple formal parameters, especially if
the method side-effects one of its arguments.
For example, consider</p><pre class="verbatim">void moveBetweenStacks(Stack&lt;@PolyNull Object&gt; s1, Stack&lt;@PolyNull Object&gt; s2) {
  s1.push(s2.pop());
}
</pre><p>In this example, if it is acceptable to rewrite your code to use Java
generics, the code can be even cleaner:</p><pre class="verbatim">&lt;T&gt; void moveBetweenStacks(Stack&lt;T&gt; s1, Stack&lt;T&gt; s2) {
  s1.push(s2.pop());
}
</pre><p><a id="qualifier-polymorphism-return-type"></a>
It is permitted to write a polymorphic qualifier on a return type only if
that polymorphic qualifier appeared elsewhere in the signature, on some
formal parameter.</p>
<!--TOC subsection id="qualifier-polymorphism-single-qualifier" Using a single polymorphic qualifier in a method signature-->
<h3 id="qualifier-polymorphism-single-qualifier" class="subsection">22.2.6&#XA0;&#XA0;Using a single polymorphic qualifier in a method signature</h3><!--SEC END --><p>As explained in Section&#XA0;<a href="#qualifier-polymorphism-multiple-qualifiers">22.2.5</a>,
you will usually use a polymorphic qualifier
multiple times in a signature.
This section describes situations when it makes sense to write just one
polymorphic qualifier in a method signature.
Some of these situations can be avoided by writing a generic method,
but in legacy code it may not be possible for you to change a method to be
generic.</p>
<!--TOC subsubsection id="qualifier-polymorphism-element-types" Using a single polymorphic qualifier on an element type-->
<h4 id="qualifier-polymorphism-element-types" class="subsubsection">Using a single polymorphic qualifier on an element type</h4><!--SEC END --><p>It can make sense to use a polymorphic qualifier just once, on an array or
generic element type.</p><p>For example, consider a routine that returns the index, in an array, of a
given element:</p><pre class="verbatim">  public static int indexOf(@PolyNull Object[] a, @Nullable Object elt) { ... }
</pre><p>If <span style="font-family:monospace">@PolyNull</span> were replaced with either <span style="font-family:monospace">@Nullable</span> or <span style="font-family:monospace">@NonNull</span>, then
one of these safe client calls would be rejected:</p><pre class="verbatim">  @Nullable Object[] a1;
  @NonNull Object[] a2;

  indexOf(a1, someObject);
  indexOf(a2, someObject);
</pre><p>Of course, it would be better style to use a generic method, as in either
of these signatures:</p><pre class="verbatim"> public static &lt;T extends @Nullable Object&gt; int indexOf(T[] a, @Nullable Object elt) { ... }
 public static &lt;T extends @Nullable Object&gt; int indexOf(T[] a, T elt) { ... }
</pre><p>The examples in this section use arrays, but analogous examples exist that
use collections.</p>
<!--TOC subsubsection id="qualifier-polymorphism-top-type" Using a single polymorphic qualifier to indicate all arguments are legal-->
<h4 id="qualifier-polymorphism-top-type" class="subsubsection">Using a single polymorphic qualifier to indicate all arguments are legal</h4><!--SEC END --><p>A single <span style="font-family:monospace">@PolyAll</span> annotation can indicate that any possible value is
permitted to be passed. For example:</p><pre class="verbatim">  boolean eq(@PolyAll Object other) {
    return this == other;
  }
</pre><p>The <span style="font-family:monospace">@PolyAll</span> annotation applies to all type systems.
It would be infeasible to write the top qualifier for every possible type
system and to update this method&#X2019;s annotation whenever a new type system is
defined.</p><p>By contrast, a declaration of <span style="font-family:monospace">eq</span> without <span style="font-family:monospace">@PolyAll</span>:</p><pre class="verbatim">  boolean eq(Object other) {
    return this == other;
  }
</pre><p>would reject some calls, in type systems where the default type qualifier
applied to <span style="font-family:monospace">Object</span> is not the top type.</p><p>A related use of a single polymorphic qualifier is to override a generic
type. For example, the annotation on
<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo-T-"><span style="font-family:monospace">Comparable.compareTo()</span></a>
is:</p><pre class="verbatim">  public interface Comparable&lt;T extends @NonNull Object&gt; {
    @Pure int compareTo(@PolyAll @NonNull T a1);
  }
</pre><p>which indicates that, for every type system other than the nullness type
system, every value is permitted as an argument, regardless of how the
<span style="font-family:monospace">Comparable</span> type was instantiated. For example, this call is legal:</p><pre class="verbatim">  Comparable&lt;@MyBottom String&gt; cble;
  @MyTop String s;
  ...
  cble.compareTo(s);
</pre>
<!--TOC section id="qualifier-parameters" Qualifier parameters-->
<h2 id="qualifier-parameters" class="section">22.3&#XA0;&#XA0;Qualifier parameters</h2><!--SEC END --><p>This section describes qualifier parameters which is the new, more-powerful
qualifier polymorphism scheme.
As of the current release,
only the
Tainting Checker (Chapter&#XA0;<a href="#tainting-checker">8</a>) and the Regex Checker
(Chapter&#XA0;<a href="#regex-checker">9</a>) support qualifier parameters.
Other checkers with
qualifier polymorphism support use the original qualifier polymorphism scheme
(Section&#XA0;<a href="#qualifier-polymorphism">22.2</a>).</p><p>Qualifier parameters provide a way for you to re-use the same code with
different type qualifiers in a type-safe manner.</p><p>Qualifier parameters are very similar to Java generics, so if you understand the
benefits of generics and how to use them, you will find qualifier
parameters natural. Both mechanisms are
used on classes and methods where different instances of the class have different
types. Without generics or qualifier parameters, the types of the members would have
to be overly general, which would cause information loss, compiler
warnings, the need for casts, and potentially run-time errors.
Generics parameterize a class or method with
a <em>type</em>, so that a client can specialize the definition with a type
as in <span style="font-family:monospace">List&lt;Integer&gt;</span> or <span style="font-family:monospace">List&lt;String&gt;</span>. By contrast, qualifier parameters
enable a client to specialize the definition with just a <em>qualifier</em>
as in
<span style="font-family:monospace">MyClass&#X27EA;@Regex&#X27EB;</span> or <span style="font-family:monospace">MyClass&#X27EA;@NonNull&#X27EB;</span>.</p>
<!--TOC subsection id="qualifier-parameters-motivation" Motivation for qualifier parameters-->
<h3 id="qualifier-parameters-motivation" class="subsection">22.3.1&#XA0;&#XA0;Motivation for qualifier parameters</h3><!--SEC END --><p>As an example of a problem that qualifier parameters solve, consider
the <span style="font-family:monospace">Holder</span> class below. In some uses of <span style="font-family:monospace">Holder</span>, the <span style="font-family:monospace">item</span> field
holds a <span style="font-family:monospace">@Tainted String</span> value, and in other uses of <span style="font-family:monospace">Holder</span>, the <span style="font-family:monospace">item</span>
field holds an <span style="font-family:monospace">@Untainted String</span> value. The only declaration of <span style="font-family:monospace">item</span>
that is consistent with all uses is <span style="font-family:monospace">@Tainted String</span>, which is a supertype
of <span style="font-family:monospace">@Untainted String</span>. When an <span style="font-family:monospace">@Untainted String</span> value is put in a <span style="font-family:monospace">Holder</span>,
a cast is required when the value is later retrieved.</p><div style="font-size:small;">
<pre class="verbatim">    class Holder {
        @Tainted String item;   // overly-general declaration, leads to casts
    }

    // taintedHolder can hold both @Tainted and @Untainted values
    Holder taintedHolder = new Holder();
    taintedHolder.item = getTaintedValue();
    @Tainted String taintedString = taintedHolder.item;  // OK; type-checks with the Tainting Checker.

    // The programmer intends untaintedHolder to hold only @Untainted values
    Holder untaintedHolder = new Holder();
    untaintedHolder.item = getUntaintedValue();
    @Untainted String untaintedString = untaintedHolder.item;  // safe code, but Tainting Checker compile-time error.
    // A cast makes the assignment type-check, but casts are unsound and error-prone.
    String untaintedString = (@Untainted untaintedString) untaintedHolder.item;
    taintedHolder.item = getTaintedValue(); // An error that we would like the type sysetm to catch
</pre></div><p>Qualifier parameters allow sound type-checking of this
code without the use of casts.</p>
<!--TOC subsection id="qualifier-parameters-overview" Overview of qualifier parameters-->
<h3 id="qualifier-parameters-overview" class="subsection">22.3.2&#XA0;&#XA0;Overview of qualifier parameters</h3><!--SEC END --><p>These following examples add qualifier parameters to
<span style="font-family:monospace">Holder</span> from Section&#XA0;<a href="#qualifier-parameters-motivation">22.3.1</a> to allow
sound type-checking.</p><p>For clarity, this section displays qualifier parameters using an idealized
syntax using double angle brackets, <span style="font-family:monospace">&#X27EA;...&#X27EB;</span>.
Note that this is not the actual
syntax you will use in source code, which is described in
Section&#XA0;<a href="#qualifier-parameters-syntax">22.3.4</a>.</p><p>In the qualifier parameter system, a class can declared to have one or more
qualifier parameters. For example, a qualifier parameter can be added to the
<span style="font-family:monospace">Holder</span> class:</p><pre>
    class Holder &#X27EA;Q&#X27EB; {

    }
</pre><p>This declares that <span style="font-family:monospace">Holder</span> takes one qualifier parameter, named
<span style="font-family:monospace">Q</span>.</p><p><span style="font-family:monospace">Q</span> can be referenced inside the <span style="font-family:monospace">Holder</span> class. In the
following, <span style="font-family:monospace">item</span> will have the same qualifier that <span style="font-family:monospace">Holder</span> is
instantiated with:</p><pre>
    class Holder &#X27EA;Q&#X27EB; {
        @Q String item;
    }
</pre><p>References and instantiations of <span style="font-family:monospace">Holder</span> specify a qualifier
argument for its parameter <span style="font-family:monospace">Q</span>.</p><pre>
    Holder&#X27EA;Q=@Tainted&#X27EB; taintedHolder;
    Holder&#X27EA;Q=@Untainted&#X27EB; untaintedHolder;
</pre><p>Qualifier parameters permit instantiating a class with the appropriate type
qualifier rather than relying on an overly-general declaration. Therefore,
the following code type-checks without casts:</p><pre>
    Holder&#X27EA;Q=@Tainted&#X27EB; taintedHolder = new Holder&#X27EA;Q=@Tainted&#X27EB;();
    @Tainted String s = holder.item;

    Holder&#X27EA;Q=@Untainted&#X27EB; untaintedHolder = new Holder&#X27EA;Q=@Untainted&#X27EB;();
    @Untainted String s = holder.item;
</pre><p>Like generics, two classes with different
qualifier parameters have no subtyping relationship:</p><pre>
    taintedHolder = untaintedHolder;     // Error: not a subtype
    untaintedHolder = taintedHolder;     // Error: not a subtype
    Holder&#X27EA;Q=@Tainted&#X27EB; taintedHolder2;
    taintedHolder = taintedHolder2;      // OK:  the qualifier argument is the same for both
</pre>
<!--TOC subsection id="qualifier-parameters-wildcards" Qualifier parameter wildcards-->
<h3 id="qualifier-parameters-wildcards" class="subsection">22.3.3&#XA0;&#XA0;Qualifier parameter wildcards</h3><!--SEC END --><p>As with Java generics, wildcard extends and super bounds may
be used. Wildcards create a subtyping relationship between classes with
qualifier parameters. See the Java tutorial at
<a href="http://docs.oracle.com/javase/tutorial/java/generics/subtyping.html"><span style="font-family:monospace">http://docs.oracle.com/javase/tutorial/java/generics/subtyping.html</span></a>
for more information on subtyping relationships with wildcards.</p><pre>
    Holder&#X27EA;Q=@Tainted&#X27EB; holder;
    Holder&#X27EA;Q=? extends @Tainted&#X27EB; holderExtends;
    Holder&#X27EA;Q=? super @Tainted&#X27EB; holderSuper;

    holder = holderExtends;    // Error: not a subtype
    holderExtends = holder;    // OK

    holder = holderSuper;    // Error: not a subtype
    holderSuper = holder;    // OK
</pre><p>For soundness, when a class is parameterized with a
wildcard, members of a qualified class that use the parameter as their type
have restrictions on their use, just as in Java.
In particular, a member of a qualified class with an extends-bounded wildcard
may only be set to <span style="font-family:monospace">null</span>. A member of a qualified class with a
super-bounded wildcard will always have the top type when accessed.</p><pre>
    Holder&#X27EA;Q=? extends @Untainted&#X27EB; holderExtends;
    @Untainted String s1 = holderExtends.item;  // OK
    holderExtends.item = getTaintedString();    // Error: only null can be assigned to item

    Holder&#X27EA;Q=? super @Untainted&#X27EB; holderSuper;
    @Untainted String s2 = holderSuper.item;    // Error: item has the top type
    holderSuper.item = getUntaintedString();    // OK
</pre>
<!--TOC subsection id="qualifier-parameters-syntax" Syntax of qualifier parameters-->
<h3 id="qualifier-parameters-syntax" class="subsection">22.3.4&#XA0;&#XA0;Syntax of qualifier parameters</h3><!--SEC END --><p>The examples in
Sections&#XA0;<a href="#qualifier-parameters-overview">22.3.2</a>&#X2013;<a href="#qualifier-parameters-wildcards">22.3.3</a>
used double angle brackets, <span style="font-family:monospace">&#X27EA;...&#X27EB;</span>, for qualifier
parameter declarations and qualifier arguments.
In real source code, qualifier parameter declarations and uses, and qualifier
arguments, are specified via Java annotations.</p><ul class="itemize"><li class="li-itemize">
To declare a qualifier parameter, use <span style="font-family:monospace">@Class</span><span style="font-family:monospace"><em>Typesystem</em></span><span style="font-family:monospace">Param</span> or
<span style="font-family:monospace">@Method</span><span style="font-family:monospace"><em>Typesystem</em></span><span style="font-family:monospace">Param</span> and give a name for the parameter, as in
<span style="font-family:monospace">@ClassTaintingParam("main")</span>.
</li><li class="li-itemize">To use a qualifier parameter, write <span style="font-family:monospace">@Var</span> and indicate the parameter
being used, as in <span style="font-family:monospace">@Var(arg="main")</span>.
</li><li class="li-itemize">To supply a qualifier argument,
write the argument annotation (e.g., <span style="font-family:monospace">@Tainted</span>),
but supply a <span style="font-family:monospace">param</span> argument, as in <span style="font-family:monospace">@Tainted("main")</span> which means that
<span style="font-family:monospace">@Tainted</span> is the argument to the parameter named <span style="font-family:monospace">main</span>.
</li></ul><p>These annotations are summarized in
Figure&#XA0;<a href="#fig-qualifier-parameter-syntax">22.1</a>
and are more fully explained below.</p><p>Each type system that supports qualifier parameters has its own copy of
these annotations. The functionality of the annotations is the same, but since
a java file might be annotated with annotations for multiple type systems, i.e.
have annotations for both the Regex and the Tainting checker, there must be a
different copy of each annotation so that the Checker Framework can determine
the checker that an annotation belongs to.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div style="font-size:xx-small;">
<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >Generic Equivalent</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >Idealized Syntax</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >Actual Syntax </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >
Declare a class parameter</td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">class Holder&lt;T&gt; {} </span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">class Holder&#X27EA;Q&#X27EB; {} </span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">@ClassTaintingParam("Q") class Holder {}</span>
</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >
Declare a method parameter</td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">&lt;T&gt; void do() {} </span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">&#X27EA;V&#X27EB; void do() {} </span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">@MethodTaintingParam("V") void do() {}</span>
</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >
Instantiate (supply an argument)</td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">Holder&lt;String&gt;</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">Holder&#X27EA;Q=@Tainted&#X27EB;</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">@Tainted(param="Q") Holder</span>
</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >
Use a parameter</td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">&lt;T&gt; void do(T t) {} </span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">&#X27EA;V&#X27EB; void do(@V Object o) {} </span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">@MethodTaintingParam("V") void do(@Var(arg="V") Object o) {}</span>
</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >
Use a parameter as an argument</td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">&lt;T&gt; void do(List&lt;T&gt; t) {} </span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">&#X27EA;V&#X27EB; void do(Holder&#X27EA;Q=@V&#X27EB; h) {} </span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">@MethodTaintingParam("V") void do(@Var(arg="V" param="Q") Holder o) {}</span>
</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >
Instantiate without constraints</td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">Holder&lt;?&gt;</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">Holder&#X27EA;Q=?&#X27EB;</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">@Wild(param="Q") Holder</span>
</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >
Instantiate with upper bound</td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">Holder&lt;? extends Object&gt;</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">Holder&#X27EA;Q=? extends @Tainted&#X27EB;</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">@Tainted(param="Q", wildcard=Wildcard.EXTENDS) Holder</span>
</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >
Instantiate with lower bound</td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">Holder&lt;? super Object&gt;</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">Holder&#X27EA;Q=? super @Tainted&#X27EB;</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-family:monospace">@Tainted(param="Q", wildcard=Wildcard.SUPER) Holder</span>
</td></tr>
</table>
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 22.1: Comparison of the syntax of Java generics, the idealized syntax
used in
Sections&#XA0;<a href="#qualifier-parameters-overview">22.3.2</a>&#X2013;<a href="#qualifier-parameters-wildcards">22.3.3</a>,
and the actual syntax used in Java source code.
</td></tr>
</table></div>
<a id="fig-qualifier-parameter-syntax"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><dl class="description"><dt class="dt-description">
<a href="api/org/checkerframework/checker/tainting/qual/ClassTaintingParam.html"><span style="font-weight:bold"><span style="font-family:monospace">@ClassTaintingParam</span></span></a></dt><dd class="dd-description">
Declares a qualifier parameter for a class.<pre>

  // Equivalent to
  class Holder &#X27EA;Q&#X27EB; {

  }

  // Declare a parameter "main"
  @ClassTaintingParam("main")
  class Holder {

  }

  // The parameter "main" can now be set
  @Tainted(param="main") Holder h;

</pre></dd><dt class="dt-description"><a href="api/org/checkerframework/checker/tainting/qual/MethodTaintingParam.html"><span style="font-weight:bold"><span style="font-family:monospace">@MethodTaintingParam</span></span></a></dt><dd class="dd-description">
Declares a qualifier parameter for a method.<p>Qualifier arguments to a method are never specified explicitly; they are
inferred by the Checker Framework based on the parameters passed to the method
invocation. Unlike Java generics, there is no way to explicitly specify
method qualifier parameters on an invocation.</p><pre>

  class Util {

    // Declare a method parameter.
    @MethodTaintingParam("meth")
    public static @Var("meth") String id(@Var("meth") String in) {
        return in;
    }
  }

  // Qualifier arguments are inferred.
  @Untainted String untainted = Util.id(getUntaintedString());

</pre></dd><dt class="dt-description"><a href="api/org/checkerframework/checker/tainting/qual/Var.html"><span style="font-weight:bold"><span style="font-family:monospace">@Var</span></span></a></dt><dd class="dd-description"> Declares a use
of a qualifier parameter. The <span style="font-family:monospace">arg</span> field
specifies which qualifier parameter in the surrounding scope the type should
get its value from. For example:<pre>

  // Equivalent to
  class Holder &#X27EA;Q&#X27EB; {
    @Q String item;
  }

  // Declare a parameter
  @ClassTaintingParam ("main")
  class Holder {
    // item will have the qualifier that Holder is instantiated with
    @Var(arg="main") String item;
  }

  @Tainted(param="main") Holder h1 = new @Tainted(param="main") Holder();
  @Tainted String value1 = h1.item;

  @Untainted(param="main") Holder h2 = new @Untainted(param="main") Holder();
  @Untainted String value1 = h2.item;

</pre><p>The <span style="font-family:monospace">"param"</span> field specifies that the value of the
qualifier parameter specified by <span style="font-family:monospace">"arg"</span> should be used as the parameter
to another qualifier type. For example:</p><pre>

  // Equivalent to
  class Holder &#X27EA;Q&#X27EB; {
    @Q String item;
    Holder&#X27EA;Q=@Q&#X27EB; nestedHolder;
  }

  @ClassTaintingParam ("main")
  class Holder {
    // item will have the qualifier that Holder is instantiated with
    @Var(arg="main") String item;

    // nestedHolder will be instantiated with the same qualifier as the
    // enclosing "main" parameter
    @Var(arg="main", param="main") Holder nestedHolder;
  }

  @Tainted(param="main") Holder h1 = new @Tainted(param="main") Holder();
  @Tainted(param="main") Holder nestedHolder = h1;
  @Tainted String value1 = h1.nestedHolder.item;

  @Untainted(param="main") Holder h2 = new @Untainted(param="main") Holder();
  @Untainted(param="main") Holder nestedHolder2 = h2;
  @Untainted String value1 = h2.nestedHolder.item;

</pre></dd><dt class="dt-description"><a href="api/org/checkerframework/checker/tainting/qual/Tainted.html"><span style="font-weight:bold"><span style="font-family:monospace">@Tainted</span></span></a></dt><dd class="dd-description">
When the <span style="font-family:monospace">param</span> field is not set, this annotation behaves as described in
Chapter&#XA0;<a href="#tainting-checker">8</a> and indicates that the value is tainted.
For example:<pre>
  // The value should be considered tainted
  @Tainted String tainted  = getTaintedString();
</pre><p>When the <span style="font-family:monospace">param</span> param field is set, the annotation indicates that the
value of the <span style="font-family:monospace">@Tainted</span> qualifier should be used as the qualifier
argument to the class that it annotates. For example:</p><pre>

  // Equivalent to Holder&#X27EA;@Tainted&#X27EB; holder

  // This declares a Holder object, whose Tainting qualifier parameter is set to @Tainted.
  // Holder must have been declared to have a Tainting qualifier parameter
  // by using the @ClassTaintingParam annotation.
  @Tainted(param="main") Holder holder;
</pre><p>The <span style="font-family:monospace">wildcard</span> field can be set to a
<a href="api/org/checkerframework/qualframework/poly/qual/Wildcard.html"><span style="font-family:monospace">Wildcard</span></a> value. This allows qualifier
parameters to act like wildcards.</p><pre>

  // Equivalent to Holder&#X27EA;? extends @Untainted&#X27EB;

  // Instantiate Holder with a wildcard parameter.
  @Untainted(param="main", wildcard=Wildcard.EXTENDS) Holder extends;

  // OK because of the extends bound
  extendsHolder = new @Untainted(param="main") Holder();
  // Error: the new Holder is not a subtype of extendsHolder
  extendsHolder = new @Untainted(param="main") Holder();

</pre></dd><dt class="dt-description"><a href="api/org/checkerframework/checker/tainting/qual/Untainted.html"><span style="font-weight:bold"><span style="font-family:monospace">@Untainted</span></span></a></dt><dd class="dd-description">
<span style="font-family:monospace">@Untainted</span> behaves the same as <span style="font-family:monospace">@Tainted</span> but for untainted values.</dd><dt class="dt-description"><a href="api/org/checkerframework/checker/tainting/qual/Wild.html"><span style="font-weight:bold"><span style="font-family:monospace">@Wild</span></span></a></dt><dd class="dd-description"> Declares
that a class has an unknown qualifier parameter. This is useful in cases
where the qualifier parameter in the class is not used or is used in very
limited ways.<pre>

  // Equivalent to
  Holder&#X27EA;?&#X27EB; h1 = new Holder&#X27EA;@Untainted&#X27EB;();

  @Wild(param="main") Holder h1 = new @Untainted(param="main") Holder;

  // Error: item is not guaranteed to be an @Untainted value.
  @Untainted String s1 = h1.item;

</pre></dd><dt class="dt-description"><a href="api/org/checkerframework/checker/tainting/qual/PolyTainted.html"><span style="font-weight:bold"><span style="font-family:monospace">@PolyTainted</span></span></a></dt><dd class="dd-description">
Enables method qualifier polymorphism. When the field <span style="font-family:monospace">param</span> is not set,
<span style="font-family:monospace">@PolyTainted</span> behaves as described
Section&#XA0;<a href="#qualifier-polymorphism">22.2</a>. For example:<pre>

  class Util {
    static @PolyTainted String id(@PolyTainted String in) {
        return in;
    }
  }

  @Untainted String s = Util.id(getUntaintedString());  // OK
</pre><p>The field <span style="font-family:monospace">param</span> can be used to specify that the inferred qualifier
parameter should be used as an argument to another parameterized type. In
this mode <span style="font-family:monospace">@PolyTainted</span> is a shorthand for a combination of
<span style="font-family:monospace">@MethodTaintingParam</span> and <span style="font-family:monospace">@Var</span>. For example:</p><pre>

  class Util {
    static @PolyTainted(param="main") Holder id(@PolyTainted(param="main") Holder in) {
        return in;
    }
  }

  // Equivalent to this code
  @MethodTaintingParam("meth")
  public static @Var(arg="meth", param="main") Holder id(@Var(arg="meth", param="main) Holder in) {
      return in;
  }

</pre></dd></dl>
<!--TOC subsection id="primary-qualifiers" Primary qualifiers-->
<h3 id="primary-qualifiers" class="subsection">22.3.5&#XA0;&#XA0;Primary qualifiers</h3><!--SEC END --><p>Type system specific annotations, like <span style="font-family:monospace">@Tainted</span> or <span style="font-family:monospace">@Regex</span>, have
dual uses in the qualifier parameter system. When their <span style="font-family:monospace">"param"</span> field
is set, they are used as a argument to a qualifier parameter.</p><p>When their <span style="font-family:monospace">"param"</span> field
is not set, they apply directly to a type and not to any qualifier
parameters of the type. We call the qualifier that applies directly to a
type the primary qualifier. For example an <span style="font-family:monospace">@Tainted String</span>
is a String with a tainted value and its primary qualifier is <span style="font-family:monospace">@Tainted</span>.</p><p><span style="font-family:monospace">@Var</span> can also be used to set primary qualifiers by omitting the
<span style="font-family:monospace">"param"</span> field on the annotation.</p><hr>
<!--TOC chapter id="advanced-type-system-features" Advanced type system features-->
<h1 id="advanced-type-system-features" class="chapter">Chapter&#XA0;23&#XA0;&#XA0;Advanced type system features</h1><!--SEC END --><p>This chapter describes features that are automatically supported by every
checker written with the Checker Framework.
You may wish to skim or skip this chapter on first reading. After you have
used a checker for a little while and want to be able to express more
sophisticated and useful types, or to understand more about how the Checker
Framework works, you can return to it.</p>
<!--TOC section id="invariant-arrays" Invariant array types-->
<h2 id="invariant-arrays" class="section">23.1&#XA0;&#XA0;Invariant array types</h2><!--SEC END --><p>Java&#X2019;s type system is unsound with respect to arrays. That is, the Java
type-checker approves code that is unsafe and will cause a run-time crash.
Technically, the problem is that Java has &#X201C;covariant array types&#X201D;, such
as treating <span style="font-family:monospace">String[]</span> as a subtype of <span style="font-family:monospace">Object[]</span>. Consider the
following example:</p><pre class="verbatim">  String[] strings = new String[] {"hello"};
  Object[] objects = strings;
  objects[0] = new Object();
  String myString = strs[0];
</pre><p>The above code puts an <span style="font-family:monospace">Object</span> in the array <span style="font-family:monospace">strings</span> and thence in
<span style="font-family:monospace">myString</span>, even though <span style="font-family:monospace">myString = new Object()</span> should be, and is,
rejected by the Java type system. Java prevents corruption of the JVM by
doing a costly run-time check at every array assignment; nonetheless, it is
undesirable to learn about a type error only via a run-time crash rather
than at compile time.</p><p>When you pass the <span style="font-family:monospace">-AinvariantArrays</span> command-line option,
the Checker Framework is stricter than Java, in the sense that it treats
arrays invariantly rather than covariantly. This means that a type system
built upon the Checker Framework is sound: you get a compile-time
guarantee without the need for any run-time checks. But it also means that
the Checker Framework rejects code that is similar to what Java unsoundly
accepts. The guarantee and the compile-time checks are about your
extended type system. The Checker Framework does not reject the example
code above, which contains no type annotations.</p><p>Java&#X2019;s covariant array typing is sound if the array is used in a read-only
fashion: that is, if the array&#X2019;s elements are accessed but the array is
not modified. However, facts about read-only usage are not built into any of
the type-checkers. Therefore, when using type systems
along with <span style="font-family:monospace">-AinvariantArrays</span>, you will need to suppress any warnings that
are false positives because the array is treated in a read-only way.</p>
<!--TOC section id="array-context-sensitive" Context-sensitive type inference for array constructors-->
<h2 id="array-context-sensitive" class="section">23.2&#XA0;&#XA0;Context-sensitive type inference for array constructors</h2><!--SEC END --><p>When you write an expression, the Checker Framework gives it the most
precise possible type, depending on the particular expression or value.
For example, when using the Regex Checker (Chapter&#XA0;<a href="#regex-checker">9</a>),
the string <span style="font-family:monospace">"hello"</span> is given type <span style="font-family:monospace">@Regex String</span> because it is a legal
regular expression (whether it is meant to be used as one or not) and the
string <span style="font-family:monospace">"(foo"</span> is given the type <span style="font-family:monospace">@Unqualified String</span> because it is not
a legal regular expression.</p><p>Array constructors work differently. When you create an array with the
array constructor syntax, such as the right-hand side of this assignment:</p><pre class="verbatim">String[] myStrings = {"hello"};
</pre><p>then the expression does not get the most precise possible type, because
doing so could cause inconvenience. Rather, its type is determined by the
context in which it is used: the left-hand side if it is in an assignment,
the declared formal parameter type if it is in a method call, etc.</p><p>In particular, if the expression <code>{"hello"}</code> were given the type
<span style="font-family:monospace">@Regex String[]</span>, then the assignment would be illegal! But the Checker
Framework gives the type <span style="font-family:monospace">String[]</span> based on the assignment context, so the code
type-checks.</p><p>If you prefer a specific type for a constructed array, you can indicate
that either in the context (change the declaration of <span style="font-family:monospace">myStrings</span>) or in a
<span style="font-family:monospace">new</span> construct (change the expression to <span style="font-family:monospace">new @Regex String[] </span><code>{"hello"}</code>).</p>
<!--TOC section id="effective-qualifier" The effective qualifier on a type (defaults and inference)-->
<h2 id="effective-qualifier" class="section">23.3&#XA0;&#XA0;The effective qualifier on a type (defaults and inference)</h2><!--SEC END --><p>A checker sometimes treats a type as having a slightly different qualifier
than what is written on the type &#X2014; especially if the programmer wrote no
qualifier at all.
Most readers can skip this section on first reading, because you will
probably find the system simply &#X201C;does what you mean&#X201D;, without forcing
you to write too many qualifiers in your program.
In particular, qualifiers in method bodies are extremely rare.</p><p>Most of this section is applicable only to source code that is being
checked by a checker.
When the compiler reads a <span style="font-family:monospace">.class</span> file that was checked by a
checker, the <span style="font-family:monospace">.class</span> file contains the explicit or defaulted
annotations from the source code and no defaulting is necessary.
When the compiler reads a <span style="font-family:monospace">.class</span> file that was not checked by a
checker, the <span style="font-family:monospace">.class</span> file contains only explicit annotations and
defaulting might be necessary; see Section&#XA0;<a href="#defaults-classfile">23.3.5</a>
for these rules.</p><p>The following steps determine the effective
qualifier on a type &#X2014; the qualifier that the checkers treat as being present.</p><ol class="enumerate" type=1><li class="li-enumerate">
If a type qualifier is present in the source code, that qualifier is used.</li><li class="li-enumerate">The type system adds implicit qualifiers. This happens whether or not
the programmer has written an explicit type qualifier.<p>Here are some examples of implicit qualifiers:</p><ul class="itemize"><li class="li-itemize">
In the Nullness type system (see Chapter&#XA0;<a href="#nullness-checker">3</a>),
<span style="font-family:monospace">enum</span> values, string literals, and method receivers are always non-null.
</li><li class="li-itemize">In the Interning type system (see Chapter&#XA0;<a href="#interning-checker">5</a>),
string literals and <span style="font-family:monospace">enum</span> values are always interned.
</li></ul><p>If the type has an implicit qualifier, then it is an error to write an
explicit qualifier that is equal to (redundant with) or a supertype of
(weaker than) the implicit qualifier. A programmer may strengthen
(write a subtype of) an implicit qualifier, however.</p><p>Implicit qualifiers arise from two sources:
</p><dl class="description"><dt class="dt-description">
<span style="font-weight:bold">built-in</span></dt><dd class="dd-description">
Implicit qualifiers can be
built into a type system (Section&#XA0;<a href="#writing-type-introduction">28.5</a>), in
which case the type system&#X2019;s documentation explains all of the type
system&#X2019;s implicit qualifiers. Both of the above examples are built into
the Nullness type system.
</dd><dt class="dt-description"><span style="font-weight:bold">programmer-declared</span></dt><dd class="dd-description">
A programmer may introduce an implicit annotation on each use of class
<span style="font-style:italic">C</span> by writing a qualifier on the declaration of class <span style="font-style:italic">C</span>. If <span style="font-family:monospace">MyClass</span>
is declared as <span style="font-family:monospace">class @MyAnno MyClass </span><span style="font-family:monospace">{</span><span style="font-family:monospace">...</span><span style="font-family:monospace">}</span>, then each occurrence of
<span style="font-family:monospace">MyClass</span> in the source code is treated as if it were <span style="font-family:monospace">@MyAnno
MyClass</span>.
</dd></dl></li><li class="li-enumerate">If there is no explicit or implicit qualifier on a type, then a default
qualifier
is applied; see Section&#XA0;<a href="#defaults">23.3.1</a>.<p>At this point (after step 3), every type has a qualifier.</p></li><li class="li-enumerate">The type system may refine a qualified type on a local variable &#X2014; that
is, treat it as a subtype of how it was declared or defaulted. This
refinement is always sound and has the effect of eliminating false
positive error messages. See Section&#XA0;<a href="#type-refinement">23.4</a>.</li></ol>
<!--TOC subsection id="defaults" Default qualifier for unannotated types-->
<h3 id="defaults" class="subsection">23.3.1&#XA0;&#XA0;Default qualifier for unannotated types</h3><!--SEC END --><p>A type system designer, or an end-user programmer, can cause unannotated
references to be treated as if they had a default annotation.</p><p>There are several defaulting mechanisms, for convenience and flexibility.
When determining the default qualifier for a use of a type, the following
rules are used in order, until one applies.
</p><ul class="itemize"><li class="li-itemize">
Use the innermost user-written <span style="font-family:monospace">@DefaultQualifier</span>, as explained in
this section.
</li><li class="li-itemize">Use the default specified by the type system designer
(Section&#XA0;<a href="#typesystem-defaults">28.3.4</a>);
this is usually CLIMB-to-top (Section&#XA0;<a href="#climb-to-top">23.3.2</a>).
</li><li class="li-itemize">Use <a href="api/org/checkerframework/framework/qual/Unqualified.html"><span style="font-family:monospace">@Unqualified</span></a>, which the framework
inserts to avoid ambiguity and simplify the programming interface for
type system designers. Users do not have to worry about this detail,
but type system implementers can rely on the fact that some
qualifier is present.
</li></ul><p>The end-user programmer specifies a default qualifier by writing the <a href="api/org/checkerframework/framework/qual/DefaultQualifier.html"><span style="font-family:monospace">@DefaultQualifier</span></a>
annotation on a package, class, method, or variable declaration. The
argument to <a href="api/org/checkerframework/framework/qual/DefaultQualifier.html"><span style="font-family:monospace">@DefaultQualifier</span></a> is the <span style="font-family:monospace">String</span>
name of an annotation. It may be a short name like <span style="font-family:monospace">"NonNull"</span>, if an
appropriate import statement exists. Otherwise, it should be
fully-qualified, like <span style="font-family:monospace">"org.checkerframework.checker.nullness.qual.NonNull"</span>.
The optional second argument indicates where the default
applies. If the second argument is omitted, the specified annotation is
the default in all locations. See the Javadoc of <a href="api/org/checkerframework/framework/qual/DefaultQualifier.html"><span style="font-family:monospace">DefaultQualifier</span></a> for details.</p><p>For example, using the Nullness type system (Chapter&#XA0;<a href="#nullness-checker">3</a>):</p><pre class="verbatim">import org.checkerframework.framework.qual.*;        // for DefaultQualifier[s]
import org.checkerframework.checker.nullness.qual.NonNull;

@DefaultQualifier(NonNull.class)
class MyClass {

  public boolean compile(File myFile) { // myFile has type "@NonNull File"
    if (!myFile.exists())          // no warning: myFile is non-null
      return false;
    @Nullable File srcPath = ...;  // must annotate to specify "@Nullable File"
    ...
    if (srcPath.exists())          // warning: srcPath might be null
      ...
  }

  @DefaultQualifier(Tainted.class)
  public boolean isJavaFile(File myfile) {  // myFile has type "@Tainted File"
    ...
  }
}
</pre><p>If you wish to write multiple
<a href="api/org/checkerframework/framework/qual/DefaultQualifier.html"><span style="font-family:monospace">@DefaultQualifier</span></a> annotations at a single location,
use
<a href="api/org/checkerframework/framework/qual/DefaultQualifiers.html"><span style="font-family:monospace">@DefaultQualifiers</span></a> instead. For example:</p><pre class="verbatim">@DefaultQualifiers({
  @DefaultQualifier(NonNull.class),
  @DefaultQualifier(Tainted.class)
})
</pre><p>If <span style="font-family:monospace">@DefaultQualifier</span>[<span style="font-family:monospace">s</span>] is placed on a package (via the
<span style="font-family:monospace">package-info.java</span> file), then it applies to the given package <em>and</em>
all subpackages.
</p><p>Recall that an annotation on a class definition indicates an implicit
qualifier (Section&#XA0;<a href="#effective-qualifier">23.3</a>) that can only be
strengthened, not weakened. This can lead to unexpected results if
the default qualifier applies to a class definition. Thus, you may want to
put explicit qualifiers on class declarations (which prevents the default
from taking effect), or exclude class declarations from defaulting.</p><p>When a programmer omits an <span style="font-family:monospace">extends</span> clause at a declaration of a type
parameter, the default still applies to the implicit upper bound. For
example, consider these two declarations:</p><pre class="verbatim">  class C&lt;T&gt; { ... }
  class C&lt;T extends Object&gt; { ... }  // identical to previous line
</pre><p>The two declarations are treated identically by Java, and the default
qualifier applies to the <span style="font-family:monospace">Object</span> upper bound whether it is implicit or
explicit. (The @NonNull default annotation applies only to the upper bound
in the <span style="font-family:monospace">extends</span> clause, not to the lower bound in the inexpressible
implicit <span style="font-family:monospace">super void</span> clause.)</p>
<!--TOC subsection id="climb-to-top" Defaulting rules and CLIMB-to-top-->
<h3 id="climb-to-top" class="subsection">23.3.2&#XA0;&#XA0;Defaulting rules and CLIMB-to-top</h3><!--SEC END --><p>Each type system defines a default qualifier. For example, the default
qualifier for the Nullness Checker is
<a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a>. That means that when a user
writes a type such as <span style="font-family:monospace">Date</span>, the Nullness Checker interprets it as
<span style="font-family:monospace">@NonNull Date</span>.</p><p>The type system applies that default qualifier to most but
not all types. In particular, unless otherwise stated, every type system
uses the CLIMB-to-top rule. This
rule states that the <em>top</em> qualifier in the hierarchy is applied to
the CLIMB locations: <span style="font-weight:bold">C</span>asts, <span style="font-weight:bold">L</span>ocals, <span style="font-weight:bold">I</span>nstanceof,
and (some) i<span style="font-weight:bold">M</span>plicit <span style="font-weight:bold">B</span>ounds.
For example, when the user writes a type such as <span style="font-family:monospace">Date</span> in such a
location, the Nullness Checker interprets it as <span style="font-family:monospace">@Nullable Date</span> (because
<a href="api/org/checkerframework/checker/nullness/qual/Nullable.html"><span style="font-family:monospace">@Nullable</span></a> is the top qualifier in the
hierarchy, see Figure&#XA0;<a href="#fig-nullness-hierarchy">3.1</a>).</p><p>The CLIMB-to-top rule is used only for unannotated source code that is
being processed by a checker. For unannotated libraries (code read by the
compiler in <span style="font-family:monospace">.class</span> or <span style="font-family:monospace">.jar</span> form), the checker uses conservative
defaults (Section&#XA0;<a href="#defaults-classfile">23.3.5</a>).</p><p>The rest of this section explains the rationale and implementation of
CLIMB-to-top.</p><p>Here is the rationale for CLIMB-to-top:</p><ul class="itemize"><li class="li-itemize">
Local variables are defaulted to top because type refinement
(Section&#XA0;<a href="#type-refinement">23.4</a>) is applied to local variables. If a local
variable starts as the top type, then the Checker Framework refines it to
the best (most specific) possible type based on assignments to it. As a
result, a programmer rarely writes an explicit annotation on any of those
locations.<p>Variables defaulted to top include local variables, resource variables in the
try-with-resources construct, variables in for statements, and catch
arguments (known as exception parameters in the Java Language Specification).
Exception parameters need to have the top type because
exceptions of arbitrary qualified types can be thrown and the Checker Framework
does not provide runtime checks.</p></li><li class="li-itemize">Cast and instanceof types are not really defaulted to top. Rather, they
are given the same type as their argument, which is the most specific
possible type. That would also have been the effect if they were given the
top type and then flow-sensitively refined to the type of their argument.</li><li class="li-itemize">Implicit upper bounds are defaulted to top to allow them to be instantiated
in any way. If a user declared <span style="font-family:monospace">class C&lt;T&gt; </span><span style="font-family:monospace">{</span><span style="font-family:monospace"> ... </span><span style="font-family:monospace">}</span>, then
we assume that the user intended to allow any instantiation of the class,
and the declaration is interpreted as <span style="font-family:monospace">class C&lt;T extends @Nullable
Object&gt; </span><span style="font-family:monospace">{</span><span style="font-family:monospace"> ... </span><span style="font-family:monospace">}</span> rather than as <span style="font-family:monospace">class C&lt;T extends
@NonNull Object&gt; </span><span style="font-family:monospace">{</span><span style="font-family:monospace"> ... </span><span style="font-family:monospace">}</span>. The latter would forbid
instantiations such as <span style="font-family:monospace">C&lt;@Nullable String&gt;</span>, or would require
rewriting of code. On the other hand, if a user writes an explicit bound
such as <span style="font-family:monospace">class C&lt;T extends D&gt; </span><span style="font-family:monospace">{</span><span style="font-family:monospace"> ... </span><span style="font-family:monospace">}</span>, then the user
intends some restriction on instantiation and can write a qualifier on the
upper bound as desired.<p>This rule means that the upper bound of <span style="font-family:monospace">class C&lt;T&gt;</span> is defaulted
differently than the upper bound of <span style="font-family:monospace">class C&lt;T extends Object&gt;</span>. It
would be more confusing for &#X201C;<span style="font-family:monospace">Object</span>&#X201D; to be defaulted differently in <span style="font-family:monospace">class C&lt;T extends Object&gt;</span> and in an
instantiation <span style="font-family:monospace">C&lt;Object&gt;</span>, and for the upper bounds to be defaulted
differently in <span style="font-family:monospace">class C&lt;T extends Object&gt;</span>
and <span style="font-family:monospace">class C&lt;T extends Date&gt;</span>.</p></li><li class="li-itemize">Implicit <em>lower</em> bounds are defaulted to the bottom type, again to allow
maximal instantiation. Note that Java does not allow a programmer to
express both the upper and lower bounds of a type, but the Checker
Framework allows the programmer to specify either or both;
see Section&#XA0;<a href="#generics-defaults">22.1.2</a>.</li></ul><p>Here is how the CLIMB-to-top rule is expressed for the Nullness Checker:</p><pre class="verbatim">@DefaultQualifierInHierarchy
@DefaultFor({ TypeUseLocation.EXCEPTION_PARAMETER })
public @interface NonNull { }

public @interface Nullable { }
</pre><p>As mentioned above, the exception parameters are always non-null, so
<span style="font-family:monospace">@DefaultFor({ TypeUseLocation.EXCEPTION_PARAMETER })</span> on <span style="font-family:monospace">@NonNull</span> overrides
the CLIMB-to-top rule.</p><p>A type system designer can specify defaults that differ from the CLIMB-to-top rule. In
addition, a user may choose a different rule for defaults using the
<a href="api/org/checkerframework/framework/qual/DefaultQualifier.html"><span style="font-family:monospace">@DefaultQualifier</span></a> annotation; see
Section&#XA0;<a href="#defaults">23.3.1</a>.</p>
<!--TOC subsection id="inherited-defaults" Inherited defaults-->
<h3 id="inherited-defaults" class="subsection">23.3.3&#XA0;&#XA0;Inherited defaults</h3><!--SEC END --><p>In certain situations, it would be convenient for an annotation on a
superclass member to be automatically inherited by subclasses that override
it. This feature would reduce both annotation effort and program
comprehensibility. In general, a program is read more often than it is
edited/annotated, so the Checker Framework does not currently support this
feature. Here are more detailed justifications:</p><ul class="itemize"><li class="li-itemize">Currently, a user can determine the annotation on a parameter or return
value by looking at a single file. If annotations could be inherited
from supertypes, then a user would have to examine all supertypes to
understand the meaning of an unannotated type in a given file.</li><li class="li-itemize">Different annotations might be inherited from a supertype and an
interface, or from two interfaces. Presumably, the subtype&#X2019;s annotations
would be stronger than either (the greatest lower bound in the type
system), or an error would be thrown if no such annotations existed.</li></ul><p>If these issues can be resolved, then the feature may be added in the
future. Or, it may be added optionally, and each type-checker
implementation can enable it if desired.</p>
<!--TOC subsection id="inherited-wildcard-annotations" Inherited wildcard annotations-->
<h3 id="inherited-wildcard-annotations" class="subsection">23.3.4&#XA0;&#XA0;Inherited wildcard annotations</h3><!--SEC END --><p>If a wildcard is unbounded and has no annotation (e.g. <span style="font-family:monospace">List&lt;?&gt;</span>),
the annotations on the wildcard&#X2019;s bounds are copied from the type parameter
to which the wildcard is an argument. For example, the two wildcards in
the declarations below are equivalent.</p><pre class="verbatim">class MyList&lt;@Nullable T extends @Nullable Object&gt; {}

MyList&lt;?&gt; listOfNullables;
MyList&lt;@Nullable ? extends @Nullable Object&gt; listOfNullables;
</pre><p>We copy these annotations because wildcards must be within the bounds of their
corresponding type parameter. Therefore, there would be many false positive
<span style="font-family:monospace">type.argument.type.incompatible</span> warnings if the bounds of a wildcard
were defaulted differently from the bounds of its corresponding type parameter.
Here is another example:</p><pre class="verbatim">class MyList&lt;@Regex(5) T extends @Regex(1) Object&gt; {}

MyList&lt;?&gt; listOfRegexes;
MyList&lt;@Regex(5) ? extends @Regex(1) Object&gt; listOfRegexes;
</pre><p>Note, this applies only to unbounded wildcards. The two wildcards in the
following example are equivalent.</p><pre class="verbatim">class MyList&lt;@Nullable T extends @Nullable Object&gt; {}

List&lt;? extends Object&gt; listOfNonNulls;
List&lt;@NonNull ? extends @NonNull Object&gt; listOfNonNulls2;
</pre><p>Note, the upper bound of the wildcard <span style="font-family:monospace">? extends Object</span> is defaulted to
<span style="font-family:monospace">@NonNull</span> using the CLIMB-to-top rule (see Section&#XA0;<a href="#climb-to-top">23.3.2</a>).</p>
<!--TOC subsection id="defaults-classfile" Default qualifiers for <span style="font-family:monospace">.class</span> files (conservative library defaults)-->
<h3 id="defaults-classfile" class="subsection">23.3.5&#XA0;&#XA0;Default qualifiers for <span style="font-family:monospace">.class</span> files (conservative library defaults)</h3><!--SEC END --><p>(<em>Note:</em> Currently, the conservative library defaults presented in this section
are off by default and can be turned on by supplying the <span style="font-family:monospace">-AuseDefaultsForUncheckedcode=bytecode</span>
command-line option. In a future release, they will be turned on
by default and it will be possible to turn them off by supplying a
<span style="font-family:monospace">-AuseDefaultsForUncheckedCode=-bytecode</span> command-line option.)</p><p>The defaulting rules presented so far apply to source code that is read by
the compiler. When the compiler reads a <span style="font-family:monospace">.class</span> file, different
defaulting rules apply.</p><p>If the checker was run during the compiler execution that created the
<span style="font-family:monospace">.class</span> file,
then there is no need for
defaults: the <span style="font-family:monospace">.class</span> file has an explicit qualifier at each type use.
(Furthermore, unless warnings were suppressed, those qualifiers are
guaranteed to be correct.)
When you are performing pluggable type-checking,
it is best to ensure that the compiler only reads such <span style="font-family:monospace">.class</span> files.
Section&#XA0;<a href="#compiling-libraries">27.3</a> discusses how to create annotated
libraries.
</p><p>If the checker was not run during the compiler execution that created the
<span style="font-family:monospace">.class</span> file, then the <span style="font-family:monospace">.class</span> file contains only the type qualifiers
that the programmer wrote explicitly. (Furthermore, there is no guarantee
that these qualifiers are correct, since they have not been checked.)
In this case, each checker decides what qualifier to use for the
locations where the programmer did not write an annotation. Unless otherwise noted, the
choice is:</p><ul class="itemize"><li class="li-itemize">
For method parameters and lower bounds, use the bottom qualifier (see
Section&#XA0;<a href="#bottom-qualifier">28.3.5</a>).
</li><li class="li-itemize">For method return values, fields, and upper bounds, use the top qualifier (see
Section&#XA0;<a href="#top-qualifier">28.3.5</a>).
</li></ul><p>These choices are conservative. They are likely to cause many
false-positive type-checking errors, which will help you to know which
library methods need annotations. You can then write those library
annotations (see Chapter&#XA0;<a href="#annotating-libraries">27</a>) or alternately
suppress the warnings (see Section&#XA0;<a href="#suppressing-warnings">24</a>).</p><p>For example, an unannotated method</p><pre class="verbatim">  String concatenate(String p1, String p2)
</pre><p>in a classfile would be interpreted as</p><pre class="verbatim">  @Top String concatenate(@Bottom String p1, @Bottom String p2)
</pre><p>There is no single possible default that is sound for fields. In the rare
circumstance that there is a mutable public field in an unannotated
library, the Checker Framework may fail to warn about code that can
misbehave at run time. The Checker Framework developers are working to
improve handling of mutable public fields in unannotated libraries.</p>
<!--TOC section id="type-refinement" Automatic type refinement (flow-sensitive type qualifier inference)-->
<h2 id="type-refinement" class="section">23.4&#XA0;&#XA0;Automatic type refinement (flow-sensitive type qualifier inference)</h2><!--SEC END --><p>The
checkers soundly treat certain variables and expressions as having a
subtype of their declared or defaulted (Section&#XA0;<a href="#defaults">23.3.1</a>)
type.
This functionality
reduces your burden of annotating types in your program and
eliminates some false positive warnings, but it
never introduces unsoundness nor causes an error to be missed.</p><p>By default all checkers
automatically incorporate type refinement. Most of the time, users don&#X2019;t
have to think about, and may not even notice, type refinement.
(And most readers can skip reading this section of the manual, except
possibly the examples in Section&#XA0;<a href="#type-refinement-examples">23.4.1</a>.)
The
checkers simply do the right thing even when a programmer omits an
annotation on a local variable, or when a programmer writes an
unnecessarily general type in a declaration.</p><p>The functionality has a variety of names: automatic type refinement,
flow-sensitive type qualifier inference, local type inference, and
sometimes just &#X201C;flow&#X201D;.</p><p>If you find examples where you think a value should be inferred to have
(or not have) a
given annotation, but the checker does not do so, please submit a bug
report (see Section&#XA0;<a href="#reporting-bugs">31.2</a>) that includes a small piece of
Java code that reproduces the problem.</p>
<!--TOC subsection id="type-refinement-examples" Type refinement examples-->
<h3 id="type-refinement-examples" class="subsection">23.4.1&#XA0;&#XA0;Type refinement examples</h3><!--SEC END --><p>Suppose you write</p><pre class="verbatim">  @Nullable String myVar;
  ...
  if (myVar != null) {
    myVar.hashCode();
  }
</pre><p>The Nullness Checker issues a warning whenever a method such as
<span style="font-family:monospace">hashCode()</span> is called on a possibly-null value, which may result in a
null pointer exception.
However, the Nullness Checker does not issue a warning for the call
<span style="font-family:monospace">myVar.hashCode()</span>
in the code above.
Within the body
of the <span style="font-family:monospace">if</span> test, the type of <span style="font-family:monospace">myVar</span> is <span style="font-family:monospace">@NonNull String</span>, even though
<span style="font-family:monospace">myVar</span> is declared as <span style="font-family:monospace">@Nullable String</span>.</p><p>Here is another example:</p><pre class="verbatim">  @Nullable String myVar;
  ...                   // myVar has type @Nullable String
  myVar = "hello";
  ...                   // myVar has type @NonNull String
  myVar.hashCode();
  ...
  myVar = myMap.get(someKey);
  ...                   // myVar has type @Nullable String
</pre><p>The Nullness Checker does not issue a warning for
the call <span style="font-family:monospace">myVar.hashCode()</span> above because after the assignment,
the type-checker
treats <span style="font-family:monospace">myVar</span> as having type <span style="font-family:monospace">@NonNull String</span>, which is more precise
than the programmer-written type.</p><p>Flow-sensitive type refinement applies to every checker, including new
checkers that you write. Here is an example for the Regex Checker
(Chapter&#XA0;<a href="#regex-checker">9</a>):</p><pre class="verbatim">  void m2(@Unannotated String s) {
    s = RegexUtil.asRegex(s, 2);  // asRegex throws error if arg is not a regex
                                  // with the given number of capturing groups
    ...   // s now has type "@Regex(2) String"
  }
</pre><p>As a further example,
consider this code, along with comments indicating whether the
Nullness Checker (Chapter&#XA0;<a href="#nullness-checker">3</a>) issues a warning. Note that the same expression may yield a
warning or not depending on its context.</p><pre class="verbatim">  // Requires an argument of type @NonNull String
  void parse(@NonNull String toParse) { ... }

  // Argument does NOT have a @NonNull type
  void lex(@Nullable String toLex) {
    parse(toLex);        // warning:  toLex might be null
    if (toLex != null) {
      parse(toLex);      // no warning:  toLex is known to be non-null
    }
    parse(toLex);        // warning:  toLex might be null
    toLex = new String(...);
    parse(toLex);        // no warning:  toLex is known to be non-null
  }
</pre><p>This example shows the general rules for when
the Nullness Checker (Chapter&#XA0;<a href="#nullness-checker">3</a>) can automatically
determine that certain variables are non-null, even if they were explicitly
or by default annotated as nullable.
The checker treats a variable or expression as <a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a>:
</p><ul class="itemize"><li class="li-itemize">
starting at the time that it is either
assigned a non-null value or checked against null (e.g., via an assertion,
<span style="font-family:monospace">if</span> statement, or being dereferenced)
</li><li class="li-itemize">until it might be re-assigned (e.g.,
via an assignment that might affect this variable, or via a method call
that might affect this variable).
</li></ul><p>The inference indicates when a variable can be treated as having a subtype
of its declared type &#X2014; for instance, when an otherwise nullable type can be
treated as a <a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a> one. The inference never treats a variable as
a supertype of its declared type (e.g., an expression with declared type <a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a>
type is never inferred to be treated as possibly-null).</p>
<!--TOC subsection id="type-refinement-types-that-are-not-refined" Types that are not refined-->
<h3 id="type-refinement-types-that-are-not-refined" class="subsection">23.4.2&#XA0;&#XA0;Types that are not refined</h3><!--SEC END --><p>Array element types and generic arguments are never changed by type
refinement. Changing these components of a type never yields a subtype of
the declared type.
For example, <span style="font-family:monospace">List&lt;Number&gt;</span> is <em>not</em> a
subtype of <span style="font-family:monospace">List&lt;Object&gt;</span>. Similarly, the Checker Framework does not
treat <span style="font-family:monospace">Number[]</span> as a subtype of
<span style="font-family:monospace">Object[]</span>.
For details, see Section&#XA0;<a href="#covariant-type-parameters">22.1.6</a> and
Section&#XA0;<a href="#invariant-arrays">23.1</a>.</p>
<!--TOC subsection id="type-refinement-runtime-tests" Run-time tests and type refinement-->
<h3 id="type-refinement-runtime-tests" class="subsection">23.4.3&#XA0;&#XA0;Run-time tests and type refinement</h3><!--SEC END --><p>Some type systems support a run-time test that the Checker Framework can
use to refine types within the scope of a conditional such as <span style="font-family:monospace">if</span>, after
an <span style="font-family:monospace">assert</span> statement, etc.</p><p>Whether a type system supports such a run-time test depends on whether the
type system is computing properties of data itself, or properties of
provenance (the source of the data). An example of a property about data is
whether a string is a regular expression. An example of a property about
provenance is units of measure: there is no way to look at the
representation of a number and determine whether it is intended to
represent kilometers or miles.</p><p>Type systems that support a run-time test are:
</p><ul class="itemize"><li class="li-itemize">
<a href="#nullness-checker">Nullness Checker</a> for null pointer errors
(see Chapter&#XA0;<a href="#nullness-checker">3</a>)
</li><li class="li-itemize"><a href="#map-key-checker">Map Key Checker</a> to track which values are
keys in a map (see Chapter&#XA0;<a href="#map-key-checker">4</a>)
</li><li class="li-itemize"><a href="#lock-checker">Lock Checker</a> for concurrency and lock errors
(see Chapter&#XA0;<a href="#lock-checker">6</a>)
</li><li class="li-itemize"><a href="#regex-checker">Regex Checker</a> to prevent use of syntactically
invalid regular expressions (see Chapter&#XA0;<a href="#regex-checker">9</a>)
</li><li class="li-itemize"><a href="#formatter-checker">Format String Checker</a> to ensure that format
strings have the right number and type of <span style="font-family:monospace">%</span> directives (see
Chapter&#XA0;<a href="#formatter-checker">10</a>)
</li><li class="li-itemize"><a href="#i18n-formatter-checker">Internationalization Format String Checker</a>
to ensure that i18n format strings have the right number and type of
<span style="font-family:monospace">{}</span> directives (see Chapter&#XA0;<a href="#i18n-formatter-checker">11</a>)
</li></ul><p>Type systems that do not currently support a run-time test, but could do so with some
additional implementation work, are</p><ul class="itemize"><li class="li-itemize">
<a href="#interning-checker">Interning Checker</a> for errors in equality
testing and interning (see Chapter&#XA0;<a href="#interning-checker">5</a>)
</li><li class="li-itemize"><a href="#propkey-checker">Property File Checker</a> to ensure that valid
keys are used for property files and resource bundles (see
Chapter&#XA0;<a href="#propkey-checker">12</a>)
</li><li class="li-itemize"><a href="#i18n-checker">Internationalization Checker</a> to
ensure that code is properly internationalized (see
Chapter&#XA0;<a href="#i18n-checker">12.2</a>)
</li><li class="li-itemize"><a href="#signature-checker">Signature String Checker</a> to ensure that the
string representation of a type is properly used, for example in
<span style="font-family:monospace">Class.forName</span> (see Chapter&#XA0;<a href="#signature-checker">13</a>).
</li><li class="li-itemize"><a href="#constant-value-checker">Constant Value Checker</a> to determine
whether an expression&#X2019;s value can be known at compile time
(see Chapter&#XA0;<a href="#constant-value-checker">16</a>)
</li></ul><p>Type systems that cannot support a run-time test are:</p><ul class="itemize"><li class="li-itemize">
<a href="#initialization-checker">Initialization Checker</a> to ensure all
fields are set in the constructor (see
Chapter&#XA0;<a href="#initialization-checker">3.8</a>)
</li><li class="li-itemize"><a href="#fenum-checker">Fake Enum Checker</a> to allow type-safe fake enum
patterns (see Chapter&#XA0;<a href="#fenum-checker">7</a>)
</li><li class="li-itemize"><a href="#tainting-checker">Tainting Checker</a> for trust and security errors
(see Chapter&#XA0;<a href="#tainting-checker">8</a>)
</li><li class="li-itemize"><a href="#guieffect-checker">GUI Effect Checker</a> to ensure that non-GUI
threads do not access the UI, which would crash the application
(see Chapter&#XA0;<a href="#guieffect-checker">14</a>)
</li><li class="li-itemize"><a href="#units-checker">Units Checker</a> to ensure operations are
performed on correct units of measurement
(see Chapter&#XA0;<a href="#units-checker">15</a>)
</li><li class="li-itemize"><a href="#aliasing-checker">Aliasing Checker</a> to identify whether
expressions have aliases (see Chapter&#XA0;<a href="#aliasing-checker">17</a>)
</li><li class="li-itemize"><a href="#linear-checker">Linear Checker</a> to control aliasing and prevent
re-use (see Chapter&#XA0;<a href="#linear-checker">18</a>)
</li><li class="li-itemize"><a href="#subtyping-checker">Subtyping Checker</a> for customized checking without
writing any code (see Chapter&#XA0;<a href="#subtyping-checker">20</a>)
</li></ul>
<!--TOC subsection id="type-refinement-fields" Fields and flow-sensitive analysis-->
<h3 id="type-refinement-fields" class="subsection">23.4.4&#XA0;&#XA0;Fields and flow-sensitive analysis</h3><!--SEC END --><p>Flow sensitivity analysis infers the type of fields in some restricted cases:</p><ul class="itemize"><li class="li-itemize">A final initialized field:
Type inference is performed for final fields that are initialized to a
compile-time constant at the declaration site; so the type of <span style="font-family:monospace">protocol</span>
is <span style="font-family:monospace">@NonNull String</span> in the following declaration:<pre class="verbatim">    public final String protocol = "https";
</pre><p>Such an inferred type may leak to the public interface of the class.
If you wish to override such behavior, you can explicitly insert the desired
annotation, e.g.,</p><pre class="verbatim">    public final @Nullable String protocol = "https";
</pre></li><li class="li-itemize">Within method bodies:
Type inference is performed for fields in the context of method bodies,
like local variables.
Consider the following example, where <span style="font-family:monospace">updatedAt</span> is a nullable
field:<pre class="verbatim">class DBObject {
  @Nullable Date updatedAt;

  void m() {
    // updatedAt is @Nullable, so warning about .getTime()
    ... updatedAt.getTime() ... // warning about possible NullPointerException

    if (updatedAt == null) {
      updatedAt = new Date();
    }

    // updatedAt is now @NonNull, so .getTime() call is OK
    ... updatedAt.getTime() ...
  }
}
</pre><p>Here the call to <span style="font-family:monospace">persistData()</span> invalidates the inferred non-null type
of <span style="font-family:monospace">updatedAt</span>.</p><p>A method call may invalidate inferences about field types; see
Section&#XA0;<a href="#type-refinement-purity">23.4.5</a>.</p></li></ul>
<!--TOC subsection id="type-refinement-purity" Side effects, determinism, purity, and flow-sensitive analysis-->
<h3 id="type-refinement-purity" class="subsection">23.4.5&#XA0;&#XA0;Side effects, determinism, purity, and flow-sensitive analysis</h3><!--SEC END --><p>As described above, a checker can use a refined type for an expression from
the time when the checker infers that the value has that refined type,
until the checker can no longer support that inference.</p><p>The refined type begins at a test (such as <span style="font-family:monospace">if (myvar != null) ...</span>) or
an assignment. If the assignment occurs within a method body,
you can write a postcondition annotation such as
<a href="api/org/checkerframework/checker/nullness/qual/EnsuresNonNull.html"><span style="font-family:monospace">@EnsuresNonNull</span></a>.</p><p>The refined type ends at an assignment or possible assignment. Any method
call has the potential to side-effect any field, so calling a method
typically causes the checker to discard its knowledge of the refined type.
This is undesirable if the method doesn&#X2019;t actually re-assign the field.</p><p>There are three annotations, collectively called purity annotations, that
you can use to help express what effects a method call does not have.
Usually, you only need to use <a href="api/org/checkerframework/dataflow/qual/SideEffectFree.html"><span style="font-family:monospace">@SideEffectFree</span></a>.</p><dl class="description"><dt class="dt-description"><a href="api/org/checkerframework/dataflow/qual/SideEffectFree.html"><span style="font-weight:bold"><span style="font-family:monospace">@SideEffectFree</span></span></a></dt><dd class="dd-description">
indicates that the method has no externally-visible side effects.</dd><dt class="dt-description"><a href="api/org/checkerframework/dataflow/qual/Deterministic.html"><span style="font-weight:bold"><span style="font-family:monospace">@Deterministic</span></span></a></dt><dd class="dd-description">
indicates that if the method is called multiple times with identical
arguments, then it returns the identical result.</dd><dt class="dt-description"><a href="api/org/checkerframework/dataflow/qual/Pure.html"><span style="font-weight:bold"><span style="font-family:monospace">@Pure</span></span></a></dt><dd class="dd-description">
indicates that the method is both @SideEffectFree and @Deterministic.</dd></dl><p>The Javadoc of the annotations describes their semantics and how they are
checked. This manual section gives examples and supplementary information.</p><p>For example, consider the
following declarations and uses:</p><pre class="verbatim">  @Nullable Object myField;

  int computeValue() { ... }

  void m() {
    ...
    if (myField != null) {
      int result = computeValue();
      myField.toString();
    }
  }
</pre><p>Ordinarily, the Nullness Checker would issue a warning regarding the
<span style="font-family:monospace">toString()</span> call, because the receiver <span style="font-family:monospace">myField</span> might be
<span style="font-family:monospace">null</span>, according to the <span style="font-family:monospace">@Nullable</span> annotation on the
declaration of <span style="font-family:monospace">myField</span>. Even though the code checked the value of
<span style="font-family:monospace">myField</span>, the call to <span style="font-family:monospace">computeValue</span> might have re-set <span style="font-family:monospace">myField</span> to null.
If you change the declaration of <span style="font-family:monospace">computeValue</span> to</p><pre class="verbatim">  @SideEffectFree
  int computeValue() { ... }
</pre><p>then the Nullness Checker issues no warnings, because it can reason that
the second occurrence of <span style="font-family:monospace">myField</span> has the same (non-null) value as
the one in the test.</p><p>As a more complex example, consider the
following declaration and uses:</p><pre class="verbatim">  @Nullable Object getField(Object arg) { ... }

  void m() {
    ...
    if (x.getField(y) != null) {
      x.getField(y).toString();
    }
  }
</pre><p>Ordinarily, the Nullness Checker would issue a warning regarding the
<span style="font-family:monospace">toString()</span> call, because the receiver <span style="font-family:monospace">x.getField(y)</span> might
be <span style="font-family:monospace">null</span>, according to the <span style="font-family:monospace">@Nullable</span> annotation in the
declaration of <span style="font-family:monospace">getField</span>. If you change the declaration of
<span style="font-family:monospace">getField</span> to</p><pre class="verbatim">  @Pure
  @Nullable Object getField(Object arg) { ... }
</pre><p>then the Nullness Checker issues no warnings, because it can reason that
the two invocations <span style="font-family:monospace">x.getField(y)</span> have the same value, and
therefore that <span style="font-family:monospace">x.getField(y)</span> is non-null within the then branch
of the if statement.</p><p>If you supply the command-line option <span style="font-family:monospace">-AsuggestPureMethods</span>, then the
Checker Framework will suggest methods that can be marked as
<span style="font-family:monospace">@SideEffectFree</span>, <span style="font-family:monospace">@Deterministic</span>, or <span style="font-family:monospace">@Pure</span>.</p><p>Currently, purity annotations are trusted. Purity annotations on called
methods affect type-checking of client code. However, you can make a
mistake by writing <span style="font-family:monospace">@SideEffectFree</span> on the declaration of a method that
is not actually side-effect-free or by writing <span style="font-family:monospace">@Deterministic</span> on the
declaration of a method that is not actually deterministic. To enable
checking of the annotations, supply the command-line option
<span style="font-family:monospace">-AcheckPurityAnnotations</span>. It is not enabled by default because of a high false
positive rate. In the future, after a new purity-checking analysis is
implemented, the Checker Framework will default to checking purity
annotations.</p><p>It can be tedious to annotate library methods with purity annotations such
as <span style="font-family:monospace">@SideEffectFree</span>. If you supply the command-line option
<span style="font-family:monospace">-AassumeSideEffectFree</span>, then the Checker Framework will unsoundly
assume that every called method is side-effect-free. This can make
flow-sensitive type refinement much more effective, since method calls will
not cause the analysis to discard information that it has learned.
However, this option can mask real errors. It is most appropriate when you
are starting out annotating a project, or if you are using the Checker
Framework to find some bugs but not to give a guarantee that no more errors
exist of the given type.</p><p>A common error is:</p><div style="font-size:small;">
<pre class="verbatim">MyClass.java:1465: error: int hashCode() in MyClass cannot override int hashCode(Object this) in java.lang.Object;
attempting to use an incompatible purity declaration
    public int hashCode() {
               ^
  found   : []
  required: [SIDE_EFFECT_FREE, DETERMINISTIC]
</pre></div><p>The reason for the error is that the <span style="font-family:monospace">Object</span> class is annotated as:</p><pre class="verbatim">class Object {
  ...
  @Pure int hashCode() { ... }
}
</pre><p>(where <a href="api/org/checkerframework/dataflow/qual/Pure.html"><span style="font-family:monospace">@Pure</span></a> means both
<a href="api/org/checkerframework/dataflow/qual/SideEffectFree.html"><span style="font-family:monospace">@SideEffectFree</span></a> and
<a href="api/org/checkerframework/dataflow/qual/Deterministic.html"><span style="font-family:monospace">@Deterministic</span></a>). Every overriding
definition, including those in your program, must use be at least as strong
a specification; in particular, every overriding definition must be
annotated as <span style="font-family:monospace">@Pure</span>.</p><p>You can fix the definition by adding <span style="font-family:monospace">@Pure</span> to your method definition.
Alternately, you can suppress the warning.
You can suppress each such warning individually using
<span style="font-family:monospace">@SuppressWarnings("purity.invalid.overriding")</span>,
or you can use the <span style="font-family:monospace">-AsuppressWarnings=purity.invalid.overriding</span>
command-line argument to suppress all such warnings.
In the future, the Checker Framework will support inheriting annotations
from superclass definitions.</p><p>The <a href="api/org/checkerframework/dataflow/qual/TerminatesExecution.html"><span style="font-family:monospace">@TerminatesExecution</span></a> annotation
indicates that a given method never returns. This can enable the
flow-sensitive type refinement to be more precise.</p>
<!--TOC subsection id="type-refinement-assertions" Assertions-->
<h3 id="type-refinement-assertions" class="subsection">23.4.6&#XA0;&#XA0;Assertions</h3><!--SEC END --><p>If your code contains an <span style="font-family:monospace">assert</span> statement, then your code could behave
in two different ways at run time, depending on whether assertions are
enabled or disabled
via the <span style="font-family:monospace">-ea</span> or <span style="font-family:monospace">-da</span> command-line options to java.</p><p>By default, the Checker Framework outputs warnings about any error that
could happen at run time, whether assertions are enabled or disabled.</p><p>If you supply the <span style="font-family:monospace">-AassumeAssertionsAreEnabled</span> command-line option, then
the Checker Framework assumes assertions are enabled. If you supply the
<span style="font-family:monospace">-AassumeAssertionsAreDisabled</span> command-line option, then the Checker
Framework assumes assertions are disabled. You may not supply both
command-line options. It is uncommon to supply either one.</p><p>These command-line arguments have no effect on processing of <span style="font-family:monospace">assert</span>
statements whose message contains the text <span style="font-family:monospace">@AssumeAssertion</span>; see
Section&#XA0;<a href="#assumeassertion">24.2</a>.</p>
<!--TOC section id="java-expressions-as-arguments" Writing Java expressions as annotation arguments-->
<h2 id="java-expressions-as-arguments" class="section">23.5&#XA0;&#XA0;Writing Java expressions as annotation arguments</h2><!--SEC END --><p>Sometimes, it is necessary to write a Java expression as the argument to an
annotation. The annotations that take a Java
expression as an argument include:</p><ul class="itemize"><li class="li-itemize">
<a href="api/org/checkerframework/framework/qual/RequiresQualifier.html"><span style="font-family:monospace">@RequiresQualifier</span></a>
</li><li class="li-itemize"><a href="api/org/checkerframework/framework/qual/EnsuresQualifier.html"><span style="font-family:monospace">@EnsuresQualifier</span></a>
</li><li class="li-itemize"><a href="api/org/checkerframework/framework/qual/EnsuresQualifierIf.html"><span style="font-family:monospace">@EnsuresQualifierIf</span></a>
</li><li class="li-itemize"><a href="api/org/checkerframework/checker/nullness/qual/RequiresNonNull.html"><span style="font-family:monospace">@RequiresNonNull</span></a>
</li><li class="li-itemize"><a href="api/org/checkerframework/checker/nullness/qual/EnsuresNonNull.html"><span style="font-family:monospace">@EnsuresNonNull</span></a>
</li><li class="li-itemize"><a href="api/org/checkerframework/checker/nullness/qual/EnsuresNonNullIf.html"><span style="font-family:monospace">@EnsuresNonNullIf</span></a>
</li><li class="li-itemize"><a href="api/org/checkerframework/checker/nullness/qual/KeyFor.html"><span style="font-family:monospace">@KeyFor</span></a>
</li><li class="li-itemize"><a href="api/org/checkerframework/checker/i18nformatter/qual/I18nFormatFor.html"><span style="font-family:monospace">@I18nFormatFor</span></a>
</li><li class="li-itemize"><a href="api/org/checkerframework/checker/lock/qual/EnsuresLockHeld.html"><span style="font-family:monospace">@EnsuresLockHeld</span></a>
</li><li class="li-itemize"><a href="api/org/checkerframework/checker/lock/qual/EnsuresLockHeldIf.html"><span style="font-family:monospace">@EnsuresLockHeldIf</span></a>
</li><li class="li-itemize"><a href="api/org/checkerframework/checker/lock/qual/GuardedBy.html"><span style="font-family:monospace">@GuardedBy</span></a>
</li><li class="li-itemize"><a href="api/org/checkerframework/checker/lock/qual/Holding.html"><span style="font-family:monospace">@Holding</span></a>
</li></ul><p>The set of permitted expressions is a subset of all Java expressions:</p><ul class="itemize"><li class="li-itemize">
the receiver object, <span style="font-family:monospace">this</span>. You can write <span style="font-family:monospace">this</span> to annotate any
variable or declaration where you could write <span style="font-family:monospace">this</span> in code.
Notably, it cannot be used in annotations on declarations of
static fields or methods. For a field, <span style="font-family:monospace">this</span> is the field&#X2019;s
receiver, i.e. its container. For a local variable, it is the
method&#X2019;s receiver.
Note that assignment of type qualifier annotations with argument
<span style="font-family:monospace">this</span> is conservatively disallowed because the receiver may fall
out of scope. For example, suppose the annotation on <span style="font-family:monospace">obj2.key</span>
has been refined to <span style="font-family:monospace">@KeyFor("this")</span>. Then the assignment
<span style="font-family:monospace">obj1.key = obj2.key</span> is disallowed, because <span style="font-family:monospace">obj2</span> may
fall out of scope while <span style="font-family:monospace">obj1</span> is still in use.</li><li class="li-itemize">the receiver object as seen from the superclass, <span style="font-family:monospace">super</span>. This can be used
to refer to fields shadowed in the subclass (although shadowing fields is
discouraged in Java).</li><li class="li-itemize"><span style="font-family:monospace">itself</span>, i.e. the value of the annotated reference (non-primitive) variable.
Currently only defined for the <span style="font-family:monospace">@GuardedBy</span> type system.
For example, <span style="font-family:monospace">@GuardedBy("itself") Object o</span> indicates that the value
referenced by <span style="font-family:monospace">o</span> is guarded by the intrinsic (monitor) lock of the value
referenced by <span style="font-family:monospace">o</span>.</li><li class="li-itemize">a formal parameter. Write <span style="font-family:monospace">#</span> followed by the <span style="font-weight:bold">one-based</span> parameter
index. For example: <span style="font-family:monospace">#1</span>, <span style="font-family:monospace">#3</span>. It is not permitted to write <span style="font-family:monospace">#0</span> to
refer to the receiver object; use <span style="font-family:monospace">this</span> instead. (A side note:
The formal parameter syntax <span style="font-family:monospace">#1</span> is less natural in source code
than writing the formal parameter name. This syntax is necessary for
separate compilation, when an annotated method has already been compiled
into a <span style="font-family:monospace">.class</span> file and a client of that method is later compiled.
In the <span style="font-family:monospace">.class</span> file, no formal parameter name information is available,
so it is necessary to use a number to indicate a formal parameter.)
</li><li class="li-itemize">a static variable. Write the class name and the variable, as in
<span style="font-family:monospace">System.out</span>.
</li><li class="li-itemize">a field of any expression. For example: <span style="font-family:monospace">next</span>,
<span style="font-family:monospace">this.next</span>, <span style="font-family:monospace">#1.next</span>. You may optionally omit a leading &#X201C;<span style="font-family:monospace">this.</span>&#X201D;, just as in Java. Thus,
<span style="font-family:monospace">this.next</span> and <span style="font-family:monospace">next</span> are equivalent.</li><li class="li-itemize">an array access. For example: <span style="font-family:monospace">this.myArray[i]</span>, <span style="font-family:monospace">vals[#1]</span>.</li><li class="li-itemize">literals: string, integer, long, null.</li><li class="li-itemize">a method invocation on any expression.
This even works for overloaded methods and methods with type parameters.
For example:
<span style="font-family:monospace">m1(x, y.z, #2)</span>, <span style="font-family:monospace">a.m2("hello")</span>.
One unusual feature is that the method call is allowed to have side
effects. If a specification is going to be checked at run time via
assertions, then the specification must not use methods with side
effects. But, the Checker Framework works at compile time, so it allows
side effects.
The current implementation will never able to prove such
a contract, but it is able to use the information (when checking
the method body with preconditions, or when checking the caller&#X2019;s
code with postconditions). This can be useful to annotate trusted
methods precisely (e.g., <span style="font-family:monospace">java.io.BufferedReader.ready()</span>). </li></ul><p><span style="font-weight:bold">Limitations:</span>
The following Java expressions may not currently be written:
</p><ul class="itemize"><li class="li-itemize">
Some literals: floats, doubles, chars, and class literals.
</li><li class="li-itemize">String concatenation expressions.
</li><li class="li-itemize">Mathematical operators (plus, minus, division, ...).
</li><li class="li-itemize">Comparisons (equality, less than, etc.).
</li></ul><p>Additionally, it is not possible to write
quantification over all array components (e.g. to express that all
array elements are non-null). There is no such Java expression, but it
would be useful when writing specifications.</p>
<!--TOC section id="unused-fields" Unused fields-->
<h2 id="unused-fields" class="section">23.6&#XA0;&#XA0;Unused fields</h2><!--SEC END --><p>In an inheritance hierarchy, subclasses often introduce new methods and
fields. For example, a <span style="font-family:monospace">Marsupial</span> (and its subclasses such as
<span style="font-family:monospace">Kangaroo</span>) might have a variable <span style="font-family:monospace">pouchSize</span> indicating the size of the animal&#X2019;s
pouch. The field does not exist in superclasses such as
<span style="font-family:monospace">Mammal</span> and <span style="font-family:monospace">Animal</span>, so Java issues a compile-time
error if a program tries to access <span style="font-family:monospace">myMammal.pouchSize</span>.</p><p>If you cannot use subtypes in your program, you can enforce similar
requirements using type qualifiers.
For fields, use the <span style="font-family:monospace">@Unused</span> annotation (Section&#XA0;<a href="#unused-annotation">23.6.1</a>), which enforces that a field or method may only
be accessed from a receiver expression with a given annotation (or one of
its subtypes).
For methods, annotate the receiver parameter <span style="font-family:monospace">this</span>; then a method call
type-checks only if the actual receiver is of the specified type.</p><p>Also see the discussion of typestate checkers, in
Chapter&#XA0;<a href="#typestate-checker">21.1</a>.</p>
<!--TOC subsection id="unused-annotation" <span style="font-family:monospace">@Unused</span> annotation-->
<h3 id="unused-annotation" class="subsection">23.6.1&#XA0;&#XA0;<span style="font-family:monospace">@Unused</span> annotation</h3><!--SEC END --><p>A Java subtype can have more fields than its supertype. For example:</p><pre class="verbatim">class Animal { }
class Mammal extends Animal { ... }
class Marsupial extends Mammal {
  int pouchSize;  // pouch capacity, in cubic centimeters
  ...
}
</pre><p>You can simulate
the same effect for type qualifiers:
the <a href="api/org/checkerframework/framework/qual/Unused.html"><span style="font-family:monospace">@Unused</span></a> annotation
on a field declares that the field may <em>not</em> be accessed via a receiver of
the given qualified type (or any <em>super</em>type).
For example:</p><pre class="verbatim">class Animal {
  @Unused(when=Mammal.class)
  int pouchSize;  // pouch capacity, in cubic centimeters
  ...
}
@interface Mammal { }
@interface Marsupial { }

@Marsupial Animal joey = ...;
... joey.pouchSize ...    // OK
@Mammal Animal mae = ...;
... mae.pouchSize ...    // compile-time error
</pre><p>The above class declaration is like writing</p><pre class="verbatim">class @Mammal-Animal { ... }
class @Marsupial-Animal {
  int pouchSize;  // pouch capacity, in cubic centimeters
  ...
}
</pre><hr>
<!--TOC chapter id="suppressing-warnings" Suppressing warnings-->
<h1 id="suppressing-warnings" class="chapter">Chapter&#XA0;24&#XA0;&#XA0;Suppressing warnings</h1><!--SEC END --><p>When the Checker Framework reports a warning, it&#X2019;s best to change the code
or its annotations, to eliminate the warning. Alternately, you can
suppress the warning, which does not change the code but prevents the
Checker Framework from reporting this particular warning to you.</p><p>You may wish to suppress checker warnings because of unannotated libraries
or un-annotated portions of your own code, because of application
invariants that are beyond the capabilities of the type system, because of
checker limitations, because you are interested in only some of the
guarantees provided by a checker, or for other reasons.
Suppressing a warning is similar to writing a cast in a Java
program: the programmer knows more about the type than the type system does
and uses the warning suppression or cast to convey that information to the
type system.</p><p>You can suppress a single warning message (or those in a single method or
class) by using the following mechanisms:</p><ul class="itemize"><li class="li-itemize">
the <span style="font-family:monospace">@SuppressWarnings</span> annotation
(Section&#XA0;<a href="#suppresswarnings-annotation">24.1</a>), or
</li><li class="li-itemize">the <span style="font-family:monospace">@AssumeAssertion</span> string in an <span style="font-family:monospace">assert</span> message (Section&#XA0;<a href="#assumeassertion">24.2</a>).
</li></ul><p>You can suppress warnings throughout the codebase by using the following mechanisms:</p><ul class="itemize"><li class="li-itemize">
the <span style="font-family:monospace">-AsuppressWarnings</span> command-line option (Section&#XA0;<a href="#suppresswarnings-command-line">24.3</a>),
</li><li class="li-itemize">the <span style="font-family:monospace">-AskipUses</span> and <span style="font-family:monospace">-AonlyUses</span> command-line options (Section&#XA0;<a href="#askipuses">24.4</a>),
</li><li class="li-itemize">the <span style="font-family:monospace">-AskipDefs</span> and <span style="font-family:monospace">-AonlyDefs</span> command-line options (Section&#XA0;<a href="#askipdefs">24.5</a>),
</li><li class="li-itemize">the <span style="font-family:monospace">-AuseDefaultsForUncheckedCode=source</span> command-line
option (Section&#XA0;<a href="#compiling-libraries">27.3</a>),
</li><li class="li-itemize">the <span style="font-family:monospace">-Alint</span> command-line option (Section&#XA0;<a href="#alint">24.6</a>), or
</li><li class="li-itemize">not using the <span style="font-family:monospace">-processor</span> command-line option
(Section&#XA0;<a href="#no-processor">24.7</a>).
</li></ul><p>Some type checkers can suppress warnings via
</p><ul class="itemize"><li class="li-itemize">
checker-specific mechanisms (Section&#XA0;<a href="#checker-specific-suppression">24.8</a>).
</li></ul><p>We now explain these mechanisms in turn.</p>
<!--TOC section id="suppresswarnings-annotation" <span style="font-family:monospace">@SuppressWarnings</span> annotation-->
<h2 id="suppresswarnings-annotation" class="section">24.1&#XA0;&#XA0;<span style="font-family:monospace">@SuppressWarnings</span> annotation</h2><!--SEC END --><p>
You can suppress specific errors and warnings by use of the
<span style="font-family:monospace">@SuppressWarnings</span> annotation, for example
<span style="font-family:monospace">@SuppressWarnings("interning")</span> or <span style="font-family:monospace">@SuppressWarnings("nullness")</span>.
Section&#XA0;<a href="#suppresswarnings-annotation-syntax">24.1.1</a> explains the syntax of the
argument string.
</p><p>A <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/SuppressWarnings.html"><span style="font-family:monospace">@SuppressWarnings</span></a>
annotation may be placed on program declarations such as a local
variable declaration, a method, or a class. It suppresses all warnings
related to the given checker, for that program element.
Section&#XA0;<a href="#suppresswarnings-annotation-locations">24.1.2</a> discusses where the
annotation may be written in source code.</p><p>Section&#XA0;<a href="#suppresswarnings-best-practices">24.1.3</a> gives best practices for
writing <span style="font-family:monospace">@SuppressWarnings</span> annotations.</p>
<!--TOC subsection id="suppresswarnings-annotation-syntax" <span style="font-family:monospace">@SuppressWarnings</span> syntax-->
<h3 id="suppresswarnings-annotation-syntax" class="subsection">24.1.1&#XA0;&#XA0;<span style="font-family:monospace">@SuppressWarnings</span> syntax</h3><!--SEC END --><p>The <span style="font-family:monospace">@SuppressWarnings</span> annotation takes a string argument.</p><p>The most common usage is <span style="font-family:monospace">@SuppressWarnings("</span><span style="font-family:monospace"><em>checkername</em></span><span style="font-family:monospace">")</span>, as
in <span style="font-family:monospace">@SuppressWarnings("interning")</span> or
<span style="font-family:monospace">@SuppressWarnings("nullness")</span>. The argument <em>checkername</em> is
in lower case and is derived from the way you invoke the checker. For
example, if you invoke a checker as
<span style="font-family:monospace">javac -processor MyNiftyChecker ...</span>,
then you would suppress its error messages with
<span style="font-family:monospace">@SuppressWarnings("mynifty")</span>. (An exception is the Subtyping
Checker, for which you use the annotation name; see
Section&#XA0;<a href="#subtyping-using">20.1</a>). While not recommended, using
<span style="font-family:monospace">@SuppressWarnings("all")</span> will suppress all warnings for all
checkers.</p><p>The <span style="font-family:monospace">@SuppressWarnings</span> argument string can also be of the form
<em>checkername:messagekey</em>, in which case only
errors/warnings relating to the given message key are suppressed. For example,
<span style="font-family:monospace">cast.unsafe</span> is the messagekey for warnings about an unsafe cast, and
<span style="font-family:monospace">cast.redundant</span> is the messagekey for warnings about a redundant cast.</p><p>Each warning from the compiler gives the most specific
suppression key that can be used to suppress that warning.
An example is <span style="font-family:monospace">dereference.of.nullable</span> in</p><pre class="verbatim">MyFile.java:107: error: [dereference.of.nullable] dereference of possibly-null reference myList
          myList.add(elt);
          ^
</pre><p>With the <span style="font-family:monospace">-AshowSuppressWarningKeys</span> command-line option,
the compiler lists every key that would suppress the warning,
not just the most specific one.</p>
<!--TOC subsection id="suppresswarnings-annotation-locations" Where <span style="font-family:monospace">@SuppressWarnings</span> can be written-->
<h3 id="suppresswarnings-annotation-locations" class="subsection">24.1.2&#XA0;&#XA0;Where <span style="font-family:monospace">@SuppressWarnings</span> can be written</h3><!--SEC END --><p><span style="font-family:monospace">@SuppressWarnings</span> is a declaration annotation, so it may be placed on
program declarations such as a local variable declaration, a method, or a
class. It cannot be used on statements, expressions, or types. To reduce
the scope of a <span style="font-family:monospace">@SuppressWarnings</span> annotation, it is sometimes desirable
to extract part of an expression into a local variable, so that warnings
can be suppressed just for that local variable&#X2019;s initializer expression.</p><p>As an example, consider suppressing a warnings at a cast that you know is safe. Here is an example
that uses the Tainting Checker (Section&#XA0;<a href="#tainting-checker">8</a>); assume
that <span style="font-family:monospace">expr</span> has compile-time (declared) type <span style="font-family:monospace">@Tainted String</span>, but you
know that the run-time value of <span style="font-family:monospace">expr</span> is untainted.</p><pre class="verbatim">  @SuppressWarnings("tainting:cast.unsafe") // expr is untainted because ... [explanation goes here]
  @Untainted String myvar = expr;
</pre><p>It would have been <em>illegal</em> to write</p><pre class="verbatim">  @Untainted String myvar;
  ...
  @SuppressWarnings("tainting:cast.unsafe") // expr is untainted because ...
  myvar = expr;
</pre><p>This does not work because
Java does not permit annotations (such as <span style="font-family:monospace">@SuppressWarnings</span>) on
assignments or other statements or expressions.</p>
<!--TOC subsection id="suppresswarnings-best-practices" Good practices when suppressing warnings-->
<h3 id="suppresswarnings-best-practices" class="subsection">24.1.3&#XA0;&#XA0;Good practices when suppressing warnings</h3><!--SEC END -->
<!--TOC subsubsection id="suppresswarnings-best-practices-smallest-scope" Suppress warnings in the smallest possible scope-->
<h4 id="suppresswarnings-best-practices-smallest-scope" class="subsubsection">Suppress warnings in the smallest possible scope</h4><!--SEC END --><p>If a particular expression causes a
false positive warning, you should extract that expression into a local variable
and place a <span style="font-family:monospace">@SuppressWarnings</span> annotation on the variable
declaration, rather than suppressing warnings for a larger expression or an
entire method body. See Section&#XA0;<a href="#suppresswarnings-annotation-locations">24.1.2</a>.</p>
<!--TOC subsubsection id="suppresswarnings-best-practices-specific-argument" Use a specific argument to <span style="font-family:monospace">@SuppressWarnings</span>-->
<h4 id="suppresswarnings-best-practices-specific-argument" class="subsubsection">Use a specific argument to <span style="font-family:monospace">@SuppressWarnings</span></h4><!--SEC END --><p><a id="compiler-message-keys"></a></p><p>It is best to use the most specific possible message key to suppress just a
specific error that you know to be a false positive. The checker outputs
this message key when it issues an error. If you use a broader
<span style="font-family:monospace">@SuppressWarnings</span> annotation, then it may mask other errors that you
needed to know about.</p><p>The example of Section&#XA0;<a href="#suppresswarnings-annotation-locations">24.1.2</a> could
have been written as any one of the following, with the last one being the
best style:</p><pre class="verbatim">  @SuppressWarnings("tainting")              // suppresses all tainting-related warnings
  @SuppressWarnings("tainting:cast")         // suppresses tainting warnings about casts
  @SuppressWarnings("tainting:cast.unsafe")  // suppresses tainting warnings about unsafe casts
</pre>
<!--TOC subsubsection id="suppresswarnings-best-practices-justification" Justify why the warning is a false positive-->
<h4 id="suppresswarnings-best-practices-justification" class="subsubsection">Justify why the warning is a false positive</h4><!--SEC END --><p>A <span style="font-family:monospace">@SuppressWarnings</span> annotation asserts that the code is actually
correct or safe (that is, no undesired behavior will occur), even though
the type system is unable to prove that the code is correct or safe.</p><p>Whenever you write a <span style="font-family:monospace">@SuppressWarnings</span> annotation, you should also
write, typically on the same line, a code comment
explaining why the code is actually correct. In some cases you might also
justify why the code cannot be rewritten in a simpler way that would be
amenable to type-checking.</p><p>This documentation will help you and others to understand the reason for
the <span style="font-family:monospace">@SuppressWarnings</span> annotation. It will also help if you decide to
audit your code to verify all the warning suppressions.</p>
<!--TOC section id="assumeassertion" <span style="font-family:monospace">@AssumeAssertion</span> string in an <span style="font-family:monospace">assert</span> message-->
<h2 id="assumeassertion" class="section">24.2&#XA0;&#XA0;<span style="font-family:monospace">@AssumeAssertion</span> string in an <span style="font-family:monospace">assert</span> message</h2><!--SEC END --><p>
You can suppress a warning by <span style="font-family:monospace">assert</span>ing that some property is true, and
placing the string <span style="font-family:monospace">@AssumeAssertion(</span><span style="font-family:monospace"><em>warningkey</em></span><span style="font-family:monospace">)</span> in the assertion
message.
</p><p>For example, in this code:</p><pre class="verbatim">  assert x != null : "@AssumeAssertion(nullness)";
  ... x.f ...
</pre><p>the Nullness Checker assumes that <span style="font-family:monospace">x</span> is non-null from the <span style="font-family:monospace">assert</span>
statement forward, and so the expression <span style="font-family:monospace">x.f</span> cannot throw a null pointer
exception.</p><p>The <span style="font-family:monospace">assert</span> expression must be an expression that would affect flow-sensitive
type qualifier refinement (Section&#XA0;<a href="#type-refinement">23.4</a>), if the
expression appeared in a conditional test. Each type system has its own
rules about what type refinement it performs.</p><p>The warning key is exactly as in the <span style="font-family:monospace">@SuppressWarnings</span> annotation
(Section&#XA0;<a href="#suppresswarnings-annotation">24.1</a>). The same good practices apply
as for <span style="font-family:monospace">@SuppressWarnings</span> annotations, such as writing a comment
justifying why the assumption is safe
(Section&#XA0;<a href="#suppresswarnings-best-practices">24.1.3</a>).</p><p>The <span style="font-family:monospace">-AassumeAssertionsAreEnabled</span> and <span style="font-family:monospace">-AassumeAssertionsAreDisabled</span>
command-line options (Section&#XA0;<a href="#type-refinement-assertions">23.4.6</a>) do not
affect processing of <span style="font-family:monospace">assert</span> statements that have <span style="font-family:monospace">@AssumeAssertion</span> in
their message. Writing <span style="font-family:monospace">@AssumeAssertion</span> means that the assertion would
succeed if it were executed, and the Checker Framework makes use of that
information regardless of the <span style="font-family:monospace">-AassumeAssertionsAreEnabled</span> and
<span style="font-family:monospace">-AassumeAssertionsAreDisabled</span> command-line options.</p>
<!--TOC subsection id="defensive-programming" Suppressing warnings and defensive programming-->
<h3 id="defensive-programming" class="subsection">24.2.1&#XA0;&#XA0;Suppressing warnings and defensive programming</h3><!--SEC END --><p>This section explains the distinction between two different uses for
assertions (and for related methods like JUnit&#X2019;s <span style="font-family:monospace">Assert.assertNotNull</span>).</p><p>Assertions are commonly used for two distinct purposes: documenting how
the program works and debugging the program when it does not work
correctly. By default, the Checker Framework assumes that each assertion
is used for debugging: the assertion might fail at run time, and the programmer
wishes to be informed at compile time about such run-time errors. On the
other hand, if you write the <span style="font-family:monospace">@AssumeAssertion</span> string in the <span style="font-family:monospace">assert</span>
message, then the Checker Framework assumes that you have used some other
technique to verify that the assertion can never fail at run time, so the
checker assumes the assertion passes and does not issue a warning.</p><p>Distinguishing the purpose of each assertion is important for precise
type-checking.
Suppose that a
programmer encounters a failing test, adds an assertion to aid debugging, and fixes the
test. The programmer leaves the assertion in the program if the programmer
is worried that the program might fail in a similar way in the future.
The Checker Framework should not assume that the assertion succeeds &#X2014;
doing so would defeat the very purpose of the Checker Framework, which is
to detect errors at compile time and prevent them from occurring at run
time.</p><p>On the other hand, assertions sometimes document facts that a programmer
has independently verified to be true, and the Checker Framework can
leverage these assertions in order to avoid issuing false positive
warnings. The programmer marks such assertions with the <span style="font-family:monospace">@AssumeAssertion</span>
string in the <span style="font-family:monospace">assert</span> message. Only do so if you are sure
that the assertion always succeeds at run time.</p><p>Sometimes methods such as
<a href="api/org/checkerframework/checker/nullness/NullnessUtils.html#castNonNull-T-"><span style="font-family:monospace">NullnessUtils.castNonNull</span></a> are used
instead of assertions. Just as for assertions, you can treat them as
debugging aids or as documentation.
If you know that a particular codebase uses
a nullness-checking method not for defensive programming but to indicate
facts that are guaranteed to be true (that is, these assertions will never
fail at run time), then you can suppress
warnings related to it.
Annotate its definition just as
<a href="api/org/checkerframework/checker/nullness/NullnessUtils.html#castNonNull-T-"><span style="font-family:monospace">NullnessUtils.castNonNull</span></a> is annotated (see the
source code for the Checker Framework).
Also, be sure to document the intention in the method&#X2019;s Javadoc, so that
programmers do not
accidentally misuse it for defensive programming.</p><p>If you are annotating a codebase that already contains precondition checks,
such as:</p><pre class="verbatim">  public String get(String key, String def) {
    checkNotNull(key, "key"); //NOI18N
    ...
  }
</pre><p>then you should mark the appropriate parameter as <span style="font-family:monospace">@NonNull</span> (which is the
default). This will prevent the checker from issuing a warning about the
<span style="font-family:monospace">checkNotNull</span> call.</p>
<!--TOC section id="suppresswarnings-command-line" <span style="font-family:monospace">-AsuppressWarnings</span> command-line option-->
<h2 id="suppresswarnings-command-line" class="section">24.3&#XA0;&#XA0;<span style="font-family:monospace">-AsuppressWarnings</span> command-line option</h2><!--SEC END --><p>Supplying the <span style="font-family:monospace">-AsuppressWarnings</span> command-line option is equivalent to
writing a <span style="font-family:monospace">@SuppressWarnings</span> annotation on every class that the compiler
type-checks. The argument to <span style="font-family:monospace">-AsuppressWarnings</span> is a comma-separated
list of warning suppression keys, as in
<span style="font-family:monospace">-AsuppressWarnings=purity,uninitialized</span>.</p><p>When possible, it is better to write a <span style="font-family:monospace">@SuppressWarnings</span> annotation with a
smaller scope, rather than using the <span style="font-family:monospace">-AsuppressWarnings</span> command-line option.</p>
<!--TOC section id="askipuses" <span style="font-family:monospace">-AskipUses</span> and <span style="font-family:monospace">-AonlyUses</span> command-line options-->
<h2 id="askipuses" class="section">24.4&#XA0;&#XA0;<span style="font-family:monospace">-AskipUses</span> and <span style="font-family:monospace">-AonlyUses</span> command-line options</h2><!--SEC END --><p>You can suppress all errors and warnings at all <em>uses</em> of a given
class, or suppress all errors and warnings except those at uses of a given
class. (The class itself is still type-checked, unless you also use
the <span style="font-family:monospace">-AskipDefs</span> or <span style="font-family:monospace">-AonlyDefs</span> command-line option, see&#XA0;<a href="#askipdefs">24.5</a>).</p><p>Set the <span style="font-family:monospace">-AskipUses</span> command-line option to a
regular expression that matches class names (not file names) for which warnings and errors
should be suppressed.
Or, set the <span style="font-family:monospace">-AonlyUses</span> command-line option to a
regular expression that matches class names (not file names) for which warnings and errors
should be emitted; warnings about uses of all other classes will be suppressed.</p><p>For example, suppose that you use
&#X201C;<code>-AskipUses=^java\.</code>&#X201D; on the command line
(with appropriate quoting) when invoking
<span style="font-family:monospace">javac</span>. Then the checkers will suppress all warnings related to
classes whose fully-qualified name starts with <code>java.</code>, such
as all warnings relating to invalid arguments and all warnings relating to
incorrect use of the return value.</p><p>To suppress all errors and warnings related to multiple classes, you can use
the regular expression alternative operator &#X201C;<span style="font-family:monospace">|</span>&#X201D;, as in
&#X201C;<code>-AskipUses="java\.lang\.|java\.util\."</code>&#X201D; to suppress
all warnings related to uses of classes belong to the <span style="font-family:monospace">java.lang</span> or
<span style="font-family:monospace">java.util</span> packages.</p><p>You can supply both <span style="font-family:monospace">-AskipUses</span> and <span style="font-family:monospace">-AonlyUses</span>, in which case
the <span style="font-family:monospace">-AskipUses</span> argument takes precedence, and <span style="font-family:monospace">-AonlyUses</span> does
further filtering but does not add anything that <span style="font-family:monospace">-AskipUses</span> removed.</p><p>Warning: Use the <span style="font-family:monospace">-AonlyUses</span> command-line option with care,
because it can have unexpected results. For example, if the
given regular expression does not match classes in the JDK, then the
Checker Framework will suppress every warning that involves a JDK class
such as <span style="font-family:monospace">Object</span> or <span style="font-family:monospace">String</span>. The meaning of <span style="font-family:monospace">-AonlyUses</span> may be
refined in the future. Oftentimes <span style="font-family:monospace">-AskipUses</span> is more useful.</p>
<!--TOC section id="askipdefs" <span style="font-family:monospace">-AskipDefs</span> and <span style="font-family:monospace">-AonlyDefs</span> command-line options-->
<h2 id="askipdefs" class="section">24.5&#XA0;&#XA0;<span style="font-family:monospace">-AskipDefs</span> and <span style="font-family:monospace">-AonlyDefs</span> command-line options</h2><!--SEC END --><p>You can suppress all errors and warnings in the <em>definition</em> of a given
class, or suppress all errors and warnings except those in the definition
of a given class. (Uses of the class are still type-checked, unless you also use
the <span style="font-family:monospace">-AskipUses</span> or <span style="font-family:monospace">-AonlyUses</span> command-line option,
see&#XA0;<a href="#askipuses">24.4</a>).</p><p>Set the <span style="font-family:monospace">-AskipDefs</span> command-line option to a
regular expression that matches class names (not file names) in whose definition warnings and errors
should be suppressed.
Or, set the <span style="font-family:monospace">-AonlyDefs</span> command-line option to a
regular expression that matches class names (not file names) whose
definitions should be type-checked.</p><p>For example, if you use
&#X201C;<code>-AskipDefs=^mypackage\.</code>&#X201D; on the command line
(with appropriate quoting) when invoking
<span style="font-family:monospace">javac</span>, then the definitions of
classes whose fully-qualified name starts with <code>mypackage.</code>
will not be checked.</p><p>If you supply both <span style="font-family:monospace">-AskipDefs</span> and <span style="font-family:monospace">-AonlyDefs</span>, then
<span style="font-family:monospace">-AskipDefs</span> takes precedence.</p><p>Another way not to type-check a file is not to pass it on the compiler
command-line: the Checker Framework type-checks only files that are passed
to the compiler on the command line, and does not type-check any file that
is not passed to the compiler. The <span style="font-family:monospace">-AskipDefs</span> and <span style="font-family:monospace">-AonlyDefs</span>
command-line options
are intended for situations in which the build system is hard to understand
or change. In such a situation, a programmer may find it easier to supply
an extra command-line argument, than to change the set of files that is
compiled.</p><p>A common scenario for using the arguments is when you are starting out by
type-checking only part of a legacy codebase. After you have verified the
most important parts, you can incrementally check more classes until you
are type-checking the whole thing.</p>
<!--TOC section id="alint" <span style="font-family:monospace">-Alint</span> command-line option-->
<h2 id="alint" class="section">24.6&#XA0;&#XA0;<span style="font-family:monospace">-Alint</span> command-line option</h2><!--SEC END --><p><a id="lint-options"></a></p><p>The <span style="font-family:monospace">-Alint</span> option enables or disables optional checks, analogously to
javac&#X2019;s <span style="font-family:monospace">-Xlint</span> option.
Each of the distributed checkers supports at least the following lint options:</p><ul class="itemize"><li class="li-itemize"><span style="font-family:monospace">cast:unsafe</span> (default: on) warn about unsafe casts that are not
checked at run time, as in <span style="font-family:monospace">((@NonNull String) myref)</span>. Such casts
are generally not necessary when flow-sensitive local type refinement is
enabled.</li><li class="li-itemize"><span style="font-family:monospace">cast:redundant</span> (default: on) warn about redundant
casts that are guaranteed to succeed at run time,
as in <span style="font-family:monospace">((@NonNull String) "m")</span>. Such casts are not necessary,
because the target expression of the cast already has the given type
qualifier.</li><li class="li-itemize"><span style="font-family:monospace">cast</span> Enable or disable all cast-related warnings.</li><li class="li-itemize">
<span style="font-family:monospace">all</span> Enable or disable all lint warnings, including
checker-specific ones if any. Examples include <span style="font-family:monospace">redundantNullComparison</span> for the
Nullness Checker (see Section&#XA0;<a href="#lint-nulltest-section">3.1</a>) and <span style="font-family:monospace">dotequals</span> for
the Interning Checker (see Section&#XA0;<a href="#lint-dotequals">5.3</a>). This option
does not enable/disable the checker&#X2019;s standard checks, just its optional
ones.
</li><li class="li-itemize"><span style="font-family:monospace">none</span> The inverse of <span style="font-family:monospace">all</span>: disable or enable all lint warnings,
including checker-specific ones if any.</li></ul><p>To activate a lint option, write <span style="font-family:monospace">-Alint=</span> followed by a
comma-delimited list of check names. If the option is preceded by a
hyphen (<span style="font-family:monospace">-</span>), the warning is disabled. For example, to disable all
lint options except redundant casts, you can pass
<span style="font-family:monospace">-Alint=-all,cast:redundant</span> on the command line.</p><p>Only the last <span style="font-family:monospace">-Alint</span> option is used; all previous <span style="font-family:monospace">-Alint</span>
options are silently ignored. In particular, this means that <span style="font-family:monospace">-Alint=all
-Alint=cast:redundant</span> is <em>not</em> equivalent to
<span style="font-family:monospace">-Alint=-all,cast:redundant</span>.</p>
<!--TOC section id="no-processor" No <span style="font-family:monospace">-processor</span> command-line option-->
<h2 id="no-processor" class="section">24.7&#XA0;&#XA0;No <span style="font-family:monospace">-processor</span> command-line option</h2><!--SEC END --><p>You can also compile parts of your code without use of the
<span style="font-family:monospace">-processor</span> switch to <span style="font-family:monospace">javac</span>. No checking is done during
such compilations, so no warnings are issued related to pluggable
type-checking.</p>
<!--TOC section id="checker-specific-suppression" Checker-specific mechanisms-->
<h2 id="checker-specific-suppression" class="section">24.8&#XA0;&#XA0;Checker-specific mechanisms</h2><!--SEC END --><p>Finally, some checkers have special rules. For example, the Nullness
checker (Chapter&#XA0;<a href="#nullness-checker">3</a>) uses
the special <span style="font-family:monospace">castNonNull</span> method to suppress warnings
(Section&#XA0;<a href="#suppressing-warnings-with-assertions">3.4.1</a>).
This manual also explains special mechanisms for
suppressing warnings issued by the Fenum Checker
(Section&#XA0;<a href="#fenum-suppressing">7.4</a>) and the Units Checker
(Section&#XA0;<a href="#units-suppressing">15.5</a>).</p><hr>
<!--TOC chapter id="legacy-code" Handling legacy code-->
<h1 id="legacy-code" class="chapter">Chapter&#XA0;25&#XA0;&#XA0;Handling legacy code</h1><!--SEC END --><p>Section&#XA0;<a href="#get-started-with-legacy-code">2.4.1</a> describes a methodology for
applying annotations to legacy code. This chapter tells you what to do if,
for some reason, you cannot change your code in such a way as to eliminate
a checker warning.</p><p>Also recall that you can convert checker errors into warnings via the
<span style="font-family:monospace">-Awarns</span> command-line option; see Section&#XA0;<a href="#checker-options">2.2.2</a>.</p>
<!--TOC section id="unannotated-code" Checking partially-annotated programs: handling unannotated code-->
<h2 id="unannotated-code" class="section">25.1&#XA0;&#XA0;Checking partially-annotated programs: handling unannotated code</h2><!--SEC END --><p>Sometimes, you wish to type-check only part of your program.
You might focus on the most mission-critical or error-prone part of your
code. When you start to use a checker, you may not wish to annotate
your entire program right away.
You may not have
enough knowledge to annotate poorly-documented libraries that your program uses.</p><p>If annotated code uses unannotated code, then the checker may issue
warnings. For example, the Nullness Checker (Chapter&#XA0;<a href="#nullness-checker">3</a>) will
warn whenever an unannotated method result is used in a non-null context:</p><pre class="verbatim">  @NonNull myvar = unannotated_method();   // WARNING: unannotated_method may return null
</pre><p>If the call <em>can</em> return null, you should fix the bug in your program by
removing the <a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a> annotation in your own program.</p><p>If the library call <em>never</em> returns null,
there are several ways to eliminate the compiler warnings.
</p><ol class="enumerate" type=1><li class="li-enumerate">
Annotate <span style="font-family:monospace">unannotated_method</span> in full. This approach provides
the strongest guarantees, but may require you to annotate additional
methods that <span style="font-family:monospace">unannotated_method</span> calls. See
Chapter&#XA0;<a href="#annotating-libraries">27</a> for a discussion of how to annotate
libraries for which you have no source code.
</li><li class="li-enumerate">Annotate only the signature of <span style="font-family:monospace">unannotated_method</span>, and
suppress warnings in its body. Two ways to suppress the warnings are via a
<span style="font-family:monospace">@SuppressWarnings</span> annotation or by not running the checker on that
file (see Section&#XA0;<a href="#suppressing-warnings">24</a>).
</li><li class="li-enumerate">Suppress all warnings related to uses of <span style="font-family:monospace">unannotated_method</span>
via the <span style="font-family:monospace">skipUses</span> processor option
(see Section&#XA0;<a href="#askipuses">24.4</a>).
Since this can suppress more warnings than you may expect,
it is usually better to annotate at least the method&#X2019;s signature. If you
choose the boundary between the annotated and unannotated code wisely,
then you only have to annotate the signatures of a limited number of
classes/methods
(e.g., the public interface to a library or package).</li></ol><p>Chapter&#XA0;<a href="#annotating-libraries">27</a> discusses adding annotations to
signatures when you do not have source code available.
Section&#XA0;<a href="#suppressing-warnings">24</a> discusses suppressing warnings.</p>
<!--TOC section id="backward-compatibility" Backward compatibility with earlier versions of Java-->
<h2 id="backward-compatibility" class="section">25.2&#XA0;&#XA0;Backward compatibility with earlier versions of Java</h2><!--SEC END --><p>Sometimes, your code needs to be <em>compiled</em> by people who are using a
Java 5/6/7 compiler, which does not support type annotations.
You can handle this situation by writing annotations in comments (Sections&#XA0;<a href="#annotations-in-comments">25.2.1</a>&#X2013;<a href="#uncommenting-annotations">25.2.3</a>).</p><p>If your code just needs to be <em>run</em> by people who are not using a Java
8 JVM, supply an appropriate <span style="font-family:monospace">-target</span> command-line option to javac. As
discussed in Section&#XA0;<a href="#no-modular-type-checking-java7-jvm">25.2.4</a>, the
disadvantage is that this makes it more difficult for clients of your
library to use pluggable type-checking to verify their own code against the
<span style="font-family:monospace">.class</span> or <span style="font-family:monospace">.jar</span> files that you supply;
Section&#XA0;<a href="#declaration-annotations-for-java7">25.2.5</a> gives a partial solution.</p>
<!--TOC subsection id="annotations-in-comments" Annotations in comments-->
<h3 id="annotations-in-comments" class="subsection">25.2.1&#XA0;&#XA0;Annotations in comments</h3><!--SEC END --><p>A Java 4 compiler does not permit use of
annotations.
A Java 5/6/7 compiler only permits annotations on
declarations &#X2014; it does not permit annotations on generic arguments,
casts, <span style="font-family:monospace">extends</span> clauses, method receivers, etc.</p><p>So that your code can be compiled by any Java compiler (for any version of
the Java language), you may write any single annotation inside a
<span style="font-family:monospace">/*</span>&#X2026;<span style="font-family:monospace">*/</span> Java comment, as in <span style="font-family:monospace">List&lt;/*@NonNull*/ String&gt;</span>.
The Checker Framework compiler treats the code exactly as if you had not written the
<span style="font-family:monospace">/*</span> and <span style="font-family:monospace">*/</span>.
In other words, the Checker Framework compiler will recognize the
annotation (when it is targeting a Java 8 or later JVM),
but your code will still compile with any Java compiler.</p><p>
By default, the Checker Framework compiler ignores any comment that contains spaces at the
beginning or end, or between the <span style="font-family:monospace">@</span> and the annotation name.
In other words, it reads <span style="font-family:monospace">/*@NonNull*/</span> as an annotation but ignores
<span style="font-family:monospace">/* @NonNull*/</span> and <span style="font-family:monospace">/*@ NonNull*/</span> and <span style="font-family:monospace">/*@NonNull */</span>.
This
feature enables backward compatibility with code that contains comments
that start with <span style="font-family:monospace">@</span> but are not annotations. (The
ESC/Java&#XA0;[<a href="#FlanaganLLNSS02">FLL+02</a>], JML&#XA0;[<a href="#LeavensBR2006%3AJML">LBR06</a>], and
Splint&#XA0;[<a href="#Evans96">Eva96</a>] tools all use &#X201C;<span style="font-family:monospace">/*@</span>&#X201D; or &#X201C;<span style="font-family:monospace">/*&#XA0;@</span>&#X201D; as a
comment marker.)
Compiler flag
<span style="font-family:monospace">-XDTA:spacesincomments</span> causes the compiler to parse annotation comments
even when they contain spaces. You may need to use
<span style="font-family:monospace">-XDTA:spacesincomments</span> if you use Eclipse&#X2019;s &#X201C;Source &gt; Correct
Indentation&#X201D; command, since it inserts space in comments. But the
annotation comments are less readable with spaces, so it&#X2019;s even better to disable
inserting spaces: in the Formatter preferences, in the Comments tab,
unselect the &#X201C;enable block comment formatting&#X201D; checkbox.
</p><p>Compiler flag <span style="font-family:monospace">-XDTA:noannotationsincomments</span> causes the compiler
to ignore annotation comments. With this compiler flag, the
Checker Framework compiler behaves like a standard Java 8 compiler that does
not support annotations in comments. If your code already contains
comments of the form <span style="font-family:monospace">/*@...*/</span> that look like type annotations, and
you want the Checker Framework compiler not to try to interpret them,
then you can either selectively add spaces to the comments or use
<span style="font-family:monospace">-XDTA:noannotationsincomments</span> to turn off all annotation
comments.</p><p><span style="font-weight:bold">Note:</span> Annotations in comments is a feature of the javac compiler
that is
distributed along with the Checker Framework. It is <em>not</em>
supported by the mainline OpenJDK javac. This is the key
difference between the Checker Framework compiler and the OpenJDK compiler.</p>
<!--TOC subsubsection id="annotations-in-java7-class-files" Annotations in comments do not appear in Java 5/6/7 <span style="font-family:monospace">.class</span> files-->
<h4 id="annotations-in-java7-class-files" class="subsubsection">Annotations in comments do not appear in Java 5/6/7 <span style="font-family:monospace">.class</span> files</h4><!--SEC END --><p>The Checker Framework compiler ignores annotations in comments when
targeting a Java 5/6/7 JVM, for example when the <span style="font-family:monospace">-target 7</span> command-line
option is supplied.</p><p>It would be possible for the Checker Framework compiler to read the
annotations in comments and place them in the Java 5/6/7 <span style="font-family:monospace">.class</span> file so
that they are available when type-checking client code. However, this
would have two problems. First, it would only be use useful to the Checker
Framework compiler, because a standard Java 8 compiler will not look for
type annotations in Java 5/6/7 bytecode. Second, the type annotations
make reference to parts of the Java 8 JDK, such as
<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/ElementType.html#TYPE_USE"><span style="font-family:monospace">ElementType.TYPE_USE</span></a>.
Therefore, trying to run the <span style="font-family:monospace">.class</span> file on a Java 5/6/7 JVM
would cause warnings or crashes.</p>
<!--TOC subsection id="receivers-and-imports-in-comments" Import statements and receiver parameters in comments-->
<h3 id="receivers-and-imports-in-comments" class="subsection">25.2.2&#XA0;&#XA0;Import statements and receiver parameters in comments</h3><!--SEC END --><p>There is a more powerful mechanism that permits arbitrary code to be
written in a comment. Format the comment as &#X201C;<span style="font-family:monospace">/*&gt;&gt;&gt;</span>&#X2026;<span style="font-family:monospace">*/</span>&#X201D;,
with the first three characters of the comment being greater-than signs. As
with annotations in comments, the commented code is ignored by ordinary
compilers but is treated like code by the
Checker Framework compiler.</p><p>This mechanism is intended for two purposes.
First, it supports the receiver (<span style="font-family:monospace">this</span> parameter) syntax. For example,
to specify a method whose receiver may incorporate unvalidated information
read from an untrusted external source:</p><pre class="verbatim">public boolean method1(/*&gt;&gt;&gt; @Tainted MyClass this*/) { ... }
public boolean method2(/*&gt;&gt;&gt; @Tainted MyClass this, */ String argument) { ... }
</pre><p>Second, it can be used for import statements:</p><pre class="verbatim">/*&gt;&gt;&gt;
import org.checkerframework.checker.nullness.qual.*;
import org.checkerframework.checker.regex.qual.*;
*/
</pre><p>If the import statements are <em>not</em> commented out, then every time you
compile the code (even when not doing pluggable type-checking),
the annotation definitions (e.g., the <span style="font-family:monospace">checker.jar</span>
or <span style="font-family:monospace">checker-qual.jar</span> file) must be on the classpath.
(This is done automatically if you use the Checker Framework compiler.)
Commenting out the import statements also eliminates Eclipse
warnings about unused import statements, if all uses of the imported
qualifier are themselves in comments and thus invisible to Eclipse.</p><p>A third use is for writing multiple annotations inside one
comment, as in <span style="font-family:monospace">/*&gt;&gt;&gt; @NonNull @Interned */ String s;</span>.
However, it is better style to write multiple annotations each
inside its own comment, as in <span style="font-family:monospace">/*@NonNull*/ /*@Interned*/ String s;</span>.</p><p>It would be possible to abuse the <span style="font-family:monospace">/*&gt;&gt;&gt;...*/</span> mechanism to inject
code only when using
the Checker Framework compiler. Doing so is not a sanctioned use of the
mechanism.</p>
<!--TOC subsection id="uncommenting-annotations" Migrating away from annotations in comments-->
<h3 id="uncommenting-annotations" class="subsection">25.2.3&#XA0;&#XA0;Migrating away from annotations in comments</h3><!--SEC END --><p>Suppose that your codebase currently uses annotations in comments, but you
wish to remove the comment characters around your annotations, because in
the future you will use only compilers that support type annotations and
your code will only run on Java 8 or later JVMs.
This Unix command removes
the comment characters, for all Java files in the current
working directory or any subdirectory.</p><pre class="verbatim">   find . -type f -name '*.java' -print \
     | xargs grep -l -P '/\*\s*@([^ */]+)\s*\*/' \
     | xargs perl -pi.bak -e 's|/\*\s*@([^ */]+)\s*\*/|@\1|g'
</pre><p>You can customize this command:
</p><ul class="itemize"><li class="li-itemize">
To process comments with embedded spaces and asterisks, change
two instances of &#X201C;<code>[^ */]</code>&#X201D; to &#X201C;<code>[^/]</code>&#X201D;.
</li><li class="li-itemize">To ignore comments with leading or trailing spaces, remove the four
instances of &#X201C;<code>\s*</code>&#X201D;.
</li><li class="li-itemize">To not make backups, remove &#X201C;<code>.bak</code>&#X201D;.
</li></ul><p>The command does not handle the <span style="font-family:monospace">&gt;&gt;&gt;</span> comments; you will need to
adapt the above command to do so, or remove them in another way.</p>
<!--TOC subsection id="no-modular-type-checking-java7-jvm" No modular type-checking when targeting Java 5/6/7-->
<h3 id="no-modular-type-checking-java7-jvm" class="subsection">25.2.4&#XA0;&#XA0;No modular type-checking when targeting Java 5/6/7</h3><!--SEC END --><p>The Checker Framework&#X2019;s type annotations utilize a Java 8 feature that
allows them to be placed on any type use, including generic type parameters
as in <span style="font-family:monospace">List&lt;@NonNull String&gt;</span>. A downside is that use of these type
annotations creates a dependency on Java 8, which means that the compiled
program requires a Java 8 or later JDK at run time.</p><p>To ensure that your program can run on a Java 5/6/7 JVM, use a command-line
option such as <span style="font-family:monospace">-target 7</span> when doing normal compilation to produce
classfiles. Before doing so, you will do pluggable type-checking, using the
<span style="font-family:monospace">-target 8</span> command-line option (or no <span style="font-family:monospace">-target</span> command-line option) to
javac; you may wish to supply the <span style="font-family:monospace">-proc:only</span> command-line argument so
that the type-checking step does not overwrite existing classfiles.</p><p>Here are the disadvantages of this approach:</p><ul class="itemize"><li class="li-itemize">
It produces classfiles that contain no trace of your type annotations.
This means that modular type-checking (also known as separate compilation)
is not possible.<p>You need to compile your entire application every time you
do pluggable type-checking, rather than just compiling a subset of the
files. Furthermore, clients of your code cannot do pluggable
type-checking to verify that they are using your code correctly, unless
they re-compile your code (or at least all the interfaces that they use)
every time that they compile their own.</p></li><li class="li-itemize">It makes pluggable type-checking a
different step than &#X201C;real&#X201D; compilation, rather than both happening at the
same time. You will do pluggable type-checking first, and when it works or
when you want to create a binary to distribute to others, you will compile
with an ordinary Java compiler.
</li></ul><p>One way to enable clients to do pluggable type-checking is to provide a
version of your library compiled for Java 8 or later, with the type
annotations. Clients will do type-checking against this version of the
library, but will do normal compilation and execution using the Java 5, 6,
or 7 version of your library.</p><p>Section&#XA0;<a href="#declaration-annotations-for-java7">25.2.5</a> gives an alternative
approach with its own advantages and disadvantages.</p>
<!--TOC subsection id="declaration-annotations-for-java7" Distributing declaration annotations instead of type annotations-->
<h3 id="declaration-annotations-for-java7" class="subsection">25.2.5&#XA0;&#XA0;Distributing declaration annotations instead of type annotations</h3><!--SEC END --><p>If it is important to you to distribute Java 5/6/7 classfiles against which
clients can do some type-checking, this section gives a way to do so.</p><p>The idea is to
use annotations that are Java 5/6/7 declaration annotations.
This approach requires you to use annotations that are declared in
different packages than usual and that have slightly different names.</p><ul class="itemize"><li class="li-itemize">
At code locations that are legal for both declaration and type
annotations (such as for fields, method returns, and method parameters),
write annotations normally (not in comments).
</li><li class="li-itemize">At locations where a declaration annotation is not permitted
(such as generic type parameters and <span style="font-family:monospace">extends</span> clauses), write
annotations in comments.
</li></ul><p>Here are some disadvantages of this approach:</p><ul class="itemize"><li class="li-itemize">
You need to use nonstandard names for
some annotations, and to remember which annotations to write in comments
and which to write normally.
</li><li class="li-itemize">It produces classfiles that contain only some of your type annotations
&#X2014; the ones that were not written in comments.
If your code uses type annotations at
locations such as generic type parameters and <span style="font-family:monospace">extends</span> clauses, then
modular type-checking will not observe them;
the implications of that were described above.
</li></ul><p>Here are more details about the approach.
Suppose you wish to run the Nullness Checker using Java 6 or 7
declaration annotations rather than type annotations. You have two options.</p><ol class="enumerate" type=1><li class="li-enumerate">
At locations where declaration annotations are possible,
use aliased annotations from other projects. For example, the aliased
annotations for the Nullness Checker are listed in
Section&#XA0;<a href="#nullness-related-work">3.7</a>.<p>
At locations where only type annotations are possible, use the
&#X201C;<span style="font-family:monospace">*Type</span>&#X201D; compatibility annotations from package
<span style="font-family:monospace">org.checkerframework.checker.nullness.compatqual</span>
in comments. For example, the Nullness Checker
declares these declaration annotations:
<a href="api/org/checkerframework/checker/nullness/compatqual/NullableType.html"><span style="font-family:monospace">@NullableType</span></a>,
<a href="api/org/checkerframework/checker/nullness/compatqual/NonNullType.html"><span style="font-family:monospace">@NonNullType</span></a>,
<a href="api/org/checkerframework/checker/nullness/compatqual/PolyNullType.html"><span style="font-family:monospace">@PolyNullType</span></a>,
<a href="api/org/checkerframework/checker/nullness/compatqual/MonotonicNonNullType.html"><span style="font-family:monospace">@MonotonicNonNullType</span></a>, and
<a href="api/org/checkerframework/checker/nullness/compatqual/KeyForType.html"><span style="font-family:monospace">@KeyForType</span></a>.
</p></li><li class="li-enumerate">At locations where declaration annotations are possible,
use &#X201C;<span style="font-family:monospace">*Decl</span>&#X201D; compatibility annotations from package
<span style="font-family:monospace">org.checkerframework.checker.nullness.compatqual</span>.
For example, the Nullness Checker
declares these declaration annotations:
<a href="api/org/checkerframework/checker/nullness/compatqual/NullableDecl.html"><span style="font-family:monospace">@NullableDecl</span></a>,
<a href="api/org/checkerframework/checker/nullness/compatqual/NonNullDecl.html"><span style="font-family:monospace">@NonNullDecl</span></a>,
<a href="api/org/checkerframework/checker/nullness/compatqual/PolyNullDecl.html"><span style="font-family:monospace">@PolyNullDecl</span></a>,
<a href="api/org/checkerframework/checker/nullness/compatqual/MonotonicNonNullDecl.html"><span style="font-family:monospace">@MonotonicNonNullDecl</span></a>, and
<a href="api/org/checkerframework/checker/nullness/compatqual/KeyForDecl.html"><span style="font-family:monospace">@KeyForDecl</span></a>.<p>At locations where only type annotations are possible, use the regular
Checker Framework type annotations in comments.
</p></li></ol><p>Notice that in each case, the declaration annotations and type annotations
have distinct names. This enables a programmer to import both sets of
annotations without a name conflict. But, you must remember to use the
correct name, depending on where the annotations are written.</p><p>Eventually, when backward compatibility with Java 7 and earlier is not important,
you should refactor your codebase to use only the regular Checker Framework
annotations, and not to write them in comments.</p><hr>
<!--TOC chapter id="type-inference" Type inference-->
<h1 id="type-inference" class="chapter">Chapter&#XA0;26&#XA0;&#XA0;Type inference</h1><!--SEC END --><p>There are two different tasks that are commonly called &#X201C;type inference&#X201D;:
</p><ol class="enumerate" type=1><li class="li-enumerate">
Type inference during type-checking:
The type-checker fills in an appropriate type where the programmer didn&#X2019;t
write one, but does not change the source code.
See Section&#XA0;<a href="#type-inference-refinement">26.1</a>.
</li><li class="li-enumerate">Type inference to annotate a program:
As a separate step before type-checking, a type inference tool
inserts type qualifiers into the source code.
See Section&#XA0;<a href="#type-inference-to-annotate">26.2</a>.
</li></ol><p>Each variety has its own advantages, discussed below.
Advantages of <em>all</em> varieties of type inference include:
</p><ul class="itemize"><li class="li-itemize">
Less work for the programmer.
</li><li class="li-itemize">The tool chooses the most general type, whereas a programmer might
accidentally write a more-specific, less-generally-useful annotation.
</li></ul>
<!--TOC section id="type-inference-refinement" Local type inference during type-checking-->
<h2 id="type-inference-refinement" class="section">26.1&#XA0;&#XA0;Local type inference during type-checking</h2><!--SEC END --><p>During type-checking, if certain variables have no type qualifier, the
type-checker determines whether there is some type qualifier that would
permit the program to type-check. If so, the type-checker uses that type
qualifier, but does not change the source code. Each time the
type-checker runs, it re-infers the type qualifier for that variable. If
no type qualifier exists that permits the program to type-check, the
type-checker issues a warning.</p><p>Local type inference is built into the Checker Framework.
Every checker automatically uses it. As a result, a programmer typically
does not have to write any qualifiers inside the body of a method.
However, it primarily
works within a method, not across method boundaries.
The source code must already contain annotations for method
signatures (arguments and return values) and fields.</p><p>Advantages of this variety of type inference include:
</p><ul class="itemize"><li class="li-itemize">
If the type qualifier is obvious to the programmer, then omitting it
can reduce annotation clutter in the program.
</li><li class="li-itemize">If the code changes, then there is no old annotation that
might need to be updated.
</li><li class="li-itemize">Within-method type inference occurs automatically.
The programmer doesn&#X2019;t have to do anything to take advantage of it.
</li></ul><p>For more details about local type inference during type-checking, also
known as &#X201C;flow-sensitive local type refinement&#X201D;, see
Section&#XA0;<a href="#type-refinement">23.4</a>.</p>
<!--TOC section id="type-inference-to-annotate" Type inference to annotate a program-->
<h2 id="type-inference-to-annotate" class="section">26.2&#XA0;&#XA0;Type inference to annotate a program</h2><!--SEC END --><p>As a separate step before type-checking, a type inference tool takes the
program as input, and outputs a set of type qualifiers that would
make the program type-check. (If no such set exists, for example because
the program is not type-correct, then the inference tool does its best but
makes no guarantees.)
These qualifiers are inserted into the source code or the
class file. They can be viewed and adjusted by the programmer, and can
be used by tools such as the type-checker.</p><p>Advantages of this variety of type inference include:
</p><ul class="itemize"><li class="li-itemize">
The inference may be more precise by taking account of the entire program
rather than just reasoning one method at a time.
</li><li class="li-itemize">The program source code contains documentation in the form of type
qualifiers, which can aid programmer understanding and may make
type-checking warnings more comprehensible.
</li></ul>
<!--TOC subsection id="type-inference-tools" Type inference tools-->
<h3 id="type-inference-tools" class="subsection">26.2.1&#XA0;&#XA0;Type inference tools</h3><!--SEC END --><p>This section lists tools that take a program and output a set of
annotations for it.
It first lists tools that work only for a single type system (but may do a
more accurate job for that type system)
then lists general tools that work for any type system.</p>
<!--TOC subsubsection id="type-inference-tools-specialized" Type inference for specific type systems-->
<h4 id="type-inference-tools-specialized" class="subsubsection">Type inference for specific type systems</h4><!--SEC END --><p>Section&#XA0;<a href="#nullness-inference">3.3.7</a> lists several tools that infer
annotations for the Nullness Checker.</p><p>If you run the Checker Framework with the <span style="font-family:monospace">-AsuggestPureMethods</span>
command-line option, it will suggest methods that can be marked as
<span style="font-family:monospace">@SideEffectFree</span>, <span style="font-family:monospace">@Deterministic</span>, or <span style="font-family:monospace">@Pure</span>; see
Section&#XA0;<a href="#type-refinement-purity">23.4.5</a>.</p>
<!--TOC subsubsection id="type-inference-tools-general" Type inference for any type system-->
<h4 id="type-inference-tools-general" class="subsubsection">Type inference for any type system</h4><!--SEC END --><p>By supplying the <span style="font-family:monospace">-Ainfer</span> command-line option,
any type-checker can infer annotations. See Section&#XA0;<a href="#whole-program-inference">26.2.2</a>.</p><p><a href="https://github.com/reprogrammer/cascade/">Cascade</a>&#XA0;[<a href="#VakilianPEJ2014">VPEJ14</a>]
is an Eclipse plugin that implements interactive type qualifier inference.
Cascade is interactive rather than fully-automated: it makes it easier for
a developer to insert annotations.
Cascade starts with an unannotated program and runs a type-checker. For each
warning it suggests multiple fixes, the developer chooses a fix, and
Cascade applies it. Cascade works with any checker built on the Checker
Framework.
You can find installation instructions and a video tutorial at <a href="https://github.com/reprogrammer/cascade"><span style="font-family:monospace">https://github.com/reprogrammer/cascade</span></a>.</p>
<!--TOC subsection id="whole-program-inference" Whole-program inference-->
<h3 id="whole-program-inference" class="subsection">26.2.2&#XA0;&#XA0;Whole-program inference</h3><!--SEC END --><p>Whole-program inference is an interprocedural inference that
infers types for fields, method parameters, and method return types that do not
have a user-written annotation (for the given type system).
The inferred types are inserted into
your program.
The inferred type is the most specific type that is compatible with all the
uses in the program. For example, the inferred type for a field is the
least upper bound of the types of all the expressions that are assigned
into the field.</p><p>To use whole-program inference,
set the <span style="font-family:monospace">$CHECKERFRAMEWORK</span> variable to the Checker Framework&#X2019;s
directory (if you haven&#X2019;t already), and make sure that
<span style="font-family:monospace">insert-annotations-to-source</span>, from the Annotation File Utilities project,
is on your path (for example in the <span style="font-family:monospace">$PATH</span> environment variable).
Then, run the script <span style="font-family:monospace">$CHECKERFRAMEWORK/checker/bin/infer-and-annotate.sh</span>.
Its command-line arguments are:</p><ol class="enumerate" type=1><li class="li-enumerate">
Processor&#X2019;s name.
</li><li class="li-enumerate">Target program&#X2019;s classpath. This argument is required; pass "" if it
is empty.
</li><li class="li-enumerate">Extra processor arguments which will be passed to the checker, if any.
You may supply any number of such arguments, or none. Each such argument
must start with a hyphen.
</li><li class="li-enumerate">Optional: List of paths to <span style="font-family:monospace">.jaif</span> files used as input in the inference
process.
</li><li class="li-enumerate">List of paths to <span style="font-family:monospace">.java</span> files in the program.
</li></ol><p>For example, to add annotations to the <span style="font-family:monospace">plume-lib</span> project:
</p><pre class="verbatim">git clone https://github.com/mernst/plume-lib.git
cd plume-lib
make jar
$CHECKERFRAMEWORK/checker/bin/infer-and-annotate.sh \
    "LockChecker,NullnessChecker" java/plume.jar    \
    -AprintErrorStack  \
    `find java/src/plume/ -name "*.java"`
# View the results
git diff
</pre><p>You may need to wait a few minutes for the command to complete.</p><p>It is recommended that you run <span style="font-family:monospace">infer-and-annotate.sh</span> on a copy of your
code, so that you can see what changes it made and so that it does not
change your only copy. One way to do this is to work in a clone of your
repository that has no uncommitted changes.</p><p>Whole-program inference differs from type refinement (Section&#XA0;<a href="#type-refinement">23.4</a>)
in three ways. First, type refinement only works within a method body.
Second, type refinement always
refines the current type, regardless of whether the value already has an
annotation in the source code.
Third, whole-program inference can infer a subtype
or a supertype of the default type, by contrast with type refinement which
always refines the current type to a subtype.</p>
<!--TOC subsubsection id="whole-program-inference-ignores-some-code" Whole-program inference ignores some code-->
<h4 id="whole-program-inference-ignores-some-code" class="subsubsection">Whole-program inference ignores some code</h4><!--SEC END --><p>Whole-program inference ignores code within the the scope of a
<span style="font-family:monospace">@SuppressWarnings</span> annotation with an appropriate key
(Section&#XA0;<a href="#suppresswarnings-annotation">24.1</a>). In particular, uses within
the scope do not contribute to the inferred type, and declarations within
the scope are not changed. You should remove <span style="font-family:monospace">@SuppressWarnings</span> annotations
from the class declaration of any class you wish to infer types for.</p><p>As noted below, whole-program inference requires invocations of your code, or
assignments to your methods, to generalize from. If a field is set via
reflection (such as via injection), then whole-program inference would produce
an inaccurate result. You probably have an annotation such as
<a href="http://docs.oracle.com/javaee/7/api/javax/inject/Inject.html"><span style="font-family:monospace">@Inject</span></a>
or
<a href="http://types.cs.washington.edu/plume-lib/api/plume/Option.html"><span style="font-family:monospace">@Option</span></a>
that indicates such fields. Meta-annotate the declaration of the <span style="font-family:monospace">Inject</span>
or <span style="font-family:monospace">Option</span> annotation with
<a href="api/org/checkerframework/framework/qual/IgnoreInWholeProgramInference.html"><span style="font-family:monospace">@IgnoreInWholeProgramInference</span></a> and whole-program
inference will not produce any inference results for fields annotated with
<span style="font-family:monospace">@Inject</span> or <span style="font-family:monospace">@Option</span>.</p><p>Whole-program inference, for a type-checker other than the Nullness Checker,
ignores (pseudo-)assignments where the right-hand-side is the <span style="font-family:monospace">null</span> literal.</p>
<!--TOC subsubsection id="whole-program-inference-manual-checking" Manually checking whole-program inference results-->
<h4 id="whole-program-inference-manual-checking" class="subsubsection">Manually checking whole-program inference results</h4><!--SEC END --><p>As with any type inference tool, it is a good idea to manually examine the
results.</p><ul class="itemize"><li class="li-itemize">
Whole-program inference can produce undesired results when your code has
non-representative calls to a particular method or assignments to a
particular field, as explained below.
This is especially noticeable when the arguments or assignments are literals.</li><li class="li-itemize">Also carefully examine annotations inferred for uses of type variables; in
some cases, it might be more appropriate for you to move those annotations
to the corresponding upper bounds of the type variable declaration.</li></ul>
<!--TOC paragraph id="whole-program-inference-non-representative-uses" Poor whole-program inference results due to non-representative uses-->
<h5 id="whole-program-inference-non-representative-uses" class="paragraph">Poor whole-program inference results due to non-representative uses</h5><!--SEC END --><p>Whole-program inference determines a method parameter&#X2019;s type
annotation based on what arguments are passed to the method, but not on how the
parameter is used within the method body. If the program contains
no errors, the tool&#X2019;s annotations are legal for the program as
currently written but may not be as general as possible and may not
accommodate future program changes. If the program contains errors, the
tool&#X2019;s annotations may reflect those errors.</p><p>For example, suppose that your program currently calls
method <span style="font-family:monospace">m1</span> with non-null
arguments. This tool will infer that <span style="font-family:monospace">m1</span>&#X2019;s parameter has
<span style="font-family:monospace">@NonNull</span> type. If you had intended the method to be able to
take <span style="font-family:monospace">null</span> as an argument and you later add such a call, the type-checker
will issue a warning because the automatically-inserted <span style="font-family:monospace">@NonNull</span>
annotation is inconsistent with the new call.
You can fix the inference problem by adding tests that pass <span style="font-family:monospace">null</span> to <span style="font-family:monospace">m1</span>.</p><p>As another example, suppose you intend method <span style="font-family:monospace">m2</span> to be called with
non-null arguments, but your program contains an error and one of the calls
to <span style="font-family:monospace">m2</span> passes <span style="font-family:monospace">null</span> as the argument. Then the tool will infer that
<span style="font-family:monospace">m2</span>&#X2019;s parameter has <span style="font-family:monospace">@Nullable</span> type.
You can fix the inference problem by correcting the bug.</p>
<!--TOC subsubsection id="how-whole-program-inference-works" How whole-program inference works-->
<h4 id="how-whole-program-inference-works" class="subsubsection">How whole-program inference works</h4><!--SEC END --><p>This section explains how the <span style="font-family:monospace">infer-and-annotate.sh</span> script works. If you
merely want to run the script and you are not encountering trouble, you can
skip this section.</p><p>If you
supply to javac the command-line option <span style="font-family:monospace">-Ainfer</span>, then the
checker outputs <span style="font-family:monospace">.jaif</span> files with refined types for fields and method signatures.
The output .jaif files are located in the folder <span style="font-family:monospace">build/whole-program-inference</span>,
relative to where you executed the javac command.</p><p>You can use the Annotation File Utilities
(<a href="http://types.cs.washington.edu/annotation-file-utilities/"><span style="font-family:monospace">http://types.cs.washington.edu/annotation-file-utilities/</span></a>) to
insert these refined types in your program. Then, the next time that you
run type-checking, there are likely to be fewer type-checking warnings.</p><p>Note that a three-step process is required:
</p><ol class="enumerate" type=1><li class="li-enumerate">
Run the checker with the <span style="font-family:monospace">-Ainfer</span> command-line option to
produce a <span style="font-family:monospace">.jaif</span> file. Some type-checking errors may result.
</li><li class="li-enumerate">Insert the <span style="font-family:monospace">.jaif</span> file&#X2019;s annotations in the program.
</li><li class="li-enumerate">Run the checker again. Fewer type-checking errors may result.
</li></ol><p>
A good approach is to repeatedly run the above process until there are no
more changes to the inference results (that is, the <span style="font-family:monospace">.jaif</span> file is
unchanged between two runs). That is exactly what the
<span style="font-family:monospace">infer-and-annotate.sh</span> script does.</p><p>The <span style="font-family:monospace">infer-and-annotate.sh</span> script insulates you from the
clumsy multi-step process. The multi-step process
is required because type-checking is modular:
it processes each class only once, independently. Modularity enables you
to run type-checking on only part of your program, and
it makes type-checking fast. However, it has some disadvantages:
</p><ul class="itemize"><li class="li-itemize">
The first run of the type-checker cannot take advantage
of whole-program inference results because whole-program inference is only complete at the
end of type-checking, and modular type-checking does not revisit any
already-processed classes.
</li><li class="li-itemize">The reason that multiple executions are required is that revisiting an
already-processed class may result in a better estimate.
</li></ul><hr>
<!--TOC chapter id="annotating-libraries" Annotating libraries-->
<h1 id="annotating-libraries" class="chapter">Chapter&#XA0;27&#XA0;&#XA0;Annotating libraries</h1><!--SEC END --><p>If your code uses a library that does <em>not</em> contain type annotations,
then the type-checker has no way to know the library&#X2019;s behavior.
The type-checker
makes conservative assumptions about unannotated bytecode: it assumes that
every method parameter has the bottom type annotation and that every method
return type has the top type annotation (see
Section&#XA0;<a href="#defaults-classfile">23.3.5</a> for details, an example, and how to
override this conservative behavior).
These conservative library
annotations invariably lead to checker warnings.
This chapter describes how to eliminate
the warnings by adding annotations to the library.
(Alternately, you can instead
suppress all warnings related to an unannotated library by use of the
<span style="font-family:monospace">-AskipUses</span> or <span style="font-family:monospace">-AonlyUses</span> command-line option; see
Section&#XA0;<a href="#askipuses">24.4</a>.)</p><p>(Note: This chapter uses &#X201C;library&#X201D; to refer to code that is provided in
<span style="font-family:monospace">.class</span> or <span style="font-family:monospace">.jar</span> form. You should use this approach for parts of your
own codebase if you typically compile different parts separately. If
your codebase is typically compiled together and you are type-checking only
part of it, you can use the approach described in this chapter, or you can
use command-line arguments such as <span style="font-family:monospace">-AskipUses</span> and <span style="font-family:monospace">-AskipDefs</span> (see
Sections&#XA0;<a href="#askipuses">24.4</a>&#X2013;<a href="#askipdefs">24.5</a>). Also, recall that the Checker
Framework analyzes all, and only, the source code that is passed to it.
The Checker Framework is a plug-in to the javac compiler, and it never
analyzes code that is not being compiled, though it does look up
annotations in the class files for code that was previously compiled.)</p>
<!--TOC section id="annotated-libraries-using" Using annotated libraries from the Checker Framework distribution-->
<h2 id="annotated-libraries-using" class="section">27.1&#XA0;&#XA0;Using annotated libraries from the Checker Framework distribution</h2><!--SEC END --><p>The Checker Framework distribution contains annotated versions of popular
libraries in directory <span style="font-family:monospace">checker-framework/checker/lib/</span>.
These currently include
</p><ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">bcel.jar</span>:
<a href="https://commons.apache.org/proper/commons-bcel/">Apache Commons BCEL</a> version 5.2
</li><li class="li-itemize"><span style="font-family:monospace">commons-bcel-6.0.jar</span>:
<a href="https://commons.apache.org/proper/commons-bcel/">Apache Commons
BCEL</a> version 6.0 pre-release
</li><li class="li-itemize"><span style="font-family:monospace">guava-19.0.jar</span>:
<a href="https://github.com/google/guava/">Google Guava</a>
</li><li class="li-itemize"><span style="font-family:monospace">java-getopt-1.0.14.jar</span>:
<a href="https://github.com/arenn/java-getopt">GNU getopt Java port</a>.
</li></ul><p>During type-checking, you should put the annotated version of the library on
your classpath. (The annotated JDK is automatically put on your classpath;
you don&#X2019;t have to
do anything special for it.)
When doing ordinary compilation or while running your code,
you can use either the annotated
library or the regular distributed version of the library &#X2014; they
behave identically.</p><p>Some projects, such as
<a href="http://plse.cs.washington.edu/daikon/">Daikon</a>
and
<a href="http://mernst.github.io/plume-lib/">plume-lib</a>,
are already distributed in annotated form by their maintainers;
over time, this should become more common, reducing the need for the
Checker Framework to include annotated versions of libraries.</p>
<!--TOC section id="annotated-libraries-creating" Creating an annotated library-->
<h2 id="annotated-libraries-creating" class="section">27.2&#XA0;&#XA0;Creating an annotated library</h2><!--SEC END --><p>This section describes how to create an annotated library.
If you annotate a new library, please inform the Checker Framework
developers so that they can include it in the Checker Framework distribution.</p><p>You make the library&#X2019;s annotations known to the checkers by writing
annotations in a copy of the library&#X2019;s source code (or in a &#X201C;stub
file&#X201D; if you do not have access to the source code).
Given the library annotations, you have two options:</p><ol class="enumerate" type=1><li class="li-enumerate">
You can compile the library to create <span style="font-family:monospace">.class</span> and <span style="font-family:monospace">.jar</span> files that
contain the annotations. Then, when doing pluggable type-checking, you
would put those files on the classpath.
When running your code, you can use either version of the library: the
one you created or the original distributed version.<p>With this compilation approach, the syntax of the library annotations is
validated ahead of time. Thus, this compilation approach is less
error-prone, and the type-checker runs faster. You get
correctness guarantees about the library in addition to your code.
Section&#XA0;<a href="#compiling-libraries">27.3</a> describes how to compile a library.</p></li><li class="li-enumerate">You can supply the annotated library source code, or a very concise
variant called a &#X201C;stub file&#X201D;, textually to the Checker Framework.<p>The stub file approach does not require you to compile the library source
code.
A stub file is applicable to multiple versions of a library, so
the stub file does not need to to be updated when a new version of the
library is released.
When provided by the author of the checker, a stub file is used
automatically, with no need for the user to supply a command-line option.
The stub file reader approach has some limitations, notably using
non-standard syntax in some locations (Section&#XA0;<a href="#stub-limitations">27.4.5</a>).
Section&#XA0;<a href="#stub">27.4</a> describes how to create and use stub files.</p></li></ol><p>If you write any library annotations,
please share them so that they
can be distributed with the Checker Framework.
Sharing your annotations is useful even if the library is only partially
annotated.
However, as noted in Section&#XA0;<a href="#get-started-with-legacy-code">2.4.1</a>, it is
best to annotate an entire class at a time.
You may find type inference tools (Chapter&#XA0;<a href="#type-inference-to-annotate">26.2</a>) helpful
when getting started, but you should always examine their results.
</p>
<!--TOC section id="compiling-libraries" Compiling partially-annotated libraries-->
<h2 id="compiling-libraries" class="section">27.3&#XA0;&#XA0;Compiling partially-annotated libraries</h2><!--SEC END --><p>If you completely annotate a library, then you can compile it using a
pluggable type-checker, and include the resulting <span style="font-family:monospace">.jar</span> file on your
classpath. You get a guarantee that the library contains no errors.</p><p>The rest of this section tells you how to compile a library if you
<em>partially</em> annotate it: that is, you write annotations for some of its
classes but not others.
(There is another type of partial annotation, which is when you annotate
method signatures but do not type-check the bodies. To do that variety of
partial annotation, simply suppress warnings; see
Chapter&#XA0;<a href="#suppressing-warnings">24</a>. You can combine the two types of
partial annotation.)</p><p>When compiling a partially-annotated library, the checker needs to use normal
defaulting rules (Section&#XA0;<a href="#climb-to-top">23.3.2</a>) for code you have annotated and
conservative defaulting rules (Section&#XA0;<a href="#defaults-classfile">23.3.5</a>) for
code you have not yet annotated.
You use <span style="font-family:monospace">@AnnotatedFor</span> to indicate which classes you have annotated.</p>
<!--TOC subsection id="AuseDefaultsForUncheckedCodesource" The <span style="font-family:monospace">-AuseDefaultsForUncheckedCode=source,bytecode</span> command-line argument-->
<h3 id="AuseDefaultsForUncheckedCodesource" class="subsection">27.3.1&#XA0;&#XA0;The <span style="font-family:monospace">-AuseDefaultsForUncheckedCode=source,bytecode</span> command-line argument</h3><!--SEC END --><p>
When compiling a library that is not fully annotated, use command-line
argument <span style="font-family:monospace">-AuseDefaultsForUncheckedCode=source,bytecode</span>. This causes
the checker to behave normally for classes with a relevant <span style="font-family:monospace">@AnnotatedFor</span>
annotation. For all other classes, the checker uses unchecked code defaults
(see Section&#XA0;<a href="#defaults-classfile">23.3.5</a>) for any type use with no explicit
user-written annotation, and the checker issues no warnings.
</p><p>The <a href="api/org/checkerframework/framework/qual/AnnotatedFor.html"><span style="font-family:monospace">@AnnotatedFor</span></a> annotation, written on a
class, indicates that the class has been annotated for certain type
systems. For example, <span style="font-family:monospace">@AnnotatedFor(</span><span style="font-family:monospace">{</span><span style="font-family:monospace">"nullness", "regex"</span><span style="font-family:monospace">}</span><span style="font-family:monospace">)</span> means that
the programmer has written annotations for the Nullness and Regular
Expression type systems. If one of those two type-checkers is run,
the <span style="font-family:monospace">-AuseDefaultsForUncheckedCode=source,bytecode</span> command-line argument
has no effect and this class is treated normally:
unannotated types are defaulted using normal source-code
defaults and type-checking warnings are issued.
<a href="api/org/checkerframework/framework/qual/AnnotatedFor.html"><span style="font-family:monospace">@AnnotatedFor</span></a>&#X2019;s arguments are any string that
may be passed to the <span style="font-family:monospace">-processor</span> command-line argument: the
fully-qualified class name for the checker, or a shorthand for built-in
checkers (see Section&#XA0;<a href="#shorthand-for-checkers">2.2.4</a>).
Writing <span style="font-family:monospace">@AnnotatedFor</span> on a class doesn&#X2019;t necessarily mean that you wrote
any annotations, but that the user examined the source code and verified
that all appropriate annotations are present.</p><p>
Whenever you compile a class using the Checker Framework, including when
using the <span style="font-family:monospace">-AuseDefaultsForUncheckedCode=source,bytecode</span> command-line
argument, the resulting <span style="font-family:monospace">.class</span> files are fully-annotated; each type use
in the <span style="font-family:monospace">.class</span> file has an explicit type qualifier for any checker that
is run.
</p>
<!--TOC subsection id="compiling-libraries-workflow" Workflow for creating or augmenting a partially-annotated library-->
<h3 id="compiling-libraries-workflow" class="subsection">27.3.2&#XA0;&#XA0;Workflow for creating or augmenting a partially-annotated library</h3><!--SEC END --><p>This section describes the typical workflow for creating a
partially-annotated library.</p><ol class="enumerate" type=1><li class="li-enumerate">
Read file <span style="font-family:monospace">checker-framework/checker/lib/README</span>
to find out whether an annotated version of the library already exists.
<p>If it does not already exist, fork the project (if its license permits
forking). Add a note, perhaps in a README, indicating how to obtain the
corresponding upstream version; that will enable others to see exactly
what edits you have made.</p><p>Adjust the library&#X2019;s
build process, such as a Maven or Ant buildfile.

</p><ol class="enumerate" type=a><li class="li-enumerate">
Every time the build system runs the compiler, it should:
<ul class="itemize"><li class="li-itemize">
passes the <span style="font-family:monospace">-AuseDefaultsForUncheckedCode=source,bytecode</span>
command-line option and
</li><li class="li-itemize">runs every pluggable type-checker for which any
annotations exist, using <span style="font-family:monospace">-processor
</span><span style="font-family:monospace"><em>TypeSystem1</em></span><span style="font-family:monospace">,</span><span style="font-family:monospace"><em>TypeSystem2</em></span><span style="font-family:monospace">,</span><span style="font-family:monospace"><em>TypeSystem3</em></span>
</li></ul>
</li><li class="li-enumerate">When the build system creates a <span style="font-family:monospace">.jar</span> file, the resulting <span style="font-family:monospace">.jar</span>
file includes the contents of
<span style="font-family:monospace">checker-framework/checker/dist/checker-qual.jar</span>.
</li></ol><p>You are not adding new build targets, but modifying existing targets.
The reason to run every type-checker is to verify
the annotations you wrote, and to use appropriate defaults for all
unannotated type uses.
The reason to include the contents of <span style="font-family:monospace">checker-qual.jar</span> is so that
the resulting <span style="font-family:monospace">.jar</span> file can be used whether or not the Checker Framework
is being run.</p></li><li class="li-enumerate">Annotate some files.
<p>When you annotate a file, annotate the whole thing, not just a few of its
methods. Once the file is fully annotated, add an
<a href="api/org/checkerframework/framework/qual/AnnotatedFor.html"><span style="font-family:monospace">@AnnotatedFor</span></a><span style="font-family:monospace">(</span><span style="font-family:monospace">{</span><span style="font-family:monospace">"</span><span style="font-family:monospace"><em>checkername</em></span><span style="font-family:monospace">"</span><span style="font-family:monospace">}</span><span style="font-family:monospace">)</span>
annotation to its class(es), or augment an existing <span style="font-family:monospace">@AnnotatedFor</span>
annotation.</p></li><li class="li-enumerate">Build the library.<p>Because of the changes that you made in step 1, this will run pluggable
type-checkers. If there are any compiler warnings, fix them and re-compile.</p><p>Now you have a <span style="font-family:monospace">.jar</span> file that you can use while type-checking and at
run time.</p></li><li class="li-enumerate">Tell other people about your work so that they can benefit from it.<ul class="itemize"><li class="li-itemize">
Please inform the Checker Framework developers
about your new annotated library by opening an issue.
This will let us include your annotated <span style="font-family:monospace">.jar</span> file in directory
<span style="font-family:monospace">checker-framework/checker/lib/</span> of the Checker Framework release.</li><li class="li-itemize">Encourage the library&#X2019;s maintainers to accept your annotations into its
main version control repository. This will make the annotations easier
to maintain, the library will obtain the correctness guarantees of
pluggable type-checking, and there will be no need for the Checker
Framework to include an annotated version of the library.<p>You will probably want to write the annotations in comments, so that it
is still possible to compile the library without use of Java 8.</p><p>If the library maintainers do not accept the annotations, then
periodically, such as when a new version of the library is released,
pull changes from upstream (the library&#X2019;s main version control system)
into your fork, add annotations to any newly-added methods in classes
that are annotated with <span style="font-family:monospace">@AnnotatedFor</span>, rebuild to create an updated
<span style="font-family:monospace">.jar</span> file, and inform the Checker Framework developers by opening an
issue or issuing a pull request.
</p></li></ul></li></ol>
<!--TOC section id="stub" Using stub classes-->
<h2 id="stub" class="section">27.4&#XA0;&#XA0;Using stub classes<a id="stub-creating-and-using"></a></h2><!--SEC END --><p>A stub file contains &#X201C;stub classes&#X201D; that contain annotated signatures,
but no method bodies. A
checker uses the annotated signatures at compile time, instead of or in
addition to annotations that appear in the library.</p><p>Section&#XA0;<a href="#stub-creating">27.4.3</a> describes how to create stub classes.
Section&#XA0;<a href="#stub-using">27.4.1</a> describes how to use stub classes.
These sections illustrate stub classes via the example of creating a <a href="api/org/checkerframework/checker/interning/qual/Interned.html"><span style="font-family:monospace">@Interned</span></a>-annotated
version of <span style="font-family:monospace">java.lang.String</span>. You don&#X2019;t need to repeat these steps
to handle <span style="font-family:monospace">java.lang.String</span> for the Interning Checker,
but you might do something similar for a different class and/or checker.</p>
<!--TOC subsection id="stub-using" Using a stub file-->
<h3 id="stub-using" class="subsection">27.4.1&#XA0;&#XA0;Using a stub file</h3><!--SEC END --><p>The <span style="font-family:monospace">-Astubs</span> argument causes the Checker Framework to read
annotations from annotated stub classes in preference to the unannotated
original library classes. For example:</p><div style="font-size:x-small;">
<pre class="verbatim">  javac -processor org.checkerframework.checker.interning.InterningChecker -Astubs=String.astub:stubs MyFile.java MyOtherFile.java ...
</pre></div><p>Each stub path entry is a file or a directory; specifying a directory is
equivalent to specifying every file in it whose name ends with
<span style="font-family:monospace">.astub</span>. The stub path entries are delimited by
<span style="font-family:monospace">File.pathSeparator</span> (&#X2018;<span style="font-family:monospace">:</span>&#X2019; for Linux and Mac, &#X2018;<span style="font-family:monospace">;</span>&#X2019; for Windows).</p><p>A checker automatically reads the stub file <span style="font-family:monospace">jdk.astub</span>, unless
command-line option <span style="font-family:monospace">-Aignorejdkastub</span> is supplied. (The checker
author should place <span style="font-family:monospace">jdk.astub</span> in the same directory as the Checker class, i.e.,
the subclass of <span style="font-family:monospace">BaseTypeVisitor</span>.) Programmers should only use the
<span style="font-family:monospace">-Astubs</span> argument for additional stub files they create themselves.</p><p>If a method appears in more than one stub file (or twice in the same
stub file), then the annotations are merged. If any of the
methods have different annotations from the same hierarchy on the same type,
then the annotation from the last declaration is used.</p><p>If both bytecode and a stub file provide information for the same
element, the stub file information is used. In particular, an
un-annotated type variable in a stub file is used instead of
annotations on a type variable in bytecode.
This feature allows stub files to change the effective annotations in
all possible situations.
Use the <span style="font-family:monospace">-AstubWarnIfOverwritesBytecode</span> command-line option to get a
warning whenever a stub file overwrites bytecode annotations.</p>
<!--TOC subsection id="stub-format" Stub file format-->
<h3 id="stub-format" class="subsection">27.4.2&#XA0;&#XA0;Stub file format</h3><!--SEC END --><p>Every Java file is a valid stub file. However, you can omit information
that is not relevant to pluggable type-checking; this makes the stub file
smaller and easier for people to read and write.</p><p>As an illustration, a stub file for the Interning type system
(Chapter&#XA0;<a href="#interning-checker">5</a>) could be:</p><pre class="verbatim">  import org.checkerframework.checker.interning.qual.Interned;
  package java.lang;
  @Interned class Class&lt;T&gt; { }
  class String {
    @Interned String intern();
  }
</pre><p>Note, annotations in comments are ignored.</p><p>The stub file format is allowed to differ from Java source code in the
following ways:
</p><dl class="description"><dt class="dt-description"></dt><dd class="dd-description"><span style="font-weight:bold">Method bodies:</span>
The stub class does not require method bodies for classes; any method
body may be replaced by a semicolon (<span style="font-family:monospace">;</span>), as in an interface or
abstract method declaration.</dd><dt class="dt-description"></dt><dd class="dd-description"><span style="font-weight:bold">Method declarations:</span>
You only have to specify the methods that you need to annotate.
Any method declaration may be omitted, in which case the checker reads
its annotations from library&#X2019;s <span style="font-family:monospace">.class</span> files. (If you are using a stub class, then
typically the library is unannotated.)</dd><dt class="dt-description"></dt><dd class="dd-description"><span style="font-weight:bold">Declaration specifiers:</span>
Declaration specifiers (e.g., <span style="font-family:monospace">public</span>, <span style="font-family:monospace">final</span>, <span style="font-family:monospace">volatile</span>)
may be omitted.</dd><dt class="dt-description"></dt><dd class="dd-description"><span style="font-weight:bold">Return types:</span>
The return type of a method does not need to match the real method.
In particular, it is valid to use <span style="font-family:monospace">java.lang.Object</span> for every method.
This simplifies the creation of stub files.</dd><dt class="dt-description"></dt><dd class="dd-description"><span style="font-weight:bold">Import statements:</span>
All imports must be at the beginning of the file.
The only required import statements are the ones to import type
annotations. Import statements for types are optional.<p>Enum constants in annotations need to be either fully-qualified
or imported.
For example, one has to either write the enum constant <span style="font-family:monospace">ANY</span> in
fully-qualified form:</p><pre class="verbatim">@Source(sparta.checkers.quals.FlowPermission.ANY)
</pre><p>or correctly import the enum class:</p><pre class="verbatim">import sparta.checkers.quals.FlowPermission;
...
@Source(FlowPermission.ANY)
</pre><p>or statically import the enum constants:</p><pre class="verbatim">import static sparta.checkers.quals.FlowPermission.*;
...
@Source(ANY)
</pre><p>Importing all packages from a class (<span style="font-family:monospace">import my.package.*;</span>) only
considers annotations from that package; enum types need to be
explicitly imported.</p></dd><dt class="dt-description"></dt><dd class="dd-description"><span style="font-weight:bold">Multiple classes and packages:</span>
The stub file format permits having multiple classes and packages.
The packages are separated by a package statement:
<span style="font-family:monospace">package my.package;</span>. Each package declaration may occur only once; in
other words, all classes from a package must appear together.</dd></dl>
<!--TOC subsection id="stub-creating" Creating a stub file-->
<h3 id="stub-creating" class="subsection">27.4.3&#XA0;&#XA0;Creating a stub file</h3><!--SEC END -->
<!--TOC subsubsection id="stub-creating-with-source" If you have access to the Java source code-->
<h4 id="stub-creating-with-source" class="subsubsection">If you have access to the Java source code</h4><!--SEC END --><p>Every Java file is a stub file. If you have access to the Java file, then
you can use the Java file as the stub file. Just add
annotations to the signatures, leaving the method bodies unchanged.
The stub file parser silently ignores any annotations that it cannot
resolve to a type, so don&#X2019;t forget the <span style="font-family:monospace">import</span> statement.</p><p>Optionally (but highly recommended!), run the type-checker to verify that
your annotations are correct. When you run the type-checker on your
annotations, there should not be any stub file that also contains
annotations for the class. In particular, if you are type-checking the JDK
itself, then you should use the <span style="font-family:monospace">-Aignorejdkastub</span> command-line option.</p><p>This approach retains the original
documentation and source code, making it easier for a programmer to
double-check the annotations. It also enables creation of diffs, easing
the process of upgrading when a library adds new methods. And, the
annotations are in a format that the library maintainers can even
incorporate.</p><p>The downside of this approach is that the stub files are larger. This can
slow down parsing.
</p>
<!--TOC subsubsection id="stub-creating-without-source" If you do not have access to the Java source code-->
<h4 id="stub-creating-without-source" class="subsubsection">If you do not have access to the Java source code</h4><!--SEC END --><p>If you do not have access to the library source code, then you can create a
stub file from the class file (Section&#XA0;<a href="#stub-creating">27.4.3</a>),
and then annotate it. The rest of this section describes this approach.</p><ol class="enumerate" type=1><li class="li-enumerate">Create a stub file by running the stub class generator. (<span style="font-family:monospace">checker.jar</span> and <span style="font-family:monospace">javac.jar</span>
must be on your classpath.)<pre class="verbatim">  cd nullness-stub
  java org.checkerframework.framework.stub.StubGenerator java.lang.String &gt; String.astub
</pre><p>Supply it with the fully-qualified name of the class for which you wish to
generate a stub class. The stub class generator prints the
stub class to standard out, so you may wish to redirect its output to a
file.</p></li><li class="li-enumerate">Add import statements for the annotations. So you would need to
add the following import statement at the beginning of the file:<pre class="verbatim">  import org.checkerframework.checker.interning.qual.*;
</pre><p>The stub file parser silently ignores any annotations that it cannot
resolve to a type, so don&#X2019;t forget the import statement.
Use the <span style="font-family:monospace">-AstubWarnIfNotFound</span> command-line option to see warnings
if an entry could not be found.</p></li><li class="li-enumerate">Add annotations to the stub class. For example, you might annotate
the <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#intern--"><span style="font-family:monospace">String.intern()</span></a> method as follows:<pre class="verbatim">  @Interned String intern();
</pre><p>You may also remove irrelevant parts of the stub file; see
Section&#XA0;<a href="#stub-format">27.4.2</a>.</p></li></ol>
<!--TOC subsection id="stub-troubleshooting" Troubleshooting stub libraries-->
<h3 id="stub-troubleshooting" class="subsection">27.4.4&#XA0;&#XA0;Troubleshooting stub libraries</h3><!--SEC END -->
<!--TOC subsubsection id="stub-troubleshooting-type-checking-results" Type-checking does not yield the expected results-->
<h4 id="stub-troubleshooting-type-checking-results" class="subsubsection">Type-checking does not yield the expected results</h4><!--SEC END --><p>By default, the stub parser silently ignores
annotations on unknown classes and methods.
The stub parser also silently ignores unknown annotations, so don&#X2019;t forget to
<span style="font-family:monospace">import</span> any annotations.</p><p>Use command-line option
<span style="font-family:monospace">-AstubWarnIfNotFound</span> to warn whenever some element of a stub file cannot
be found.</p><p>The <span style="font-family:monospace">@NoStubParserWarning</span> annotation on a package or type in a stub file
overrides the <span style="font-family:monospace">-AstubWarnIfNotFound</span> command-line option, and no warning
will be issued.</p><p>Use command-line option
<span style="font-family:monospace">-AstubWarnIfOverwritesBytecode</span> to warn whenever some element of a
stub file overwrites annotations contained in bytecode.</p><p>Use command-line option <span style="font-family:monospace">-AstubDebug</span> to output debugging messages while
parsing stub files, including about unknown classes, methods, and
annotations. This overrides the <span style="font-family:monospace">@NoStubParserWarning</span> annotation.</p>
<!--TOC subsubsection id="stub-troubleshooting-parsing" Problems parsing stub libraries-->
<h4 id="stub-troubleshooting-parsing" class="subsubsection">Problems parsing stub libraries</h4><!--SEC END --><p>When using command-line option <span style="font-family:monospace">-AstubWarnIfNotFound</span>,
an error is issued if a stub file has a typo or the API method does not
exist.</p><p>Fix this error by removing the extra L in the method name:
</p><pre class="verbatim">StubParser: Method isLLowerCase(char) not found in type java.lang.Character
</pre><p>Fix this error by removing the method <span style="font-family:monospace">enableForgroundNdefPush(...)</span> from
the stub file, because it is not defined in class <span style="font-family:monospace">android.nfc.NfcAdapter</span>
in the version of the library you are using:
</p><pre class="verbatim">StubParser: Method enableForegroundNdefPush(Activity,NdefPushCallback)
      not found in type android.nfc.NfcAdapter
</pre>
<!--TOC subsection id="stub-limitations" Limitations-->
<h3 id="stub-limitations" class="subsection">27.4.5&#XA0;&#XA0;Limitations</h3><!--SEC END --><p>The stub file reader has several limitations that are violations of Java 8 syntax. We will fix these in a
future release.</p><ul class="itemize"><li class="li-itemize">The receiver is written after the method parameter list, instead of as an
explicit first parameter. That is, instead of<pre class="verbatim">     returntype methodname(@Annotations C this, params);
</pre><p>in a stub file one has to write</p><pre class="verbatim">     returntype methodname(params) @Annotations;
</pre></li><li class="li-itemize">The stub file reader
does not handle nested class declarations. To work around this, it permits a
top-level class to be written with a <span style="font-family:monospace">$</span> in its name, and applies the
annotations to the appropriate nested class.<pre class="verbatim">    class Lib$Inner {
       // methods
    }
</pre></li><li class="li-itemize">Annotations must be written before the package name on a fully-qualified
types rather than directly on the type it qualifies. However, it is usually not
necessary to write the fully-qualified name.<pre class="verbatim">          void init(@Nullable java.security.SecureRandom random);
   </pre></li><li class="li-itemize">Annotations on types that are inner classes must be written before the
package if the type is written as a
fully-qualified type, or before the inner class name if the type is
written as a simple type. For example,<pre class="verbatim">        ProcessBuilder redirectError(@NonNull java.lang.ProcessBuilder.Redirect destination);
</pre><p>or
</p><pre class="verbatim">        ProcessBuilder redirectError(@NonNull Redirect destination);
</pre><p>The code below will cause an error.
</p><pre class="verbatim">        // error
        ProcessBuilder redirectError(@NonNull ProcessBuilder.Redirect destination);
</pre><p>or
</p><pre class="verbatim">        // error
        ProcessBuilder redirectError(ProcessBuilder.@NonNull Redirect destination);
</pre></li><li class="li-itemize">Annotations can only use string, boolean, or integer literals; other literals are not
yet supported.
</li></ul><p>If these limitations are a problem, then you should insert annotations
in the library&#X2019;s <span style="font-family:monospace">.class</span> files instead.</p>
<!--TOC section id="libraries-troubleshooting" Troubleshooting/debugging annotated libraries-->
<h2 id="libraries-troubleshooting" class="section">27.5&#XA0;&#XA0;Troubleshooting/debugging annotated libraries</h2><!--SEC END --><p>Sometimes, it may seem that a checker is treating a library as unannotated
even though the library has annotations. The compiler has two flags that
may help you in determining whether library files are read, and if they are
read whether the library&#X2019;s annotations are parsed.</p><dl class="description"><dt class="dt-description">
</dt><dd class="dd-description"><span style="font-family:monospace">-verbose</span>
Outputs info about compile phases &#X2014; when the compiler
reads/parses/attributes/writes any file. Also outputs the classpath and
sourcepath paths.
</dd><dt class="dt-description"></dt><dd class="dd-description"><span style="font-family:monospace">-XDTA:parser</span> (which is equivalent to <span style="font-family:monospace">-XDTA:reader</span> plus <span style="font-family:monospace">-XDTA:writer</span>)
Sets the internal <span style="font-family:monospace">debugJSR308</span> flag, which outputs information about
reading and writing.
</dd></dl><hr>
<!--TOC chapter id="writing-a-checker" How to create a new checker-->
<h1 id="writing-a-checker" class="chapter">Chapter&#XA0;28&#XA0;&#XA0;How to create a new checker</h1><!--SEC END --><p>This chapter describes how to create a checker
&#X2014; a type-checking compiler plugin that detects bugs or verifies their
absence. After a programmer annotates a program,
the checker plugin verifies that the code is consistent
with the annotations.
If you only want to <em>use</em> a checker, you do not need to read this
chapter.</p><p>Writing a simple checker is easy! For example, here is a complete, useful
type-checker:</p><pre class="verbatim">@SubtypeOf(Unqualified.class)
@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})
public @interface Encrypted {}
</pre><p>This checker is so short because it builds on the Subtyping Checker
(Chapter&#XA0;<a href="#subtyping-checker">20</a>).
See Section&#XA0;<a href="#subtyping-example">20.2</a> for more details about this particular checker.
When you wish to create a new checker, it is often easiest to begin by
building it declaratively on top of the Subtyping Checker, and then return to
this chapter when you need more expressiveness or power than the Subtyping
Checker affords.</p><p>You can also create your own checker by customizing a different existing
checker. Specific checkers that are designed for extension include
the Subtyping Checker (Chapter&#XA0;<a href="#subtyping-checker">20</a>),
the Fake Enumeration Checker (Chapter&#XA0;<a href="#fenum-checker">7</a>),
the Units Checker (Chapter&#XA0;<a href="#units-checker">15</a>),
and a typestate checker (Chapter&#XA0;<a href="#typestate-checker">21.1</a>).
Or, you can copy and then modify a different existing checker &#X2014; whether
one distributed with the Checker Framework or a third-party one.
(One good choice to copy and modify is the Regex Checker
(Chapter&#XA0;<a href="#regex-checker">9</a>); a bad choice is the Nullness Checker,
which is more sophisticated than anything you want to start out building.)</p><p>
You can place your checker&#X2019;s source files wherever you like. When you
compile your checker, <span style="font-family:monospace">$CHECKERFRAMEWORK/framework/dist/framework.jar</span> and <span style="font-family:monospace">$CHECKERFRAMEWORK/framework/dist/javac.jar</span>
should be on your classpath. (If you wish to modify an existing checker in place,
or to place the source code for your new checker in your own private copy of the
Checker Framework source code, then you need to be able to re-compile the
Checker Framework, as described in Section&#XA0;<a href="#build-source">31.3</a>.)
</p><p>The rest of this chapter contains many details for people who want to write more powerful
checkers.
You do not need all of the details, at least at first.
In addition to reading this chapter of the manual, you may find it helpful
to examine the implementations of the checkers that are distributed with
the Checker Framework. You can even create your checker by modifying one
of those.
The Javadoc documentation of the framework and the checkers is in the
distribution and is also available online at
<a href="http://types.cs.washington.edu/checker-framework/current/api/"><span style="font-family:monospace">http://types.cs.washington.edu/checker-framework/current/api/</span></a>.</p><p>If you write a new checker and wish to advertise it to the world, let us
know so we can mention it in the Checker Framework Manual, link to
it from the webpages, or include it in the Checker Framework distribution.
For examples, see Chapter&#XA0;<a href="#third-party-checkers">21</a>.</p>
<!--TOC section id="tool-relationships" Relationship of the Checker Framework to other tools-->
<h2 id="tool-relationships" class="section">28.1&#XA0;&#XA0;Relationship of the Checker Framework to other tools</h2><!--SEC END --><p>This table shows the relationship among various tools.
All of the tools support the Java 8 type annotation syntax.
You use the Checker Framework to build pluggable type systems, and the
Annotation File Utilities to manipulate <span style="font-family:monospace">.java</span> and <span style="font-family:monospace">.class</span> files.</p><div class="center">
<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="vertical-align:top;text-align:left;border:solid 1px;" ><div class="center">Subtyping </div><p>Checker</p></td><td style="vertical-align:top;text-align:left;border:solid 1px;" ><div class="center">Nullness </div><p>Checker</p></td><td style="vertical-align:top;text-align:left;border:solid 1px;" ><div class="center">Mutation </div><p>Checker</p></td><td style="vertical-align:top;text-align:left;border:solid 1px;" ><div class="center">Tainting </div><p>Checker</p></td><td style="vertical-align:top;text-align:left;border:solid 1px;" ><div class="center">&#X2026;</div></td><td style="vertical-align:top;text-align:left;border:solid 1px;" ><div class="center">Your </div><p>Checker</p></td><td style="text-align:center;border:solid 1px;white-space:nowrap"  colspan=2>&nbsp;</td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;"  colspan=6><div class="center">Base Checker </div><p>(enforces subtyping rules)</p></td><td style="vertical-align:top;text-align:left;border:solid 1px;" ><div class="center">Type </div><p>inference</p></td><td style="vertical-align:top;text-align:left;border:solid 1px;" >Other <p>tools
</p></td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;"  colspan=6><div class="center">Checker Framework </div><p>(enables creation of pluggable type-checkers)</p></td><td style="vertical-align:top;text-align:left;border:solid 1px;"  colspan=2><div class="center"><a href="http://types.cs.washington.edu/annotation-file-utilities/">Annotation File Utilities</a> </div><p>(<span style="font-family:monospace">.java</span> &#X2194; <span style="font-family:monospace">.class</span> files)
</p></td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;"  colspan=8><div class="center"><a href="http://types.cs.washington.edu/jsr308/">Type Annotations</a> syntax
and classfile format (&#X201C;JSR 308&#X201D;) </div><p>(no built-in semantics) </p></td></tr>
</table>
</div><p>The Base Checker enforces the standard subtyping rules on extended types.
The Subtyping Checker is a simple use of the Base Checker that supports
providing type qualifiers on the command line.
You usually want to build your checker on the Base Checker.</p>
<!--TOC section id="parts-of-a-checker" The parts of a checker-->
<h2 id="parts-of-a-checker" class="section">28.2&#XA0;&#XA0;The parts of a checker</h2><!--SEC END --><p>The Checker Framework provides abstract base classes (default
implementations), and a specific checker overrides as little or as much of
the default implementations as necessary.
Sections&#XA0;<a href="#writing-typequals">28.3</a>&#X2013;<a href="#writing-compiler-interface">28.7</a> describe
the components of a type system as written using the Checker Framework:</p><dl class="description"><dt class="dt-description"></dt><dd class="dd-description"><a href="#writing-typequals">28.3</a>
<span style="font-weight:bold">Type qualifiers and hierarchy.</span> You define the annotations for
the type system and the subtyping relationships among qualified types
(for instance, that <span style="font-family:monospace">@NonNull Object</span> is a subtype of <span style="font-family:monospace">@Nullable
Object</span>).</dd><dt class="dt-description"></dt><dd class="dd-description"><a href="#extending-visitor">28.4</a>
<span style="font-weight:bold">Type rules.</span> You specify the type system semantics (type
rules), violation of which yields a type error. There are two types of
rules.
<ul class="itemize"><li class="li-itemize">
Subtyping rules related to the type hierarchy, such as that every
assignment and pseudo-assignment satisfies a subtyping relationship.
Your checker automatically inherits these subtyping rules from the Base
Checker (Chapter&#XA0;<a href="#subtyping-checker">20</a>), so there is nothing for you to do.
</li><li class="li-itemize">Additional rules that are specific to your particular checker. For
example, in the Nullness type system, only references with a
<a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a> type may be dereferenced. You
write these additional rules yourself.
</li></ul></dd><dt class="dt-description"></dt><dd class="dd-description"><a href="#writing-type-introduction">28.5</a>
<span style="font-weight:bold">Type introduction rules.</span> For some types and
expressions, a qualifier should be treated as implicitly present even if a
programmer did not explicitly write it. For example, in the Nullness
type system every literal
other than <span style="font-family:monospace">null</span> has a <a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a> type;
examples of literals include <span style="font-family:monospace">"some string"</span> and <span style="font-family:monospace">java.util.Date.class</span>.</dd><dt class="dt-description"></dt><dd class="dd-description"><a href="#dataflow">28.6</a>
<span style="font-weight:bold">Dataflow rules.</span> These optional rules enhance flow-sensitive
type qualifier inference (local variable type inference).</dd><dt class="dt-description"></dt><dd class="dd-description"><a href="#writing-compiler-interface">28.7</a>
<span style="font-weight:bold">Interface to the compiler.</span> The compiler interface indicates
which annotations are part of the type system, which command-line options
and <span style="font-family:monospace">@SuppressWarnings</span> annotations the checker recognizes, etc.
</dd></dl>
<!--TOC subsection id="writing-tips" Tips for creating a checker-->
<h3 id="writing-tips" class="subsection">28.2.1&#XA0;&#XA0;Tips for creating a checker</h3><!--SEC END --><p>To make your job easier, we recommend that you build your type-checker
incrementally, testing at each phase rather than trying to build the whole
thing at once.</p><p>Here is an example of one good way to proceed.</p><ol class="enumerate" type=1><li class="li-enumerate">
Before you start coding, first write the user manual, which explains the
type system, what it guarantees, how to use it, etc., from the point of
view of a user.
This will help you flesh out your goals and the concepts, which are
easier to understand and change in text than in an imprementation.
Section&#XA0;<a href="#documenting-a-checker">28.10</a> gives a suggested structure for the
manual chapter, which will help you avoid omitting any parts.<p>Once you have designed and documented the parts of your type system, you
may also want to choose some case studies and play computer to ensure
that they give the expected results. During manual checking, ask
yourself what reasoning you applied, what information you needed, and
whether your written-down rules were sufficient.</p></li><li class="li-enumerate">Implement the type qualifiers and hierarchy
(Section&#XA0;<a href="#writing-typequals">28.3</a>).<p>Write simple test cases to test your type hierarchy. For instance, if
your type hierarchy consists of a supertype <span style="font-family:monospace">@UnknownSign</span> and a subtype
<span style="font-family:monospace">@NonNegative</span>, then you could write a test case such as:</p><pre class="verbatim">  void foo(@UnknownSign int us, @NonNegative int nn) {
    @UnknownSign int a = us;
    @UnknownSign int b = nn;
    @NonNegative int c = us;
    @NonNegative int d = nn;  // expected error on this line
  }
</pre><p>Type-check these test files using the Subtyping Checker
(Chapter&#XA0;<a href="#subtyping-checker">20</a>).</p></li><li class="li-enumerate">Write the checker class itself
(Section&#XA0;<a href="#writing-compiler-interface">28.7</a>).
Ensure that you can still type-check your test files and that the results
are the same.</li><li class="li-enumerate">Implement type rules, if any (Section&#XA0;<a href="#extending-visitor">28.4</a>).<p>Write simple test cases to test the type rules, and ensure that the
typechecker behaves as expected on those test files.
For example, if your type system forbids indexing an array by a
possibly-negative value, then you would write a test case such as:</p><pre class="verbatim">  void foo(String[] myarray, @UnknownSign int us, @NonNegative int nn) {
    myarray[us];  // expected error on this line
    myarray[nn];
  }
</pre></li><li class="li-enumerate">Implement and test type introduction rules, if any (Section&#XA0;<a href="#writing-type-introduction">28.5</a>).<p>For example, if your type system sets the qualifier for manifest literal
integers and for array lengths, you would write a test case like the following:</p><pre class="verbatim">  void foo(String[] myarray) {
    @NonNegative nn1 = -1;  // expected error on this line
    @NonNegative nn2 = 0;
    @NonNegative nn3 = 1;
    @NonNegative nn4 = myarray.length;
  }
</pre></li><li class="li-enumerate">Optionally, implement and test dataflow refinement rules
(Section&#XA0;<a href="#dataflow">28.6</a>).<p>For instance, if after an arithmetic comparison, your type system infers
which expressions are now known to be non-negative, you could write a
test case such as:</p><pre class="verbatim">  void foo(@UnknownSign int us, @NonNegative int nn) {
    @NonNegative nn2;
    nn2 = us;  // expected error on this line
    if (us &gt; j) {
      nn2 = us;
    }
    if (us &gt;= j) {
      nn2 = us;
    }
    if (j &lt; us) {
      nn2 = us;
    }
    if (j &lt;= us) {
      nn2 = us;
    }
    nn = us;  // expected error on this line
  }
</pre></li></ol>
<!--TOC section id="writing-typequals" Annotations: Type qualifiers and hierarchy-->
<h2 id="writing-typequals" class="section">28.3&#XA0;&#XA0;Annotations: Type qualifiers and hierarchy</h2><!--SEC END --><p>A type system designer specifies the qualifiers in the type system (Section&#XA0;<a href="#define-type-qualifiers">28.3.1</a>)
and
the type hierarchy that relates them.
The type hierarchy &#X2014; the subtyping relationships among the qualifiers &#X2014;
can be defined either
declaratively via meta-annotations (Section&#XA0;<a href="#declarative-hierarchy">28.3.2</a>), or procedurally through
subclassing <a href="api/org/checkerframework/framework/type/QualifierHierarchy.html"><span style="font-family:monospace">QualifierHierarchy</span></a> or
<a href="api/org/checkerframework/framework/type/TypeHierarchy.html"><span style="font-family:monospace">TypeHierarchy</span></a> (Section&#XA0;<a href="#procedural-hierarchy">28.3.3</a>).</p>
<!--TOC subsection id="define-type-qualifiers" Defining the type qualifiers-->
<h3 id="define-type-qualifiers" class="subsection">28.3.1&#XA0;&#XA0;Defining the type qualifiers</h3><!--SEC END --><p>Type qualifiers are defined as Java annotations. In Java, an
annotation is defined using the Java <span style="font-family:monospace">@interface</span> keyword.
For example, to define a two-qualifier hierarchy: the <span style="font-family:monospace">@Nullable</span> annotation which is the top
qualifier in its type hierarchy:</p><pre class="verbatim">  import java.lang.annotation.ElementType;
  import java.lang.annotation.Target;
  import org.checkerframework.framework.qual.SubtypeOf;
  import org.checkerframework.framework.qual.DefaultQualifierInHierarchy;
  @DefaultQualifierInHierarchy
  @SubtypeOf({})
  @Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})
  public @interface UnknownSign {}


  import java.lang.annotation.ElementType;
  import java.lang.annotation.Target;
  import org.checkerframework.framework.qual.SubtypeOf;
  @SubtypeOf({UnknownSign.class})
  @Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})
  public @interface NonNegative {}
</pre><p>The <a href="api/org/checkerframework/framework/qual/SubtypeOf.html"><span style="font-family:monospace">@SubtypeOf</span></a> meta-annotation
indicates the parent in the type hierarchy.</p><p>The <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Target.html"><span style="font-family:monospace">@Target</span></a>
meta-annotation indicates where the annotation
may be written. All type qualifiers that users can write in source code should
have the value <span style="font-family:monospace">ElementType.TYPE_USE</span> and optionally with the additional value
of <span style="font-family:monospace">ElementType.TYPE_PARAMETER</span>, but no other <span style="font-family:monospace">ElementType</span> values.
</p><p>The annotations should be placed within a directory called <span style="font-family:monospace">qual</span>, and this
directory should be placed in the same directory as your Checker&#X2019;s source file.</p><p>For example, the Nullness Checker&#X2019;s source file is located at
<span style="font-family:monospace">.../nullness/NullnessChecker.java</span>. The <span style="font-family:monospace">NonNull</span> qualifier is located in the
directory <span style="font-family:monospace">.../nullness/qual</span>.</p><p>The Checker Framework automatically treats any annotation that has this value
and is declared in the qual package as a type qualifier.
(See Section <a href="#indicating-supported-annotations">28.7.1</a> for more details.)</p><p>Your type system should include a top qualifier and a bottom qualifier
(Section&#XA0;<a href="#bottom-and-top-qualifier">28.3.5</a>). You should also define a
polymorphic qualifier <span style="font-family:monospace">@Poly</span><span style="font-family:monospace"><em>MyTypeSystem</em></span>
(Section&#XA0;<a href="#qualifier-polymorphism">22.2</a>).</p>
<!--TOC subsection id="declarative-hierarchy" Declaratively defining the qualifier hierarchy-->
<h3 id="declarative-hierarchy" class="subsection">28.3.2&#XA0;&#XA0;Declaratively defining the qualifier hierarchy</h3><!--SEC END --><p>Declaratively, the type system designer uses two meta-annotations (written
on the declaration of qualifier annotations) to specify the qualifier
hierarchy.</p><ul class="itemize"><li class="li-itemize"><a href="api/org/checkerframework/framework/qual/SubtypeOf.html"><span style="font-family:monospace">@SubtypeOf</span></a> denotes that a qualifier is a subtype of
another qualifier or qualifiers, specified as an array of class
literals. For example, for any type <span style="font-style:italic">T</span>,
<a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a> <span style="font-style:italic">T</span> is a subtype of <a href="api/org/checkerframework/checker/nullness/qual/Nullable.html"><span style="font-family:monospace">@Nullable</span></a> <span style="font-style:italic">T</span>:<pre class="verbatim">    @Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})
    @SubtypeOf( { Nullable.class } )
    public @interface NonNull { }
  </pre><p><a href="api/org/checkerframework/framework/qual/SubtypeOf.html"><span style="font-family:monospace">@SubtypeOf</span></a> accepts multiple annotation classes as an argument,
permitting the type hierarchy to be an arbitrary DAG.</p><p>All type qualifiers, except for polymorphic qualifiers (see below and
also Section&#XA0;<a href="#qualifier-polymorphism">22.2</a>), need to be
properly annotated with <a href="api/org/checkerframework/framework/qual/SubtypeOf.html"><span style="font-family:monospace">SubtypeOf</span></a>.</p><p>The top qualifier is annotated with
<span style="font-family:monospace">@SubtypeOf( { } )</span>. The top qualifier is the qualifier that is
a supertype of all other qualifiers. For example, <a href="api/org/checkerframework/checker/nullness/qual/Nullable.html"><span style="font-family:monospace">@Nullable</span></a>
is the top qualifier of the Nullness type system, hence is defined as:</p><pre class="verbatim">    @Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})
    @SubtypeOf( { } )
    public @interface Nullable { }
  </pre><p>
If the top qualifier of the hierarchy is the unqualified type, then its children
will use <span style="font-family:monospace">@SubtypeOf(Unqualified.class)</span>, but no <span style="font-family:monospace">@SubtypeOf({})</span> annotation on the top qualifier is necessary. For an example, see the
<span style="font-family:monospace">Encrypted</span> type system of Section&#XA0;<a href="#encrypted-example">20.2</a>.
</p></li><li class="li-itemize"><a href="api/org/checkerframework/framework/qual/PolymorphicQualifier.html"><span style="font-family:monospace">@PolymorphicQualifier</span></a> denotes that a qualifier is a
polymorphic qualifier. For example:<pre class="verbatim">    @Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})
    @PolymorphicQualifier
    public @interface PolyNull { }
  </pre><p>For a description of polymorphic qualifiers, see
Section&#XA0;<a href="#qualifier-polymorphism">22.2</a>. A polymorphic qualifier needs
no <a href="api/org/checkerframework/framework/qual/SubtypeOf.html"><span style="font-family:monospace">@SubtypeOf</span></a> meta-annotation and need not be
mentioned in any other <a href="api/org/checkerframework/framework/qual/SubtypeOf.html"><span style="font-family:monospace">@SubtypeOf</span></a>
meta-annotation.</p></li></ul><p>The declarative and procedural mechanisms for specifying the hierarchy can
be used together. In particular, when using the <a href="api/org/checkerframework/framework/qual/SubtypeOf.html"><span style="font-family:monospace">@SubtypeOf</span></a>
meta-annotation, further customizations may be
performed procedurally (Section&#XA0;<a href="#procedural-hierarchy">28.3.3</a>)
by overriding the <a href="api/org/checkerframework/framework/util/GraphQualifierHierarchy.html#isSubtype-java.util.Collection-java.util.Collection-"><span style="font-family:monospace">isSubtype</span></a> method in the checker class
(Section&#XA0;<a href="#writing-compiler-interface">28.7</a>).
However, the declarative mechanism is sufficient for most type systems.</p>
<!--TOC subsection id="procedural-hierarchy" Procedurally defining the qualifier hierarchy-->
<h3 id="procedural-hierarchy" class="subsection">28.3.3&#XA0;&#XA0;Procedurally defining the qualifier hierarchy</h3><!--SEC END --><p>While the declarative syntax suffices for many cases, more complex
type hierarchies can be expressed by overriding, in your subclass of <a href="api/org/checkerframework/common/basetype/BaseTypeVisitor.html"><span style="font-family:monospace">BaseTypeVisitor</span></a>,
either <a href="api/org/checkerframework/framework/type/AnnotatedTypeFactory.html#createQualifierHierarchy--"><span style="font-family:monospace">createQualifierHierarchy</span></a> or <a href="api/org/checkerframework/framework/type/AnnotatedTypeFactory.html#createTypeHierarchy--"><span style="font-family:monospace">createTypeHierarchy</span></a> (typically
only one of these needs to be overridden).
For more details, see the Javadoc of those methods and of the classes
<a href="api/org/checkerframework/framework/type/QualifierHierarchy.html"><span style="font-family:monospace">QualifierHierarchy</span></a> and <a href="api/org/checkerframework/framework/type/TypeHierarchy.html"><span style="font-family:monospace">TypeHierarchy</span></a>.</p><p>The <a href="api/org/checkerframework/framework/type/QualifierHierarchy.html"><span style="font-family:monospace">QualifierHierarchy</span></a> class represents the qualifier hierarchy (not the
type hierarchy). A type-system designer may subclass
<a href="api/org/checkerframework/framework/type/QualifierHierarchy.html"><span style="font-family:monospace">QualifierHierarchy</span></a> to express customized qualifier
relationships (e.g., relationships based on annotation
arguments).</p><p>The <a href="api/org/checkerframework/framework/type/TypeHierarchy.html"><span style="font-family:monospace">TypeHierarchy</span></a> class represents the type hierarchy &#X2014;
that is, relationships between
annotated types, rather than merely type qualifiers, e.g., <span style="font-family:monospace">@NonNull
Date</span> is a subtype of <span style="font-family:monospace">@Nullable Date</span>. The default <a href="api/org/checkerframework/framework/type/TypeHierarchy.html"><span style="font-family:monospace">TypeHierarchy</span></a> uses
<a href="api/org/checkerframework/framework/type/QualifierHierarchy.html"><span style="font-family:monospace">QualifierHierarchy</span></a> to determine all subtyping relationships.
The default <a href="api/org/checkerframework/framework/type/TypeHierarchy.html"><span style="font-family:monospace">TypeHierarchy</span></a> handles
generic type arguments, array components, type variables, and
wildcards in a similar manner to the Java standard subtype
relationship but with taking qualifiers into consideration. Some type
systems may need to override that behavior. For instance, the Java
Language Specification specifies that two generic types are subtypes only
if their type arguments are identical: for example,
<span style="font-family:monospace">List&lt;Date&gt;</span> is not a subtype of <span style="font-family:monospace">List&lt;Object&gt;</span>, or of any other
generic <span style="font-family:monospace">List</span>.
(In the technical jargon, the generic arguments are &#X201C;invariant&#X201D; or &#X201C;novariant&#X201D;.)</p>
<!--TOC subsection id="typesystem-defaults" Defining a default annotation-->
<h3 id="typesystem-defaults" class="subsection">28.3.4&#XA0;&#XA0;Defining a default annotation</h3><!--SEC END --><p>A type system applies a default qualifier where the user has not written a
qualifier (and no implicit qualifier is applicable), as explained in
Section&#XA0;<a href="#defaults">23.3.1</a>.</p><p>The type system designer may specify a default annotation declaratively,
using the <a href="api/org/checkerframework/framework/qual/DefaultQualifierInHierarchy.html"><span style="font-family:monospace">@DefaultQualifierInHierarchy</span></a>
meta-annotation.
Note that the default will apply to any source code that the checker reads,
including stub libraries, but will not apply to compiled <span style="font-family:monospace">.class</span>
files that the checker reads.</p><p>
Alternately, the type system designer may specify a default procedurally,
by calling the
<a href="api/org/checkerframework/framework/util/defaults/QualifierDefaults.html#addCheckedCodeDefault-javax.lang.model.element.AnnotationMirror-org.checkerframework.framework.qual.TypeUseLocation-"><span style="font-family:monospace">QualifierDefaults.addCheckedCodeDefault</span></a>
method. You may do this even if you have declaratively defined the
qualifier hierarchy; see the Nullness Checker&#X2019;s implementation for an
example.
</p>
<!--TOC subsection id="bottom-and-top-qualifier" Completeness of the type hierarchy-->
<h3 id="bottom-and-top-qualifier" class="subsection">28.3.5&#XA0;&#XA0;Completeness of the type hierarchy</h3><!--SEC END --><p>When you define a type system, its type hierarchy must be a
complete lattice &#X2014; that is, there must be a top type that is a
supertype of all other types, and there must be a bottom type that is a
subtype of all other types.
Furthermore, it is best if the top type and bottom type are defined
explicitly for the type system, rather than (say) reusing a qualifier from the
Checker Framework such as <span style="font-family:monospace">@Unqualified</span>.</p><p>It is possible that a single type-checker checks multiple type hierarchies.
An example is the Nullness Checker, which has three separate type
hierarchies, one each for
nullness, initialization, and map keys. In this case, each type hierarchy
would have its own top qualifier and its own bottom qualifier; they don&#X2019;t
all have to share a single top qualifier or a single bottom qualifier.</p>
<!--TOC paragraph id="bottom-qualifier" Bottom qualifier-->
<h5 id="bottom-qualifier" class="paragraph">Bottom qualifier</h5><!--SEC END --><p>
Your type hierarchy must have a bottom qualifier
&#X2014; a qualifier that is a (direct or indirect) subtype of every other
qualifier.</p><p>Your type system must give <span style="font-family:monospace">null</span> the bottom type. (The only exception
is if the type system has special treatment for <span style="font-family:monospace">null</span> values, as the
Nullness Checker does.) This legal code
will not type-check unless <span style="font-family:monospace">null</span> has the bottom type:
</p><pre class="verbatim">&lt;T&gt; T f() {
    return null;
}
</pre><p>
You don&#X2019;t necessarily have to define a new bottom qualifier. You can
use <span style="font-family:monospace">org.checkerframework.framework.qual.Bottom</span> if your type system does not already have an
appropriate bottom qualifier.
</p><p>If your type system has a special bottom type that is used <em>only</em> for
the <span style="font-family:monospace">null</span> value, then users should only write the bottom qualifier
on explicit bounds. To ensure this, write
<span style="font-family:monospace">@TargetLocations({ TypeUseLocation.EXPLICIT_LOWER_BOUND, TypeUseLocation.EXPLICIT_UPPER_BOUND })</span>
on the definition of the bottom qualifier.</p><p>The hierarchy shown in Figure&#XA0;<a href="#fig-initialization-hierarchy">3.3</a> lacks
a bottom qualifier, but the actual implementation does contain a (non-user-visible) bottom qualifier.</p>
<!--TOC paragraph id="top-qualifier" Top qualifier-->
<h5 id="top-qualifier" class="paragraph">Top qualifier</h5><!--SEC END --><p>
Your type hierarchy must have a top qualifier
&#X2014; a qualifier that is a (direct or indirect) supertype of every other
qualifier.
Here is the reason.
The default type for local variables is the top
qualifier (that type is then flow-sensitively
refined depending on what values are stored in the local variable).
If there is no single top qualifier, then there is no
unambiguous choice to make for local variables.</p><p>Furthermore, it is most convenient to users if the top qualifier is defined
by the type system. It is possible to use the framework&#X2019;s
<span style="font-family:monospace">@Unqualified</span> as the top type, but this is poor practice.
Users lose
flexibility in expressing defaults: there is no
way for a user to change the default qualifier for just that type system.
If a user specifies
<span style="font-family:monospace">@DefaultQualifier(Unqualified.class)</span>,
then the default would apply to every
type system that uses <span style="font-family:monospace">@Unqualified</span>, which is unlikely to be desired.</p>
<!--TOC section id="extending-visitor" Visitor: Type rules-->
<h2 id="extending-visitor" class="section">28.4&#XA0;&#XA0;Visitor: Type rules</h2><!--SEC END --><p>A type system&#X2019;s rules define which operations on values of a
particular type are forbidden.
These rules must be defined procedurally, not declaratively.</p><p>The Checker Framework provides a <span style="font-style:italic">base visitor class</span>,
<a href="api/org/checkerframework/common/basetype/BaseTypeVisitor.html"><span style="font-family:monospace">BaseTypeVisitor</span></a>, that performs type-checking at each node of a
source file&#X2019;s AST. It uses the visitor design pattern to traverse
Java syntax trees as provided by Oracle&#X2019;s
<a href="http://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/">Tree
API</a>,
and it issues a warning (by calling
<a href="api/org/checkerframework/framework/source/SourceChecker.html#report-org.checkerframework.framework.source.Result-java.lang.Object-"><span style="font-family:monospace">SourceChecker.report</span></a>)
whenever the type system is violated.</p><p>A checker&#X2019;s visitor overrides one method in the base visitor for each special
rule in the type qualifier system. Most type-checkers
override only a few methods in <a href="api/org/checkerframework/common/basetype/BaseTypeVisitor.html"><span style="font-family:monospace">BaseTypeVisitor</span></a>. For example, the
visitor for the Nullness type system of Chapter&#XA0;<a href="#nullness-checker">3</a>
contains a single 4-line method that warns if an expression of nullable type
is dereferenced, as in:
</p><pre class="verbatim">  myObject.hashCode();  // invalid dereference
</pre><p>By default, <a href="api/org/checkerframework/common/basetype/BaseTypeVisitor.html"><span style="font-family:monospace">BaseTypeVisitor</span></a> performs subtyping checks that are
similar to Java subtype rules, but taking the type qualifiers into account.
<a href="api/org/checkerframework/common/basetype/BaseTypeVisitor.html"><span style="font-family:monospace">BaseTypeVisitor</span></a> issues these errors:</p><ul class="itemize"><li class="li-itemize">invalid assignment (type.incompatible) for an assignment from
an expression type to an incompatible type. The assignment may be a
simple assignment, or pseudo-assignment like return expressions or
argument passing in a method invocation<p>In particular, in every assignment and pseudo-assignment, the
left-hand side of the assignment is a supertype of (or the same type
as) the right-hand side. For example, this assignment is not
permitted:</p><pre class="verbatim">    @Nullable Object myObject;
    @NonNull Object myNonNullObject;
    ...
    myNonNullObject = myObject;  // invalid assignment
  </pre></li><li class="li-itemize">invalid generic argument (type.argument.type.incompatible) when a type
is bound to an incompatible generic type variable</li><li class="li-itemize">invalid method invocation (method.invocation.invalid) when a
method is invoked on an object whose type is incompatible with the
method receiver type</li><li class="li-itemize">invalid overriding parameter type (override.parameter.invalid)
when a parameter in a method declaration is incompatible with that
parameter in the overridden method&#X2019;s declaration</li><li class="li-itemize">invalid overriding return type (override.return.invalid) when a
parameter in a method declaration is incompatible with that
parameter in the overridden method&#X2019;s declaration</li><li class="li-itemize">invalid overriding receiver type (override.receiver.invalid)
when a receiver in a method declaration is incompatible with that
receiver in the overridden method&#X2019;s declaration</li></ul>
<!--TOC subsection id="ast-traversal" AST traversal-->
<h3 id="ast-traversal" class="subsection">28.4.1&#XA0;&#XA0;AST traversal</h3><!--SEC END --><p>The Checker Framework needs to do its own traversal of the AST even though
it operates as an ordinary annotation processor&#XA0;[<a href="#JSR269">Dar06</a>]. Annotation
processors can utilize a visitor for Java code, but that visitor only
visits the public elements of Java code, such as classes, fields, methods,
and method arguments &#X2014; it does not visit code bodies or various other
locations. The Checker Framework hardly uses the built-in visitor &#X2014; as
soon as the built-in visitor starts to visit a class, then the Checker
Framework&#X2019;s visitor takes over and visits all of the class&#X2019;s source code.</p><p>Because there is no standard API for the AST of Java code<sup><a id="text1" href="#note1">1</a></sup>, the Checker
Framework uses the javac implementation. This is why the Checker Framework
is not deeply integrated with Eclipse, but runs as an external tool (see
Section&#XA0;<a href="#eclipse">29.7</a>).</p>
<!--TOC subsection id="avoid-hardcoding" Avoid hardcoding-->
<h3 id="avoid-hardcoding" class="subsection">28.4.2&#XA0;&#XA0;Avoid hardcoding</h3><!--SEC END --><p>It may be tempting to write a type-checking rule for method invocation,
where your rule checks the name of the method being called and then treats
the method in a special way. This is usually the wrong approach. It
is better to write annotations, in a stub file
(Chapter&#XA0;<a href="#annotating-libraries">27</a>), and leave the work to the standard
type-checking rules.</p>
<!--TOC section id="writing-type-introduction" Type factory: Implicit annotations (type introduction rules)-->
<h2 id="writing-type-introduction" class="section">28.5&#XA0;&#XA0;Type factory: Implicit annotations (type introduction rules)</h2><!--SEC END --><p>For some types and expressions, a qualifier should be treated as present
even if a programmer did not explicitly write it. For example, every
literal (other than <span style="font-family:monospace">null</span>) has a <a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a> type.
Section&#XA0;<a href="#effective-qualifier">23.3</a> explains the meaning of implicit
qualifiers, such as that they cannot be overridden.</p><p>The implicit annotations may be specified declaratively
(Section&#XA0;<a href="#declarative-type-introduction">28.5.1</a>) and/or procedurally
(Section&#XA0;<a href="#procedurally-specifying-implicit-annotations">28.5.2</a>).
It is easiest to specify them declaratively, when the declarative method is
sufficiently expressive.</p>
<!--TOC subsection id="declarative-type-introduction" Declaratively specifying implicit annotations-->
<h3 id="declarative-type-introduction" class="subsection">28.5.1&#XA0;&#XA0;Declaratively specifying implicit annotations</h3><!--SEC END --><p>The <a href="api/org/checkerframework/framework/qual/ImplicitFor.html"><span style="font-family:monospace">@ImplicitFor</span></a> meta-annotation indicates
implicit annotations.
When written on a qualifier, <a href="api/org/checkerframework/framework/qual/ImplicitFor.html"><span style="font-family:monospace">ImplicitFor</span></a>
specifies the trees (AST nodes) and types for which the framework should
automatically add that qualifier.</p><p>In short, the types and trees can be
specified via any combination of four fields in <a href="api/org/checkerframework/framework/qual/ImplicitFor.html"><span style="font-family:monospace">ImplicitFor</span></a>.</p><p>For example, consider the definitions of the
<a href="api/org/checkerframework/checker/nullness/qual/Nullable.html"><span style="font-family:monospace">@Nullable</span></a> and
<a href="api/org/checkerframework/checker/nullness/qual/NonNull.html"><span style="font-family:monospace">@NonNull</span></a>
type qualifiers:</p><pre class="verbatim">  @SubtypeOf({})
  @ImplicitFor(literals = { LiteralKind.NULL },
               typeNames = { java.lang.Void.class })
  @Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})
  public @interface Nullable { }

  @SubtypeOf( { Nullable.class } )
  @ImplicitFor(types = { TypeKind.PACKAGE,
                         TypeKind.INT, TypeKind.BOOLEAN, TypeKind.CHAR,
                         TypeKind.DOUBLE, TypeKind.FLOAT, TypeKind.LONG,
                         TypeKind.SHORT, TypeKind.BYTE },
      // All literals except NULL_LITERAL:
      literals = { LiteralKind.BOOLEAN, LiteralKind.CHAR, LiteralKind.DOUBLE,
                   LiteralKind.FLOAT, LiteralKind.INT, LiteralKind.LONG,
                   LiteralKind.STRING })
  @Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})
  public @interface NonNull {  }
</pre><p>For more details, see the Javadoc for the <a href="api/org/checkerframework/framework/qual/ImplicitFor.html"><span style="font-family:monospace">ImplicitFor</span></a>
annotation, and the Javadoc for the javac classes that are linked from
it. You only need to understand a small amount about the javac AST, such
as the
<a href="https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/tree/Tree.Kind.html?is-external=true"><span style="font-family:monospace">Tree.Kind</span></a>
and
<a href="http://docs.oracle.com/javase/8/docs/api/javax/lang/model/type/TypeKind.html?is-external=true"><span style="font-family:monospace">TypeKind</span></a>
enums. All the information you need is in the Javadoc, and
Section&#XA0;<a href="#javac-tips">28.11</a> can help you get started.</p>
<!--TOC subsection id="procedurally-specifying-implicit-annotations" Procedurally specifying implicit annotations-->
<h3 id="procedurally-specifying-implicit-annotations" class="subsection">28.5.2&#XA0;&#XA0;Procedurally specifying implicit annotations</h3><!--SEC END --><p>If the <span style="font-family:monospace">@ImplicitFor</span> annotation is not sufficiently expressive, then you
can write code to set implicit annotations. To do so, create a subclass of
<a href="api/org/checkerframework/framework/type/AnnotatedTypeFactory.html"><span style="font-family:monospace">AnnotatedTypeFactory</span></a> and override its
<span style="font-family:monospace">annotateImplicit</span> methods.</p><p><span style="font-family:monospace">AnnotatedTypeFactory</span>, when given a program
expression, returns the expression&#X2019;s type. This should include not only
the qualifiers that the programmer explicitly wrote in the source code, but
also default and implicit annotations, and flow-sensitive local type
inference (see Section&#XA0;<a href="#effective-qualifier">23.3</a> for explanations of these
concepts).</p><p>To add implicit annotations, you should override
<a href="api/org/checkerframework/framework/type/AnnotatedTypeFactory.html#annotateImplicit-com.sun.source.tree.Tree-org.checkerframework.framework.type.AnnotatedTypeMirror-"><span style="font-family:monospace">annotateImplicit(Tree,AnnotatedTypeMirror)</span></a>
(or
<a href="api/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.html#annotateImplicit-com.sun.source.tree.Tree-org.checkerframework.framework.type.AnnotatedTypeMirror-boolean-"><span style="font-family:monospace">annotateImplicit(Tree,AnnotatedTypeMirror,boolean)</span></a>
if extending <span style="font-family:monospace">GenericAnnotatedTypeFactory</span>)
and
<a href="api/org/checkerframework/framework/type/AnnotatedTypeFactory.html#annotateImplicit-javax.lang.model.element.Element-org.checkerframework.framework.type.AnnotatedTypeMirror-"><span style="font-family:monospace">annotateImplicit(Element,AnnotatedTypeMirror)</span></a>.
The methods operate on <a href="api/org/checkerframework/framework/type/AnnotatedTypeMirror.html"><span style="font-family:monospace">AnnotatedTypeMirror</span></a>,
which is the Checker Framework&#X2019;s representation of an annotated type.</p>
<!--TOC section id="dataflow" Dataflow: enhancing flow-sensitive type qualifier inference-->
<h2 id="dataflow" class="section">28.6&#XA0;&#XA0;Dataflow: enhancing flow-sensitive type qualifier inference</h2><!--SEC END --><p>By default, every checker performs automatic type refinement, also known as
flow inference, as described
in Section&#XA0;<a href="#type-refinement">23.4</a>.</p><p>In the uncommon case that you wish to disable flow inference in your
checker, put the following two lines at the beginning of the constructor
for your subtype of
<a href="api/org/checkerframework/common/basetype/BaseAnnotatedTypeFactory.html"><span style="font-family:monospace">BaseAnnotatedTypeFactory</span></a>:</p><pre class="verbatim">        // use true to enable flow inference, false to disable it
        super(checker, false);
</pre><p>You can enhance the Checker Framework&#X2019;s built-in flow-sensitive type refinement,
so that it is more powerful and is customized to your type system. In
particular, your enhancement will yield a more refined type for certain
expressions.</p><p>Most enhancements to type refinement are based on a
run-time test specific to the type system, and not all type systems have
applicable run-time tests. See
Section&#XA0;<a href="#type-refinement-runtime-tests">23.4.3</a> to determine whether
run-time tests are applicable to your type system.</p><p>The Checker Framework&#X2019;s type refinement is implemented with a dataflow algorithm
which can be customized to enhance the built-in type refinement. The next
sections detail dataflow customization. It would also be helpful to read the
<a href="http://types.cs.washington.edu/checker-framework/current/checker-framework-dataflow-manual.pdf">Dataflow Manual</a>, which gives a more in-depth description of the Checker
Framework&#X2019;s dataflow framework.</p><p>The steps to customizing type refinement are:
</p><ol class="enumerate" type=1><li class="li-enumerate">
<a href="#dataflow-create-classes">28.6.1</a> Create required classes and configure their
use
</li><li class="li-enumerate"><a href="#dataflow-override-methods">28.6.2</a> Override methods that handle
<a href="api/org/checkerframework/dataflow/cfg/node/Node.html"><span style="font-family:monospace">Node</span></a>s of interest
</li><li class="li-enumerate"><a href="#dataflow-determine-expressions">28.6.3</a> Determine which expressions will be
refined
</li><li class="li-enumerate"><a href="#dataflow-implement-refinement">28.6.4</a> Implement the refinement
</li></ol><p>The Regex Checker&#X2019;s dataflow customization for the
<a href="api/org/checkerframework/checker/regex/RegexUtil.html#asRegex-java.lang.String-"><span style="font-family:monospace">RegexUtil.asRegex</span></a>
run-time check is used as an example throughout the steps.</p>
<!--TOC subsection id="dataflow-create-classes" Create required classes and configure their use-->
<h3 id="dataflow-create-classes" class="subsection">28.6.1&#XA0;&#XA0;Create required classes and configure their use</h3><!--SEC END --><p>The following classes must be created to customize dataflow. These classes must
be included on the classpath like other components of your checker.</p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-weight:bold">Create a class that extends
</span><a href="api/org/checkerframework/framework/flow/CFAbstractTransfer.html"><span style="font-weight:bold"><span style="font-family:monospace">CFAbstractTransfer</span></span></a><p><a href="api/org/checkerframework/framework/flow/CFAbstractTransfer.html"><span style="font-family:monospace">CFAbstractTransfer</span></a> performs the default Checker
Framework type refinement. The extended class will add functionality by
overriding superclass methods.</p><p>The Regex Checker&#X2019;s extended <a href="api/org/checkerframework/framework/flow/CFAbstractTransfer.html"><span style="font-family:monospace">CFAbstractTransfer</span></a> is
<a href="api/org/checkerframework/checker/regex/classic/RegexTransfer.html"><span style="font-family:monospace">RegexTransfer</span></a>.</p></li><li class="li-enumerate"><span style="font-weight:bold">Create a class that extends
</span><a href="api/org/checkerframework/framework/flow/CFAbstractAnalysis.html"><span style="font-weight:bold"><span style="font-family:monospace">CFAbstractAnalysis</span></span></a><span style="font-weight:bold"> and uses the extended
</span><a href="api/org/checkerframework/framework/flow/CFAbstractTransfer.html"><span style="font-weight:bold"><span style="font-family:monospace">CFAbstractTransfer</span></span></a><p>
<a href="api/org/checkerframework/framework/flow/CFAbstractTransfer.html"><span style="font-family:monospace">CFAbstractTransfer</span></a> and its superclass,
<a href="api/org/checkerframework/dataflow/analysis/Analysis.html"><span style="font-family:monospace">Analysis</span></a>, are the central coordinating classes
in the Checker Framework&#X2019;s dataflow algorithm. The
<span style="font-family:monospace">createTransferFunction</span> method must be overridden in an extended
<a href="api/org/checkerframework/framework/flow/CFAbstractTransfer.html"><span style="font-family:monospace">CFAbstractTransfer</span></a> to return a new instance of the
extended <a href="api/org/checkerframework/framework/flow/CFAbstractTransfer.html"><span style="font-family:monospace">CFAbstractTransfer</span></a>.
</p><p>
The Regex Checker&#X2019;s extended <a href="api/org/checkerframework/framework/flow/CFAbstractAnalysis.html"><span style="font-family:monospace">CFAbstractAnalysis</span></a> is
<a href="api/org/checkerframework/checker/regex/classic/RegexAnalysis.html"><span style="font-family:monospace">RegexAnalysis</span></a>, which overrides the
<span style="font-family:monospace">createTransferFunction</span> to return a new
<a href="api/org/checkerframework/checker/regex/classic/RegexTransfer.html"><span style="font-family:monospace">RegexTransfer</span></a> instance:
</p><pre class="verbatim">  @Override
  public RegexTransfer createTransferFunction() {
      return new RegexTransfer(this);
  }
</pre></li><li class="li-enumerate"><span style="font-weight:bold">Configure the checker&#X2019;s type factory to use the extended
</span><a href="api/org/checkerframework/framework/flow/CFAbstractAnalysis.html"><span style="font-weight:bold"><span style="font-family:monospace">CFAbstractAnalysis</span></span></a><p>
To configure your checker&#X2019;s type factory to use the new extended
<a href="api/org/checkerframework/framework/flow/CFAbstractAnalysis.html"><span style="font-family:monospace">CFAbstractAnalysis</span></a>, override the
<span style="font-family:monospace">createFlowAnalysis</span> method in your type factory to return a new instance
of the extended <a href="api/org/checkerframework/framework/flow/CFAbstractAnalysis.html"><span style="font-family:monospace">CFAbstractAnalysis</span></a>.
</p><pre class="verbatim">  @Override
  protected RegexAnalysis createFlowAnalysis(
          List&lt;Pair&lt;VariableElement, CFValue&gt;&gt; fieldValues) {

      return new RegexAnalysis(checker, this, fieldValues);
  }
</pre></li></ol>
<!--TOC subsection id="dataflow-override-methods" Override methods that handle Nodes of interest-->
<h3 id="dataflow-override-methods" class="subsection">28.6.2&#XA0;&#XA0;Override methods that handle Nodes of interest</h3><!--SEC END --><p>At this point, your checker is configured to use your extended
<a href="api/org/checkerframework/framework/flow/CFAbstractAnalysis.html"><span style="font-family:monospace">CFAbstractAnalysis</span></a>, but it uses only the default
behavior. Next, in your extended <a href="api/org/checkerframework/framework/flow/CFAbstractTransfer.html"><span style="font-family:monospace">CFAbstractTransfer</span></a>
override the visitor method that handles the <a href="api/org/checkerframework/dataflow/cfg/node/Node.html"><span style="font-family:monospace">Node</span></a>s
relevant to your run-time check or run-time operation can be used to refine
types.</p><p>A <a href="api/org/checkerframework/dataflow/cfg/node/Node.html"><span style="font-family:monospace">Node</span></a> is basically equivalent to a javac compiler
<a href="https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/tree/Tree.html?is-external=true"><span style="font-family:monospace">Tree</span></a>. A tree is a node in the abstract syntax tree of the
program being checked. See Section&#XA0;<a href="#javac-tips">28.11</a> for more information about trees.</p><p>As an example, for the statement <span style="font-family:monospace">String a = "";</span>, the corresponding
abstract syntax tree structure is:
</p><pre class="verbatim">VariableTree:
  name: "a"
  type:
    IdentifierTree
      name: String
  initializer:
    LiteralTree
      value: ""
</pre><p>A <a href="api/org/checkerframework/dataflow/cfg/node/Node.html"><span style="font-family:monospace">Node</span></a> generally maps one-to-one with a
<a href="https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/tree/Tree.html?is-external=true"><span style="font-family:monospace">Tree</span></a>. When dataflow processes a method, it translates
<a href="https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/tree/Tree.html?is-external=true"><span style="font-family:monospace">Tree</span></a>s into <a href="api/org/checkerframework/dataflow/cfg/node/Node.html"><span style="font-family:monospace">Node</span></a>s and then
calls the appropriate visit method on
<a href="api/org/checkerframework/framework/flow/CFAbstractTransfer.html"><span style="font-family:monospace">CFAbstractTransfer</span></a> which then performs the dataflow
analysis for the passed in <a href="api/org/checkerframework/dataflow/cfg/node/Node.html"><span style="font-family:monospace">Node</span></a>.</p><p>Decide what <a href="api/org/checkerframework/dataflow/cfg/node/Node.html"><span style="font-family:monospace">Node</span></a> kinds are of interest with
respect to the run-time checks or run-time operations you are trying to support.
The <a href="api/org/checkerframework/dataflow/cfg/node/Node.html"><span style="font-family:monospace">Node</span></a> subclasses can be found in the
<span style="font-family:monospace">org.checkerframework.dataflow.cfg.node</span> package. Some examples are
<a href="api/org/checkerframework/dataflow/cfg/node/EqualToNode.html"><span style="font-family:monospace">EqualToNode</span></a>,
<a href="api/org/checkerframework/dataflow/cfg/node/LeftShiftNode.html"><span style="font-family:monospace">LeftShiftNode</span></a>,
<a href="api/org/checkerframework/dataflow/cfg/node/VariableDeclarationNode.html"><span style="font-family:monospace">VariableDeclarationNode</span></a>.</p><p>The Regex Checker refines the type of a run-time test method call, so
<a href="api/org/checkerframework/checker/regex/classic/RegexTransfer.html"><span style="font-family:monospace">RegexTransfer</span></a> overrides the method that handles
<a href="api/org/checkerframework/dataflow/cfg/node/MethodInvocationNode.html"><span style="font-family:monospace">MethodInvocationNode</span></a>s,
<span style="font-family:monospace">visitMethodInvocation</span>.</p><pre class="verbatim">  public TransferResult&lt;CFValue, CFStore&gt; visitMethodInvocation(
    MethodInvocationNode n, TransferInput&lt;CFValue, CFStore&gt; in)  { ... }
</pre>
<!--TOC subsection id="dataflow-determine-expressions" Determine the expressions to refine the types of-->
<h3 id="dataflow-determine-expressions" class="subsection">28.6.3&#XA0;&#XA0;Determine the expressions to refine the types of</h3><!--SEC END --><p>There are usually multiple expressions used in a run-time check or run-time
operation; determine which expression the customization will refine. This is
usually specific to the type system and run-time test.</p><p>
Expressions are refined by modifying the return value of a visitor method in
<a href="api/org/checkerframework/framework/flow/CFAbstractTransfer.html"><span style="font-family:monospace">CFAbstractTransfer</span></a>.
<a href="api/org/checkerframework/framework/flow/CFAbstractTransfer.html"><span style="font-family:monospace">CFAbstractTransfer</span></a> visitor methods return a
<a href="api/org/checkerframework/dataflow/analysis/TransferResult.html"><span style="font-family:monospace">TransferResult</span></a>. The constructor of a
<a href="api/org/checkerframework/dataflow/analysis/TransferResult.html"><span style="font-family:monospace">TransferResult</span></a> takes two parameters: the resulting
type for the <a href="api/org/checkerframework/dataflow/cfg/node/Node.html"><span style="font-family:monospace">Node</span></a> being evaluated (the result
type) and a map from expressions in scopes to estimates of their types (a
<a href="api/org/checkerframework/dataflow/analysis/Store.html"><span style="font-family:monospace">Store</span></a>).
</p><p>For the program operation <span style="font-family:monospace">op(a,b)</span>, an enhancement may improve the Checker
Framework&#X2019;s types in either or both of the following ways:
</p><ol class="enumerate" type=1><li class="li-enumerate">
Changing the resulting type to refine the estimate of the type of entire
expression <span style="font-family:monospace">op(a,b)</span>.<p>As an example (and as the running example of
implementing a dataflow refinement),
the <span style="font-family:monospace">RegexUtil.asRegex</span> method is declared as:</p><pre class="verbatim">  @Regex(0) String asRegex(String s, int groups) { ... }
</pre><p>which means that an expression such as <span style="font-family:monospace">RegexUtil.asRegex(myString, myInt)</span>
has type <span style="font-family:monospace">@Regex(0) String</span>. When <span style="font-family:monospace">int</span> parameter <span style="font-family:monospace">group</span> is
known or can be inferred at compile time, a better estimate can be given. For
example, <span style="font-family:monospace">RegexUtil.asRegex(myString, 2)</span> has type <span style="font-family:monospace">@Regex(2) String</span>.</p><p>
Changing the <a href="api/org/checkerframework/dataflow/analysis/TransferResult.html"><span style="font-family:monospace">TransferResult</span></a>&#X2019;s result type changes
the type that is returned by the <a href="api/org/checkerframework/framework/type/AnnotatedTypeFactory.html"><span style="font-family:monospace">AnnotatedTypeFactory</span></a>
for the tree corresponding to the <a href="api/org/checkerframework/dataflow/cfg/node/Node.html"><span style="font-family:monospace">Node</span></a> that was
visited. (Remember that <a href="api/org/checkerframework/common/basetype/BaseTypeVisitor.html"><span style="font-family:monospace">BaseTypeVisitor</span></a> uses the
<a href="api/org/checkerframework/framework/type/AnnotatedTypeFactory.html"><span style="font-family:monospace">AnnotatedTypeFactory</span></a> to look up the type of a
<a href="https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/tree/Tree.html?is-external=true"><span style="font-family:monospace">Tree</span></a>, and then performs checks on types of one or more
<a href="https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/tree/Tree.html?is-external=true"><span style="font-family:monospace">Tree</span></a>s.)
</p><p>When <a href="api/org/checkerframework/checker/regex/classic/RegexTransfer.html"><span style="font-family:monospace">RegexTransfer</span></a> evaluates a
<span style="font-family:monospace">RegexUtils.asRegex</span> invocation, it updates the
<a href="api/org/checkerframework/dataflow/analysis/TransferResult.html"><span style="font-family:monospace">TransferResult</span></a>&#X2019;s result type. This changes the
type of the <span style="font-family:monospace">RegexUtils.asRegex</span> invocation when its
<a href="https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/tree/Tree.html?is-external=true"><span style="font-family:monospace">Tree</span></a> is looked up by the
<a href="api/org/checkerframework/framework/type/AnnotatedTypeFactory.html"><span style="font-family:monospace">AnnotatedTypeFactory</span></a>. Regex Checker&#X2019;s
<span style="font-family:monospace">visitMethodInvocation</span> is shown in more detail in
Section&#XA0;<a href="#dataflow-implement-refinement">28.6.4</a>.</p></li><li class="li-enumerate">Changing the store to refine the estimate of some other expression, such
as <span style="font-family:monospace">a</span> or <span style="font-family:monospace">b</span>.<p>As an example, consider an equality test.</p><pre class="verbatim">  @Nullable String s;
    if (s != null) {
    ...
    }
</pre><p>The type of <span style="font-family:monospace">s != null</span> is always <span style="font-family:monospace">@NonNull boolean</span> (dataflow analysis
does not affect it), but in the true branch, the type of <span style="font-family:monospace">s</span> can be
refined to <span style="font-family:monospace">@NonNull String</span>.</p><p>Updating the <a href="api/org/checkerframework/dataflow/analysis/Store.html"><span style="font-family:monospace">Store</span></a> treats an expression as a
having a refined type for the remainder of the method or conditional block. For
example, when the Nullness Checker&#X2019;s dataflow evaluates <span style="font-family:monospace">myvar != null</span>, it
updates the <a href="api/org/checkerframework/dataflow/analysis/Store.html"><span style="font-family:monospace">Store</span></a> to specify that the variable
<span style="font-family:monospace">myvar</span> should be treated as having type <span style="font-family:monospace">@NonNull</span> for the rest of the
then conditional block. Not all kinds of expressions can be refined; currently
method return values, local variables, fields, and array values can be stored in
the <a href="api/org/checkerframework/dataflow/analysis/Store.html"><span style="font-family:monospace">Store</span></a>. Other kinds of expressions, like
binary expressions or casts, cannot be stored in the
<a href="api/org/checkerframework/dataflow/analysis/Store.html"><span style="font-family:monospace">Store</span></a>.</p></li></ol>
<!--TOC subsection id="dataflow-implement-refinement" Implement the refinement-->
<h3 id="dataflow-implement-refinement" class="subsection">28.6.4&#XA0;&#XA0;Implement the refinement</h3><!--SEC END --><p>
This section details implementing the visitor method
<span style="font-family:monospace">RegexTransfer.visitMethodInvocation</span> for the <span style="font-family:monospace">RegexUtil.asRegex</span>
run-time test. You can find other examples of visitor methods in
<a href="api/org/checkerframework/checker/lock/LockTransfer.html"><span style="font-family:monospace">LockTransfer</span></a> and
<a href="api/org/checkerframework/checker/formatter/FormatterTransfer.html"><span style="font-family:monospace">FormatterTransfer</span></a>.
</p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-weight:bold">Determine if the visited </span><a href="api/org/checkerframework/dataflow/cfg/node/Node.html"><span style="font-weight:bold"><span style="font-family:monospace">Node</span></span></a><span style="font-weight:bold"> is of
interest</span><p>The visitor method for a <a href="api/org/checkerframework/dataflow/cfg/node/Node.html"><span style="font-family:monospace">Node</span></a> is invoked for all
instances of that <a href="api/org/checkerframework/dataflow/cfg/node/Node.html"><span style="font-family:monospace">Node</span></a> kind in the program, so the
<a href="api/org/checkerframework/dataflow/cfg/node/Node.html"><span style="font-family:monospace">Node</span></a> must be inspected to determine if it is an
instance of the desired run-time test or operation. For example,
<span style="font-family:monospace">visitMethodInvocation</span> is called when dataflow processes any method
invocation, but the <a href="api/org/checkerframework/checker/regex/classic/RegexTransfer.html"><span style="font-family:monospace">RegexTransfer</span></a> should only refine
the result of <span style="font-family:monospace">RegexUtils.asRegex</span> invocations:</p><pre class="verbatim">  @Override
  public TransferResult&lt;CFValue, CFStore&gt; visitMethodInvocation(...)
    ...
    MethodAccessNode target = n.getTarget();
    ExecutableElement method = target.getMethod();
    Node receiver = target.getReceiver();
    if (receiver instanceof ClassNameNode) {
      ClassNameNode cn = (ClassNameNode) receiver;
      String receiverName = cn.getElement().toString();

      // Is this a RegexUtil.isRegex(s, groups) method call?
      if (isRegexUtil(receiverName)) {
        if (ElementUtils.matchesElement(method,
          null, IS_REGEX_METHOD_NAME, String.class, int.class)) {
            ...
</pre></li><li class="li-enumerate"><span style="font-weight:bold">Determine the refined type</span><p>Some run-time tests, like the null comparison test, have a deterministic type
refinement, e.g. the Nullness Checker always refines the argument in the
expression to <span style="font-family:monospace">@NonNull</span>. However, sometimes the refined type is dependent
on the parts of run-time test or operation itself, such as arguments passed to
it.</p><p>For example, the refined type of <span style="font-family:monospace">RegexUtils.asRegex</span> is dependent on the
integer argument to the method call. The <a href="api/org/checkerframework/checker/regex/classic/RegexTransfer.html"><span style="font-family:monospace">RegexTransfer</span></a>
uses this argument to build the resulting type <span style="font-family:monospace">@Regex(i)</span>, where <span style="font-family:monospace">i</span>
is the value of the integer argument. Note that currently this code only uses
the value of the integer argument if the argument was an integer literal. It
could be extended to use the value of the argument if it was any compile-time
constant or was inferred at compile time by another analysis, such as the
<a href="#constant-value-checker">16</a>.</p><pre class="verbatim">  AnnotationMirror regexAnnotation;
  Node count = n.getArgument(1);
  if (count instanceof IntegerLiteralNode) {
    IntegerLiteralNode iln = (IntegerLiteralNode) count;
    Integer groupCount = iln.getValue();
    regexAnnotation = factory.createRegexAnnotation(groupCount);

</pre><p>If the integer argument was not a literal integer, the
<a href="api/org/checkerframework/checker/regex/classic/RegexTransfer.html"><span style="font-family:monospace">RegexTransfer</span></a> falls back to refining the type to just
<span style="font-family:monospace">@Regex(0)</span>.</p><pre class="verbatim">  } else {
    regexAnnotation = AnnotationUtils.fromClass(factory.getElementUtils(), Regex.class);
  }
</pre></li><li class="li-enumerate"><span style="font-weight:bold">Return a </span><a href="api/org/checkerframework/dataflow/analysis/TransferResult.html"><span style="font-weight:bold"><span style="font-family:monospace">TransferResult</span></span></a><span style="font-weight:bold"> with the
refined types</span><p>As discussed in Section&#XA0;<a href="#dataflow-determine-expressions">28.6.3</a>, the type of an
expression is refined by modifying the
<a href="api/org/checkerframework/dataflow/analysis/TransferResult.html"><span style="font-family:monospace">TransferResult</span></a>. Since the
<a href="api/org/checkerframework/checker/regex/classic/RegexTransfer.html"><span style="font-family:monospace">RegexTransfer</span></a> is updating the type of the run-time
test itself, it will update the result type and not the
<a href="api/org/checkerframework/dataflow/analysis/Store.html"><span style="font-family:monospace">Store</span></a>.</p><p>A <a href="api/org/checkerframework/framework/flow/CFValue.html"><span style="font-family:monospace">CFValue</span></a> is created to hold the type inferred.
<a href="api/org/checkerframework/framework/flow/CFValue.html"><span style="font-family:monospace">CFValue</span></a> is a wrapper class for values being inferred
by dataflow:
</p><pre class="verbatim">  CFValue newResultValue = analysis.createSingleAnnotationValue(regexAnnotation,
      result.getResultValue().getType().getUnderlyingType());
</pre><p>Then, RegexTransfer&#X2019;s <span style="font-family:monospace">visitMethodInvocation</span> creates and returns a
<a href="api/org/checkerframework/dataflow/analysis/TransferResult.html"><span style="font-family:monospace">TransferResult</span></a> using <span style="font-family:monospace">newResultValue</span> as the
result type.</p><pre class="verbatim">  return new RegularTransferResult&lt;&gt;(newResultValue, result.getRegularStore());
</pre><p>Finally, when the Regex Checker encounters a <span style="font-family:monospace">RegexUtils.asRegex</span> method
call, the checker will refine the return type of the method if it can determine
the value of the integer parameter at compile time.</p></li></ol>
<!--TOC section id="writing-compiler-interface" The checker class: Compiler interface-->
<h2 id="writing-compiler-interface" class="section">28.7&#XA0;&#XA0;The checker class: Compiler interface</h2><!--SEC END --><p>A checker&#X2019;s entry point is a subclass of
<a href="api/org/checkerframework/framework/source/SourceChecker.html"><span style="font-family:monospace">SourceChecker</span></a>, and is usually a direct subclass
of either <a href="api/org/checkerframework/common/basetype/BaseTypeChecker.html"><span style="font-family:monospace">BaseTypeChecker</span></a> or
<a href="api/org/checkerframework/framework/source/AggregateChecker.html"><span style="font-family:monospace">AggregateChecker</span></a>.
This entry
point, which we call the checker class, serves two
roles: an interface to the compiler and a factory for constructing
type-system classes.</p><p>Because the Checker Framework provides reasonable defaults, oftentimes the
checker class has no work to do. Here are the complete definitions of the
checker classes for the Interning Checker and the Nullness Checker:</p><pre class="verbatim">  @SupportedLintOptions({"dotequals"})
  public final class InterningChecker extends BaseTypeChecker { }

  @SupportedLintOptions({"flow", "cast", "cast:redundant"})
  public class NullnessChecker extends BaseTypeChecker { }
</pre><p>The checker class bridges between the compiler and the rest of the checker. It
invokes the type-rule check visitor on every Java source file being
compiled, and provides a simple API,
<a href="api/org/checkerframework/framework/source/SourceChecker.html#report-org.checkerframework.framework.source.Result-java.lang.Object-"><span style="font-family:monospace">SourceChecker.report</span></a>, to issue
errors using the compiler error reporting mechanism.</p><p>Also, the checker class follows the factory method pattern to
construct the concrete classes (e.g., visitor, factory) and annotation
hierarchy representation. It is a convention that, for
a type system named Foo, the compiler
interface (checker), the visitor, and the annotated type factory are
named as <span style="font-family:monospace">FooChecker</span>, <span style="font-family:monospace">FooVisitor</span>, and <span style="font-family:monospace">FooAnnotatedTypeFactory</span>.
<a href="api/org/checkerframework/common/basetype/BaseTypeChecker.html"><span style="font-family:monospace">BaseTypeChecker</span></a> uses the convention to
reflectively construct the components. Otherwise, the checker writer
must specify the component classes for construction.</p><p>
A checker can customize the default error messages through a
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Properties.html"><span style="font-family:monospace">Properties</span></a>-loadable text file named
<span style="font-family:monospace">messages.properties</span> that appears in the same directory as the checker class.
The property file keys are the strings passed to <a href="api/org/checkerframework/framework/source/SourceChecker.html#report-org.checkerframework.framework.source.Result-java.lang.Object-"><span style="font-family:monospace">report</span></a>
(like <span style="font-family:monospace">type.incompatible</span>) and the values are the strings to be
printed (<span style="font-family:monospace">"cannot assign ..."</span>).
The <span style="font-family:monospace">messages.properties</span> file only need to mention the new messages that
the checker defines.
It is also allowed to override messages defined in superclasses, but this
is rarely needed.
For more details about message keys, see Section&#XA0;<a href="#compiler-message-keys">24.1.3</a>.
</p>
<!--TOC subsection id="indicating-supported-annotations" Indicating supported annotations-->
<h3 id="indicating-supported-annotations" class="subsection">28.7.1&#XA0;&#XA0;Indicating supported annotations</h3><!--SEC END --><p>A checker must indicate the annotations that it supports (make up its type
hierarchy), including whether it supports the polymorphic qualifier
<a href="api/org/checkerframework/framework/qual/PolyAll.html"><span style="font-family:monospace">@PolyAll</span></a>.</p><p>By default, a checker supports <span style="font-family:monospace">PolyAll</span>, and all annotations located in a
subdirectory called <span style="font-family:monospace">qual</span> that&#X2019;s located in the same directory as the checker.
Note that only annotations defined with the <span style="font-family:monospace">@Target(</span><span style="font-family:monospace">ElementType.TYPE_USE</span><span style="font-family:monospace">)</span>
meta-annotation (and optionally with the additional value of
<span style="font-family:monospace">ElementType.TYPE_PARAMETER</span>, but no other <span style="font-family:monospace">ElementType</span> values)
are automatically considered as supported annotations.</p><p>To indicate support for annotations that are located outside of the <span style="font-family:monospace">qual</span>
subdirectory, annotations that have other <span style="font-family:monospace">ElementType</span> values, or to indicate
whether a checker supports the polymorphic qualifier
<a href="api/org/checkerframework/framework/qual/PolyAll.html"><span style="font-family:monospace">@PolyAll</span></a>, checker writers can override the
<a href="api/org/checkerframework/framework/type/AnnotatedTypeFactory.html#createSupportedTypeQualifiers--"><span style="font-family:monospace">createSupportedTypeQualifiers</span></a>
method (open the link for details).</p><p>An aggregate checker (which extends
<a href="api/org/checkerframework/framework/source/AggregateChecker.html"><span style="font-family:monospace">AggregateChecker</span></a>) does not need to specify its
type qualifiers, but each of its component checkers should do so.</p>
<!--TOC subsection id="bundling-multiple-checkers" Bundling multiple checkers-->
<h3 id="bundling-multiple-checkers" class="subsection">28.7.2&#XA0;&#XA0;Bundling multiple checkers</h3><!--SEC END --><p>Sometimes, multiple checkers work together and should always be run
together. There are two different ways to bundle multiple checkers
together, by creating an &#X201C;aggregate checker&#X201D; or a &#X201C;compound checker&#X201D;.</p><ol class="enumerate" type=1><li class="li-enumerate">
An aggregate checker runs multiple independent, unrelated checkers. There
is no communication or cooperation among them.<p>The effect is the same as if a user passes
multiple processors to the <span style="font-family:monospace">-processor</span> command-line option.</p><p>For example, instead of a user having to run</p><pre class="verbatim">  javac -processor DistanceUnitChecker,VelocityUnitChecker,MassUnitChecker ... files ...
</pre><p>the user can write</p><pre class="verbatim">  javac -processor MyUnitCheckers ... files ...
</pre><p>if you define an aggregate checker class. Extend <a href="api/org/checkerframework/framework/source/AggregateChecker.html"><span style="font-family:monospace">AggregateChecker</span></a> and override
the <span style="font-family:monospace">getSupportedTypeCheckers</span> method, like the following:</p><pre class="verbatim">  public class MyUnitCheckers extends AggregateChecker {
    protected Collection&lt;Class&lt;? extends SourceChecker&gt;&gt; getSupportedCheckers() {
      return Arrays.asList(DistanceUnitChecker.class,
                           VelocityUnitChecker.class,
                           MassUnitChecker.class);
    }
  }
</pre><p>An example of an aggregate checker is <a href="api/org/checkerframework/checker/i18n/I18nChecker.html"><span style="font-family:monospace">I18nChecker</span></a>
(see Chapter&#XA0;<a href="#i18n-checker">12.2</a>), which consists of
<a href="api/org/checkerframework/checker/i18n/I18nSubchecker.html"><span style="font-family:monospace">I18nSubchecker</span></a> and
<a href="api/org/checkerframework/checker/i18n/LocalizableKeyChecker.html"><span style="font-family:monospace">LocalizableKeyChecker</span></a>.</p></li><li class="li-enumerate">Use a compound checker to express dependencies among checkers. Suppose it
only makes sense to run MyChecker if MyHelperChecker has already been run;
that might be the case if MyHelperChecker computes some information that
MyChecker needs to use.<p>Override
<span style="font-family:monospace">MyChecker.</span><a href="api/org/checkerframework/common/basetype/BaseTypeChecker.html#getImmediateSubcheckerClasses--"><span style="font-family:monospace">getImmediateSubcheckerClasses</span></a>
to return a list of the checkers that MyChecker depends on. Every one of
them will be run before MyChecker is run. One of MyChecker&#X2019;s subcheckers
may itself be a compound checker, and multiple checkers may declare a
dependence on the same subchecker. The Checker Framework will run each
checker once, and in an order consistent with all the dependences.</p><p>A checker obtains information from its subcheckers (those that ran before
it) by querying their <a href="api/org/checkerframework/framework/type/AnnotatedTypeFactory.html"><span style="font-family:monospace">AnnotatedTypeFactory</span></a> to
determine the types of variables.</p></li></ol>
<!--TOC subsection id="providing-command-line-options" Providing command-line options-->
<h3 id="providing-command-line-options" class="subsection">28.7.3&#XA0;&#XA0;Providing command-line options</h3><!--SEC END --><p>A checker can provide two kinds of command-line options:
boolean flags and
named string values (the standard annotation processor
options).</p>
<!--TOC subsubsection id="providing-command-line-options-boolean-flags" Boolean flags-->
<h4 id="providing-command-line-options-boolean-flags" class="subsubsection">Boolean flags</h4><!--SEC END --><p>To specify a simple boolean flag, add:</p><pre class="verbatim">@SupportedLintOptions({"flag"})
</pre><p>to your checker subclass.
The value of the flag can be queried using</p><pre class="verbatim">checker.getLintOption("flag", false)
</pre><p>The second argument sets the default value that should be returned.</p><p>To pass a flag on the command line, call javac as follows:</p><pre class="verbatim">javac -processor Mine -Alint=flag
</pre>
<!--TOC subsubsection id="providing-command-line-options-named-string-values" Named string values-->
<h4 id="providing-command-line-options-named-string-values" class="subsubsection">Named string values</h4><!--SEC END --><p>For more complicated options, one can use the standard annotation
processing <span style="font-family:monospace">@SupportedOptions</span> annotation on the checker, as in:</p><pre class="verbatim">@SupportedOptions({"info"})
</pre><p>The value of the option can be queried using</p><pre class="verbatim">checker.getOption("info")
</pre><p>To pass an option on the command line, call javac as follows:</p><pre class="verbatim">javac -processor Mine -Ainfo=p1,p2
</pre><p>The value is returned as a single string and you have to perform the
required parsing of the option.</p>
<!--TOC section id="testing-framework" Testing framework-->
<h2 id="testing-framework" class="section">28.8&#XA0;&#XA0;Testing framework</h2><!--SEC END --><p>
The Checker Framework provides a convenient way to write tests for your
checker.
It is extensively documented in file <span style="font-family:monospace">checker-framework/checker/tests/README</span>.
Also see the API documentation for
<a href="api/org/checkerframework/framework/test/CheckerFrameworkTest.html"><span style="font-family:monospace">CheckerFrameworkTest</span></a>,
which all test classes should extend.
</p>
<!--TOC section id="debugging-options" Debugging options-->
<h2 id="debugging-options" class="section">28.9&#XA0;&#XA0;Debugging options</h2><!--SEC END --><p>The Checker Framework provides debugging options that can be helpful when
writing a checker. These are provided via the standard <span style="font-family:monospace">javac</span> &#X201C;<span style="font-family:monospace">-A</span>&#X201D;
switch, which is used to pass options to an annotation processor.</p>
<!--TOC subsection id="debugging-options-detail" Amount of detail in messages-->
<h3 id="debugging-options-detail" class="subsection">28.9.1&#XA0;&#XA0;Amount of detail in messages</h3><!--SEC END --><ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">-AprintAllQualifiers</span>: print all type qualifiers, including
qualifiers like <span style="font-family:monospace">@Unqualified</span> which are usually not shown.
(Use the <span style="font-family:monospace">@InvisibleQualifier</span> meta-annotation on a qualifier to hide it.)</li><li class="li-itemize"><span style="font-family:monospace">-Adetailedmsgtext</span>: Output error/warning messages in a
stylized format that is easy for tools to parse. This is useful for
tools that run the Checker Framework and parse its output, such as IDE
plugins. See the source code of <span style="font-family:monospace">SourceChecker.java</span> for details about
the format.</li><li class="li-itemize"><span style="font-family:monospace">-AprintErrorStack</span>: print a stack trace whenever an
internal Checker Framework error occurs.</li><li class="li-itemize"><span style="font-family:monospace">-Anomsgtext</span>: use message keys (such as &#X201C;<span style="font-family:monospace">type.invalid</span>&#X201D;)
rather than full message text when reporting errors or warnings. This is
used by the Checker Framework&#X2019;s own tests, so they do not need to be
changed if the English message is updated.</li></ul>
<!--TOC subsection id="debugging-options-libraries" Stub and JDK libraries-->
<h3 id="debugging-options-libraries" class="subsection">28.9.2&#XA0;&#XA0;Stub and JDK libraries</h3><!--SEC END --><ul class="itemize"><li class="li-itemize"><span style="font-family:monospace">-Aignorejdkastub</span>:
ignore the <span style="font-family:monospace">jdk.astub</span> file in the checker directory. Files passed
through the <span style="font-family:monospace">-Astubs</span> option are still processed. This is useful
when experimenting with an alternative stub file.</li><li class="li-itemize"><span style="font-family:monospace">-Anocheckjdk</span>:
don&#X2019;t issue an error if no annotated JDK can be found.</li><li class="li-itemize"><span style="font-family:monospace">-AstubDebug</span>:
Print debugging messages while processing stub files.</li></ul>
<!--TOC subsection id="debugging-options-progress" Progress tracing-->
<h3 id="debugging-options-progress" class="subsection">28.9.3&#XA0;&#XA0;Progress tracing</h3><!--SEC END --><ul class="itemize"><li class="li-itemize"><span style="font-family:monospace">-Afilenames</span>: print the name of each file before type-checking it.</li><li class="li-itemize"><span style="font-family:monospace">-Ashowchecks</span>: print debugging information for each
pseudo-assignment check (as performed by
<a href="api/org/checkerframework/common/basetype/BaseTypeVisitor.html"><span style="font-family:monospace">BaseTypeVisitor</span></a>; see
Section&#XA0;<a href="#extending-visitor">28.4</a>).</li></ul>
<!--TOC subsection id="debugging-options-output-args" Saving the command-line arguments to a file-->
<h3 id="debugging-options-output-args" class="subsection">28.9.4&#XA0;&#XA0;Saving the command-line arguments to a file</h3><!--SEC END --><ul class="itemize"><li class="li-itemize"><span style="font-family:monospace">-AoutputArgsToFile</span>:
This saves the final command-line parameters as passed to the compiler in a file.
This file can be used as a script (if the file is marked as executable on Unix, or
if it includes a <span style="font-family:monospace">.bat</span> extension on Windows) to re-execute the same compilation command.
Note that this argument cannot be included in a file containing command-line arguments
passed to the compiler using the @argfile syntax.<p>Example usage: <span style="font-family:monospace">-AoutputArgsToFile=/home/username/scriptfile</span></p></li></ul>
<!--TOC subsection id="debugging-options-misc" Miscellaneous debugging options-->
<h3 id="debugging-options-misc" class="subsection">28.9.5&#XA0;&#XA0;Miscellaneous debugging options</h3><!--SEC END --><ul class="itemize"><li class="li-itemize"><span style="font-family:monospace">-Acfgviz</span>:
Mechanism to visualize the control flow graph (CFG) of
all the methods and code fragments
analyzed by the dataflow analysis (Section&#XA0;<a href="#dataflow">28.6</a>).
The graph also contains information about flow-sensitively refined
types of various expressions at many program points.
The argument is a sequence of values or key-value pairs.
The first argument has to be the fully-qualified name of the
<span style="font-family:monospace">org.checkerframework.dataflow.cfg.CFGVisualizer</span> implementation
that should be used. The remaining values or key-value pairs are
passed to <span style="font-family:monospace">CFGVisualizer.init</span>.</li><li class="li-itemize"><span style="font-family:monospace">-Aflowdotdir</span>:
Specify directory for <span style="font-family:monospace">.dot</span> files visualizing the CFG.
Short-hand for
<span style="font-family:monospace">-Acfgviz=org.checkerframework.dataflow.cfg.DOTCFGVisualizer,outdir=xyz</span></li><li class="li-itemize"><span style="font-family:monospace">-Averbosecfg</span>:
Enable additional output in the CFG visualization.
Equivalent to passing <span style="font-family:monospace">verbose</span> to <span style="font-family:monospace">cfgviz</span>, e.g. as in
<span style="font-family:monospace">-Acfgviz=MyClass,verbose</span></li><li class="li-itemize"><span style="font-family:monospace">-AresourceStats</span>:
Whether to output resource statistics at JVM shutdown.</li></ul>
<!--TOC subsection id="debugging-options-examples" Examples-->
<h3 id="debugging-options-examples" class="subsection">28.9.6&#XA0;&#XA0;Examples</h3><!--SEC END --><p>The following example demonstrates how these options are used:</p><pre class="verbatim">$ javac -processor org.checkerframework.checker.interning.InterningChecker \
    examples/InternedExampleWithWarnings.java -Ashowchecks -Anomsgtext -Afilenames

[InterningChecker] InterningExampleWithWarnings.java
 success (line  18): STRING_LITERAL "foo"
     actual: DECLARED @org.checkerframework.checker.interning.qual.Interned java.lang.String
   expected: DECLARED @org.checkerframework.checker.interning.qual.Interned java.lang.String
 success (line  19): NEW_CLASS new String("bar")
     actual: DECLARED java.lang.String
   expected: DECLARED java.lang.String
examples/InterningExampleWithWarnings.java:21: (not.interned)
    if (foo == bar)
            ^
 success (line  22): STRING_LITERAL "foo == bar"
     actual: DECLARED @org.checkerframework.checker.interning.qual.Interned java.lang.String
   expected: DECLARED java.lang.String
1 error
</pre>
<!--TOC subsection id="debugging-options-external" Using an external debugger-->
<h3 id="debugging-options-external" class="subsection">28.9.7&#XA0;&#XA0;Using an external debugger</h3><!--SEC END --><p>
You can use any standard debugger to observe the execution of your checker.
Set the execution main class to <span style="font-family:monospace">com.sun.tools.javac.Main</span>, and insert
the Checker Framework javac.jar (resides in
<span style="font-family:monospace">$CHECKERFRAMEWORK/checker/dist/javac.jar</span>). If using an IDE, it is
recommended that you add <span style="font-family:monospace">.../jsr308-langtools</span> as a project, so you
can step into its source code if needed.
</p><p>You can also set up remote (or local) debugging using the following command as a template:</p><pre class="verbatim">java -jar $CHECKERFRAMEWORK/framework/dist/framework.jar \
    -J-Xdebug -J-Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005 \
    -processor org.checkerframework.checker.nullness.NullnessChecker \
    src/sandbox/FileToCheck.java

</pre>
<!--TOC section id="documenting-a-checker" Documenting the checker-->
<h2 id="documenting-a-checker" class="section">28.10&#XA0;&#XA0;Documenting the checker</h2><!--SEC END --><p>This section describes how to write a chapter for this manual that
describes a new type-checker. This is a prerequisite to having your
type-checker distributed with the Checker Framework, which is the best way
for users to find it and for it to be kept up to date with Checker
Framework changes. Even if you do not want your checker distributed with
the Checker Framework, these guidelines may help you write better
documentation.</p><p>When writing a chapter about a new type-checker, see the existing chapters
for inspiration. (But recognize that the existing chapters aren&#X2019;t perfect:
maybe they can be improved too.)</p><p>A chapter in the Checker Framework manual should generally have the
following sections:</p><dl class="description"><dt class="dt-description">
<span style="font-weight:bold">Chapter: Belly Rub Checker</span></dt><dd class="dd-description">
The text before the first section in the chapter should state the
guarantee that the checker provides and why it is important. It should
give an overview of the concepts. It should state how to run the checker.
</dd><dt class="dt-description"><span style="font-weight:bold">Section: Belly Rub Annotations</span></dt><dd class="dd-description">
This section includes descriptions of the annotations with links to the
Javadoc. Separate type annotations from declaration annotations, and put
any type annotations that a programmer may not write (they are only used
internally by the implementation) last within variety of annotation.<p>Draw a diagram of the type hierarchy. A textual description of
the hierarchy is not sufficient; the diagram really helps readers to
understand the system.</p><p>The Javadoc for the annotations deserves the same care as the manual
chapter. Each annotation&#X2019;s Javadoc comment should use the
<span style="font-family:monospace">@checker_framework.manual</span> Javadoc taglet to refer to the chapter that
describes the checker; see <a href="api/org/checkerframework/javacutil/dist/ManualTaglet.html"><span style="font-family:monospace">ManualTaglet</span></a>.
</p></dd><dt class="dt-description"><span style="font-weight:bold">Section: What the Belly Rub Checker checks</span></dt><dd class="dd-description">
This section gives more details about when an error is issued, with examples.
This section may be omitted if the checker does not contain special
type-checking rules &#X2014; that is, if the checker only enforces the usual
Java subtyping rules.
</dd><dt class="dt-description"><span style="font-weight:bold">Section: Examples</span></dt><dd class="dd-description">
Code examples.
</dd></dl><p>Sometimes you can omit some of the above sections. Sometimes there are
additional sections, such as tips on suppressing warnings, comparisons to
other tools, and run-time support.</p><p>You will create a new <span style="font-family:monospace">belly-rub-checker.tex</span> file,
then <code>\input</code> it at a logical place in <span style="font-family:monospace">manual.tex</span> (not
necessarily as the last checker-related chapter). Also add two references
to the checker&#X2019;s chapter: one at the beginning of
chapter&#XA0;<a href="#introduction">1</a>, and identical text in
Section&#XA0;<a href="#type-refinement-runtime-tests">23.4.3</a> (both of these lists appear in
the same order as the manual chapters, to help us notice if anything is
missing).</p><p>Every chapter and (sub)*section should have a label defined <em>within</em> the
<code>\section</code> command. Section labels should start with the checker
name (as in <code>\label{bellyrub-examples}</code>) and not with &#X201C;<span style="font-family:monospace">sec:</span>&#X201D;.
These conventions are for the benefit of the Hevea program that produces
the HTML version of the manual.</p><p>Don&#X2019;t forget to write Javadoc for any annotations that the checker uses.
That is part of the documentation and is the first thing that many users
may see. Also ensure that the Javadoc links back to the manual, using the
<span style="font-family:monospace">@checker_framework.manual</span> custom Javadoc tag.</p><p>You should also integrate your new checker with the Eclipse plugin.
</p>
<!--TOC section id="javac-tips" javac implementation survival guide-->
<h2 id="javac-tips" class="section">28.11&#XA0;&#XA0;javac implementation survival guide</h2><!--SEC END --><p>Since this section of the manual was written, the useful &#X201C;The Hitchhiker&#X2019;s
Guide to javac&#X201D; has become available at
<a href="http://openjdk.java.net/groups/compiler/doc/hhgtjavac/index.html"><span style="font-family:monospace">http://openjdk.java.net/groups/compiler/doc/hhgtjavac/index.html</span></a>.
See it first, and then refer to this section. (This section of the manual
should be revised, or parts eliminated, in light of that document.)</p><p>A checker built using the Checker Framework makes use of a few interfaces
from the underlying compiler (Oracle&#X2019;s OpenJDK javac).
This section describes those interfaces.</p>
<!--TOC subsection id="compiler-information" Checker access to compiler information-->
<h3 id="compiler-information" class="subsection">28.11.1&#XA0;&#XA0;Checker access to compiler information</h3><!--SEC END --><p>The compiler uses and exposes three hierarchies to model the Java
source code and classfiles.</p>
<!--TOC subsubsection id="javac-types" Types &#X2014; Java Language Model API-->
<h4 id="javac-types" class="subsubsection">Types &#X2014; Java Language Model API</h4><!--SEC END --><p>A <a href="http://docs.oracle.com/javase/8/docs/api/javax/lang/model/type/TypeMirror.html?is-external=true"><span style="font-family:monospace">TypeMirror</span></a> represents a Java type.
</p><p>
There is a <span style="font-family:monospace">TypeMirror</span> interface to represent each type kind,
e.g., <span style="font-family:monospace">PrimitiveType</span> for primitive types, <span style="font-family:monospace">ExecutableType</span>
for method types, and <span style="font-family:monospace">NullType</span> for the type of the <span style="font-family:monospace">null</span> literal.
</p><p><span style="font-family:monospace">TypeMirror</span> does not represent annotated types though. A checker
should use the Checker Framework types API,
<a href="api/org/checkerframework/framework/type/AnnotatedTypeMirror.html"><span style="font-family:monospace">AnnotatedTypeMirror</span></a>, instead. <span style="font-family:monospace">AnnotatedTypeMirror</span>
parallels the <span style="font-family:monospace">TypeMirror</span> API, but also present the type annotations
associated with the type.</p><p>The Checker Framework and the checkers use the types API extensively.</p>
<!--TOC subsubsection id="javac-elements" Elements &#X2014; Java Language Model API-->
<h4 id="javac-elements" class="subsubsection">Elements &#X2014; Java Language Model API</h4><!--SEC END --><p>An <a href="http://docs.oracle.com/javase/8/docs/api/javax/lang/model/element/Element.html?is-external=true"><span style="font-family:monospace">Element</span></a> represents a potentially-public
declaration that can be accessed from elsewhere: classes, interfaces, methods, constructors, and
fields. <span style="font-family:monospace">Element</span> represents elements found in both source
code and bytecode.</p><p>There is an <span style="font-family:monospace">Element</span> interface to represent each construct, e.g.,
<span style="font-family:monospace">TypeElement</span> for class/interfaces, <span style="font-family:monospace">ExecutableElement</span> for
methods/constructors, <span style="font-family:monospace">VariableElement</span> for local variables and
method parameters.</p><p>If you need to operate on the declaration level, always use elements rather
than trees
(see below). This allows the code to work on
both source and bytecode elements.</p><p>Example: retrieve declaration annotations, check variable
modifiers (e.g., <span style="font-family:monospace">strictfp</span>, <span style="font-family:monospace">synchronized</span>)</p>
<!--TOC subsubsection id="javac-trees" Trees &#X2014; Compiler Tree API-->
<h4 id="javac-trees" class="subsubsection">Trees &#X2014; Compiler Tree API</h4><!--SEC END --><p>A <a href="https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/tree/Tree.html?is-external=true"><span style="font-family:monospace">Tree</span></a> represents a syntactic unit in the source code,
like a method declaration, statement, block, <span style="font-family:monospace">for</span> loop, etc. Trees only
represent source code to be compiled (or found in <span style="font-family:monospace">-sourcepath</span>);
no tree is available for classes read from bytecode.</p><p>There is a Tree interface for each Java source structure, e.g.,
<span style="font-family:monospace">ClassTree</span> for class declaration, <span style="font-family:monospace">MethodInvocationTree</span>
for a method invocation, and <span style="font-family:monospace">ForEachTree</span> for an enhanced-for-loop
statement.</p><p>You should limit your use of trees. A checker uses Trees mainly to
traverse the source code and retrieve the types/elements corresponding to
them. Then, the checker performs any needed checks on the types/elements instead.</p>
<!--TOC subsubsection id="using-the-apis" Using the APIs-->
<h4 id="using-the-apis" class="subsubsection">Using the APIs</h4><!--SEC END --><p>The three APIs use some common idioms and conventions; knowing them will
help you to create your checker.</p><p><em>Type-checking</em>:
Do not use <span style="font-family:monospace">instanceof</span> to determine the class of the object,
because you cannot necessarily predict the run-time type of the object that
implements an interface. Instead, use the <span style="font-family:monospace">getKind()</span> method. The
method returns <a href="http://docs.oracle.com/javase/8/docs/api/javax/lang/model/type/TypeKind.html?is-external=true"><span style="font-family:monospace">TypeKind</span></a>,
<a href="http://docs.oracle.com/javase/8/docs/api/javax/lang/model/element/ElementKind.html?is-external=true"><span style="font-family:monospace">ElementKind</span></a>, and <a href="https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/tree/Tree.Kind.html?is-external=true"><span style="font-family:monospace">Tree.Kind</span></a>
for the three interfaces, respectively.</p><p><em>Visitors and Scanners</em>:
The compiler and the Checker Framework use the visitor pattern
extensively. For example, visitors are used to traverse the source tree
(<a href="api/org/checkerframework/common/basetype/BaseTypeVisitor.html"><span style="font-family:monospace">BaseTypeVisitor</span></a> extends
<a href="https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/util/TreePathScanner.html?is-external=true"><span style="font-family:monospace">TreePathScanner</span></a>) and for type
checking (<a href="api/org/checkerframework/framework/type/treeannotator/TreeAnnotator.html"><span style="font-family:monospace">TreeAnnotator</span></a> implements
<a href="https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/tree/TreeVisitor.html?is-external=true"><span style="font-family:monospace">TreeVisitor</span></a>).</p><p><em>Utility classes</em>:
Some useful methods appear in a utility class. The Oracle convention is that
the utility class for a <span style="font-family:monospace">Foo</span> hierarchy is <span style="font-family:monospace">Foos</span> (e.g.,
<a href="http://docs.oracle.com/javase/8/docs/api/javax/lang/model/util/Types.html?is-external=true"><span style="font-family:monospace">Types</span></a>, <a href="http://docs.oracle.com/javase/8/docs/api/javax/lang/model/util/Elements.html?is-external=true"><span style="font-family:monospace">Elements</span></a>, and
<a href="https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/util/Trees.html?is-external=true"><span style="font-family:monospace">Trees</span></a>). The Checker Framework uses a common
<span style="font-family:monospace">Utils</span> suffix instead (e.g., <a href="api/org/checkerframework/javacutil/TypesUtils.html"><span style="font-family:monospace">TypesUtils</span></a>,
<a href="api/org/checkerframework/javacutil/TreeUtils.html"><span style="font-family:monospace">TreeUtils</span></a>, <a href="api/org/checkerframework/javacutil/ElementUtils.html"><span style="font-family:monospace">ElementUtils</span></a>), with one
notable exception: <a href="api/org/checkerframework/framework/util/AnnotatedTypes.html"><span style="font-family:monospace">AnnotatedTypes</span></a>.</p>
<!--TOC subsection id="checker-as-annotation-processor" How a checker fits in the compiler as an annotation processor-->
<h3 id="checker-as-annotation-processor" class="subsection">28.11.2&#XA0;&#XA0;How a checker fits in the compiler as an annotation processor</h3><!--SEC END --><p>The Checker Framework builds on the Annotation Processing API
introduced in Java 6. A type annotation processor is one that extends
<a href="api/org/checkerframework/javacutil/AbstractTypeProcessor.html"><span style="font-family:monospace">AbstractTypeProcessor</span></a>; these get run on each class
source file after the compiler confirms that the class is valid Java code.</p><p>The most important methods of <a href="api/org/checkerframework/javacutil/AbstractTypeProcessor.html"><span style="font-family:monospace">AbstractTypeProcessor</span></a>
are <span style="font-family:monospace">typeProcess</span> and <span style="font-family:monospace">getSupportedSourceVersion</span>. The former
class is where you would insert any sort of method call to walk the AST,
and the latter just returns a constant indicating that we are targeting
version 8 of the compiler. Implementing these two methods should be enough
for a basic plugin; see the Javadoc for the class for other methods that
you may find useful later on.</p><p>The Checker Framework uses Oracle&#X2019;s Tree API to access a program&#X2019;s AST.
The Tree API is specific to the Oracle OpenJDK, so the Checker Framework only
works with the OpenJDK javac, not with Eclipse&#X2019;s compiler ecj or with
<a href="http://gcc.gnu.org/java/">gcj</a>. This also limits the tightness of
the integration of the Checker Framework into other IDEs such as <a href="http://www.jetbrains.com/idea/">IntelliJ IDEA</a>.
An implementation-neutral API would be preferable.
In the future, the Checker Framework
can be migrated to use the Java Model AST of JSR 198 (Extension API for
Integrated Development Environments)&#XA0;[<a href="#JSR198">Cro06</a>], which gives access to
the source code of a method. But, at present no tools
implement JSR&#XA0;198. Also see Section&#XA0;<a href="#ast-traversal">28.4.1</a>.</p>
<!--TOC subsubsection id="learning-more-about-javac" Learning more about javac-->
<h4 id="learning-more-about-javac" class="subsubsection">Learning more about javac</h4><!--SEC END --><p>Sun&#X2019;s javac compiler interfaces can be daunting to a
newcomer, and its documentation is a bit sparse. The Checker Framework
aims to abstract a lot of these complexities.
You do not have to understand the implementation of javac to
build powerful and useful checkers.
Beyond this document,
other useful resources include the Java Infrastructure
Developer&#X2019;s guide at
<a href="http://wiki.netbeans.org/Java_DevelopersGuide"><span style="font-family:monospace">http://wiki.netbeans.org/Java_DevelopersGuide</span></a> and the compiler
mailing list archives at
<a href="http://news.gmane.org/gmane.comp.java.openjdk.compiler.devel"><span style="font-family:monospace">http://news.gmane.org/gmane.comp.java.openjdk.compiler.devel</span></a>
(subscribe at
<a href="http://mail.openjdk.java.net/mailman/listinfo/compiler-dev"><span style="font-family:monospace">http://mail.openjdk.java.net/mailman/listinfo/compiler-dev</span></a>).</p>
<!--TOC section id="integrating-a-checker" Integrating a checker with the Checker Framework-->
<h2 id="integrating-a-checker" class="section">28.12&#XA0;&#XA0;Integrating a checker with the Checker Framework</h2><!--SEC END --><p>To integrate a new checker with the Checker Framework release, perform
the following:</p><ul class="itemize"><li class="li-itemize">Add a <span style="font-family:monospace">XXX-tests</span> build target in file
<span style="font-family:monospace">checker-framework/checker/build.xml</span> and ensure all tests pass.</li><li class="li-itemize">Make sure <span style="font-family:monospace">all-tests</span> tests the new checker.</li><li class="li-itemize">Extend the <span style="font-family:monospace">check-compilermsgs</span> target to include the
compiler messages property file of the new checker in
the <span style="font-family:monospace">checker-args</span> list. (Keep the list in alphabetical order.)</li><li class="li-itemize">Make sure <span style="font-family:monospace">check-compilermsgs</span> and <span style="font-family:monospace">check-purity</span> run
without warnings or errors.</li></ul><hr>
<!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note1" href="#text1">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Actually,
there is a standard API for Java ASTs &#X2014; JSR 198 (Extension API for
Integrated Development Environments)&#XA0;[<a href="#JSR198">Cro06</a>]. If tools were to
implement it
(which would just require writing wrappers or adapters), then the Checker
Framework and similar tools could be portable among different compilers and
IDEs.</div></dd></dl>
<!--END NOTES-->
<!--TOC chapter id="external-tools" Integration with external tools-->
<h1 id="external-tools" class="chapter">Chapter&#XA0;29&#XA0;&#XA0;Integration with external tools</h1><!--SEC END --><p>This chapter discusses how to run a checker from the command line, from a
build system, or from an IDE. You can skip to the appropriate section:</p><ul class="itemize"><li class="li-itemize">
javac (Section&#XA0;<a href="#javac-installation">29.1</a>)
</li><li class="li-itemize">Ant (Section&#XA0;<a href="#ant-task">29.2</a>)
</li><li class="li-itemize">Maven (Section&#XA0;<a href="#maven">29.3</a>)
</li><li class="li-itemize">Gradle (Section&#XA0;<a href="#gradle">29.4</a>)
</li><li class="li-itemize">Android plugin for Gradle (Section&#XA0;<a href="#android-gradle">29.5</a>)
</li><li class="li-itemize">IntelliJ IDEA (Section&#XA0;<a href="#intellij">29.6</a>)
</li><li class="li-itemize">Eclipse (Section&#XA0;<a href="#eclipse">29.7</a>)
</li><li class="li-itemize">tIDE (Section&#XA0;<a href="#tide">29.8</a>)
</li></ul><p>If your build system or IDE is not listed above, you should customize how
it runs the javac command on your behalf. See your build system or IDE
documentation to learn how to
customize it, adapting the instructions for javac in Section&#XA0;<a href="#javac-installation">29.1</a>.
If you make another tool support running a checker, please
inform us via the
<a href="https://groups.google.com/forum/#!forum/checker-framework-discuss">mailing
list</a> or
<a href="https://github.com/typetools/checker-framework/issues">issue tracker</a> so
we can add it to this manual.</p><p>All examples in this chapter are in the public domain, with no copyright nor
licensing restrictions.</p>
<!--TOC section id="javac-installation" Javac compiler-->
<h2 id="javac-installation" class="section">29.1&#XA0;&#XA0;Javac compiler</h2><!--SEC END --><p>To perform pluggable type-checking, run the <span style="font-family:monospace">javac</span> compiler with the
Checker Framework on the classpath.
There are three ways to achieve this. You can use any
one of them. However, if you are using the Windows command shell, you must
use the last one.
</p><ul class="itemize"><li class="li-itemize">
Option 1:
Add directory
<span style="font-family:monospace">.../checker-framework-2.0.0/checker/bin</span> to your path, <em>before</em> any other
directory that contains a <span style="font-family:monospace">javac</span> executable.<p>If you are
using the bash shell, a way to do this is to add the following to your
<code>~/.profile</code> (or alternately <code>~/.bash_profle</code> or <code>~/.bashrc</code>) file:
</p><pre class="verbatim">  export CHECKERFRAMEWORK=${HOME}/checker-framework-2.0.0
  export PATH=${CHECKERFRAMEWORK}/checker/bin:${PATH}
</pre><p>then log out and back in to ensure that the environment variable
setting takes effect.</p><p>Now, whenever you run <span style="font-family:monospace">javac</span>, you will use the &#X201C;Checker
Framework compiler&#X201D;. It is exactly the same as the OpenJDK compiler,
with two small differences: it includes the Checker Framework jar file
on its classpath, and it recognizes type annotations in comments (see
Section&#XA0;<a href="#annotations-in-comments">25.2.1</a>).</p></li><li class="li-itemize">
Option 2:
Whenever this document tells you to run <span style="font-family:monospace">javac</span>, you
can instead run <span style="font-family:monospace">$CHECKERFRAMEWORK/checker/bin/javac</span>.
<p>You can simplify this by introducing an alias. Then,
whenever this document tells you to run <span style="font-family:monospace">javac</span>, instead use that
alias. Here is the syntax for your
<code>~/.bashrc</code> file:
</p><pre class="verbatim">  export CHECKERFRAMEWORK=${HOME}/checker-framework-2.0.0
  alias javacheck='$CHECKERFRAMEWORK/checker/bin/javac'
</pre><p>If you are using a Java 7 JVM, then add command-line arguments to so
indicate:</p><pre class="verbatim">  export CHECKERFRAMEWORK=${HOME}/checker-framework-2.0.0
  alias javacheck='$CHECKERFRAMEWORK/checker/bin/javac -source 7 -target 7'
</pre><p>If you do not add the <span style="font-family:monospace">-source 7 -target 7</span> command-line arguments, you
may get the following error when running a class that was compiled by
javacheck:
</p><pre class="verbatim">  UnsupportedClassVersionError: ... : Unsupported major.minor version 52.0
</pre></li><li class="li-itemize">Option 3:
Whenever this document tells you to run <span style="font-family:monospace">javac</span>, instead
run checker.jar via <span style="font-family:monospace">java</span> (not <span style="font-family:monospace">javac</span>) as in:<pre class="verbatim">  java -jar $CHECKERFRAMEWORK/checker/dist/checker.jar ...
</pre><p>You can simplify the above command by introducing an alias. Then,
whenever this document tells you to run <span style="font-family:monospace">javac</span>, instead use that
alias. For example:</p><pre class="verbatim">  # Unix
  export CHECKERFRAMEWORK=${HOME}/checker-framework-2.0.0
  alias javacheck='java -jar $CHECKERFRAMEWORK/checker/dist/checker.jar'

  # Windows
  set CHECKERFRAMEWORK = C:\Program Files\checker-framework-2.0.0\
  doskey javacheck=java -jar %CHECKERFRAMEWORK%\checker\dist\checker.jar $*
</pre><p>and add <span style="font-family:monospace">-source 7 -target 7</span> if you use a Java 7 JVM.</p><p>(Explanation for advanced users: More generally, anywhere that you would use <span style="font-family:monospace">javac.jar</span>, you can substitute
<span style="font-family:monospace">$CHECKERFRAMEWORK/checker/dist/checker.jar</span>;
the result is to use the Checker
Framework compiler instead of the regular <span style="font-family:monospace">javac</span>.)</p></li></ul><p>To ensure that you are using the Checker Framework compiler, run
<span style="font-family:monospace">javac -version</span> (possibly using the
full pathname to <span style="font-family:monospace">javac</span> or the alias, if you did not add the Checker
Framework <span style="font-family:monospace">javac</span> to your path).
The output should be:</p><pre class="verbatim">  javac 1.8.0-jsr308-2.0.0
</pre>
<!--TOC section id="ant-task" Ant task-->
<h2 id="ant-task" class="section">29.2&#XA0;&#XA0;Ant task</h2><!--SEC END --><p>If you use the <a href="http://ant.apache.org/">Ant</a> build tool to compile
your software, then you can add an Ant task that runs a checker. We assume
that your Ant file already contains a compilation target that uses the
<span style="font-family:monospace">javac</span> task.</p><ol class="enumerate" type=1><li class="li-enumerate">
Set the <span style="font-family:monospace">jsr308javac</span> property:<pre class="verbatim">  &lt;property environment="env"/&gt;

  &lt;property name="checkerframework" value="${env.CHECKERFRAMEWORK}" /&gt;

  &lt;!-- On Mac/Linux, use the javac shell script; on Windows, use javac.bat --&gt;
  &lt;condition property="cfJavac" value="javac.bat" else="javac"&gt;
      &lt;os family="windows" /&gt;
  &lt;/condition&gt;

  &lt;presetdef name="jsr308.javac"&gt;
    &lt;javac fork="yes" executable="${checkerframework}/checker/bin/${cfJavac}" &gt;
      &lt;!-- JSR-308-related compiler arguments --&gt;
      &lt;compilerarg value="-version"/&gt;
      &lt;compilerarg value="-implicit:class"/&gt;
    &lt;/javac&gt;
  &lt;/presetdef&gt;
</pre></li><li class="li-enumerate"><span style="font-weight:bold">Duplicate</span> the compilation target, then <span style="font-weight:bold">modify</span> it slightly as
indicated in this example:<pre class="verbatim">  &lt;target name="check-nullness"
          description="Check for null pointer dereferences"
          depends="clean,..."&gt;
    &lt;!-- use jsr308.javac instead of javac --&gt;
    &lt;jsr308.javac ... &gt;
      &lt;compilerarg line="-processor org.checkerframework.checker.nullness.NullnessChecker"/&gt;
      &lt;!-- optional, to not check uses of library methods:
        &lt;compilerarg value="-AskipUses=^(java\.awt\.|javax\.swing\.)"/&gt;
      --&gt;
      &lt;compilerarg line="-Xmaxerrs 10000"/&gt;
      ...
    &lt;/jsr308.javac&gt;
  &lt;/target&gt;
</pre><p>Fill in each ellipsis (&#X2026;) from the original compilation target.</p><p>In the example, the target is named <span style="font-family:monospace">check-nullness</span>, but you can
name it whatever you like.
</p></li></ol>
<!--TOC subsection id="ant-task-explanation" Explanation-->
<h3 id="ant-task-explanation" class="subsection">29.2.1&#XA0;&#XA0;Explanation</h3><!--SEC END --><p>This section explains each part of the Ant task.</p><ol class="enumerate" type=1><li class="li-enumerate">
Definition of <span style="font-family:monospace">jsr308.javac</span>:<p>The <span style="font-family:monospace">fork</span> field of the <span style="font-family:monospace">javac</span> task
ensures that an external javac program is called. Otherwise, Ant will run
javac via a Java method call, and there is no guarantee that it will get
the Checker Framework compiler that is distributed with the Checker Framework.</p><p>The <span style="font-family:monospace">-version</span> compiler argument is just for debugging; you may omit
it.</p><p>The <span style="font-family:monospace">-implicit:class</span> compiler argument causes annotation processing
to be performed on implicitly compiled files. (An implicitly compiled file
is one that was not specified on the command line, but for which the source
code is newer than the <span style="font-family:monospace">.class</span> file.) This is the default, but
supplying the argument explicitly suppresses a compiler warning.</p></li><li class="li-enumerate">The <span style="font-family:monospace">check-nullness</span> target:<p>The target assumes the existence of a <span style="font-family:monospace">clean</span> target that removes all
<span style="font-family:monospace">.class</span> files. That is necessary because Ant&#X2019;s <span style="font-family:monospace">javac</span> target
doesn&#X2019;t re-compile <span style="font-family:monospace">.java</span> files for which a <span style="font-family:monospace">.class</span> file
already exists.</p><p>The <span style="font-family:monospace">-processor ...</span> compiler argument indicates which checker to
run. You can supply additional arguments to the checker as well.</p></li></ol>
<!--TOC section id="maven" Maven-->
<h2 id="maven" class="section">29.3&#XA0;&#XA0;Maven</h2><!--SEC END --><p>If you use the <a href="http://maven.apache.org/">Maven</a> tool,
then you can enable Checker Framework checkers by following the
instructions below.</p><p>See the directory <span style="font-family:monospace">examples/MavenExample/</span> for examples of the use of
Maven build files that run a checker. These examples can be used to verify that
Maven is correctly downloading the Checker Framework from
<a href="http://search.maven.org/#search%7Cga%7C1%7Corg.checkerframework">Maven
Central</a> and executing it.</p><p>There are two general ways you can configure your Maven buildfile,
corresponding to the two ways to run the Checker Framework:
</p><ul class="itemize"><li class="li-itemize">
Use the Type Annotations compiler. You need to use this if you write
annotations in comments (see Section&#XA0;<a href="#annotations-in-comments">25.2.1</a>).
</li><li class="li-itemize">Use the standard Java 8 compiler.
</li></ul><p>Please note that the <span style="font-family:monospace">-AoutputArgsToFile</span> command-line option
(see Section&#XA0;<a href="#debugging-options-output-args">28.9.4</a>) and shorthands for built-in checkers
(see Section&#XA0;<a href="#shorthand-for-checkers">2.2.4</a>) are not available when
following these instructions. Both these features are available only when a checker is
launched via <span style="font-family:monospace">checker.jar</span> such as when <span style="font-family:monospace">$CHECKERFRAMEWORK/checker/bin/javac</span>
is run. The Gradle instructions in this section
bypass <span style="font-family:monospace">checker.jar</span> and cause the compiler to run a
checker as an annotation processor directly.</p><ol class="enumerate" type=1><li class="li-enumerate">Declare a dependency on the Checker Framework artifacts. Find the
existing <span style="font-family:monospace">&lt;dependencies&gt;</span> section and add the following new
<span style="font-family:monospace">&lt;dependency&gt;</span> items:<pre>
    &lt;dependencies&gt;
        ... existing &lt;dependency&gt; items ...

        &lt;!-- annotations from the Checker Framework: nullness, interning, locking, ... --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.checkerframework&lt;/groupId&gt;
            &lt;artifactId&gt;checker-qual&lt;/artifactId&gt;
            &lt;version&gt;2.0.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.checkerframework&lt;/groupId&gt;
            &lt;artifactId&gt;checker&lt;/artifactId&gt;
            &lt;version&gt;2.0.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- The type annotations compiler - uncomment if desired --&gt;
        &lt;!-- &lt;dependency&gt;
            &lt;groupId&gt;org.checkerframework&lt;/groupId&gt;
            &lt;artifactId&gt;compiler&lt;/artifactId&gt;
            &lt;version&gt;2.0.0&lt;/version&gt;
        &lt;/dependency&gt; --&gt;
        &lt;!-- The annotated JDK to use (change to jdk7 if using Java 7) --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.checkerframework&lt;/groupId&gt;
            &lt;artifactId&gt;jdk8&lt;/artifactId&gt;
            &lt;version&gt;2.0.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</pre></li><li class="li-enumerate">Use Maven properties to hold the locations of the
annotated JDK and (if using annotations in comments), the type annotations compiler. Both were declared as Maven dependencies above.
To set the value of these properties automatically, use the Maven Dependency plugin.<p>First, create the properties in the <span style="font-family:monospace">properties</span> section of the POM:</p><pre>
&lt;properties&gt;
    &lt;!-- These properties will be set by the Maven Dependency plugin --&gt;
    &lt;!-- Change to jdk7 if using Java 7 --&gt;
    &lt;annotatedJdk&gt;${org.checkerframework:jdk8:jar}&lt;/annotatedJdk&gt;
    &lt;!-- Uncomment to use the type annotations compiler. --&gt;
    &lt;!-- &lt;typeAnnotationsJavac&gt;${org.checkerframework:compiler:jar}&lt;/typeAnnotationsJavac&gt; --&gt;
&lt;/properties&gt;
</pre><p>Change the reference to the <span style="font-family:monospace">maven-dependency-plugin</span> within the <span style="font-family:monospace">&lt;plugins&gt;</span>
section, or add it if it is not present.</p><pre>
    &lt;plugin&gt;
        &lt;!-- This plugin will set properties values using dependency information --&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.3&lt;/version&gt;
        &lt;executions&gt;
            &lt;execution&gt;
                &lt;goals&gt;
                    &lt;goal&gt;properties&lt;/goal&gt;
                &lt;/goals&gt;
            &lt;/execution&gt;
        &lt;/executions&gt;
    &lt;/plugin&gt;
</pre></li><li class="li-enumerate">Direct the Maven compiler plugin to use the desired checkers.
Change the reference to the <span style="font-family:monospace">maven-compiler-plugin</span> within the <span style="font-family:monospace">&lt;plugins&gt;</span>
section, or add it if it is not present.<p>For example, to use the <span style="font-family:monospace">org.checkerframework.checker.nullness.NullnessChecker</span>:</p><div style="font-size:small;">
<pre>
    &lt;plugin&gt;
        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
        &lt;version&gt;3.3&lt;/version&gt;
        &lt;configuration&gt;
            &lt;!-- Change source and target to 1.7 if using Java 7 --&gt;
            &lt;source&gt;1.8&lt;/source&gt;
            &lt;target&gt;1.8&lt;/target&gt;
            &lt;fork&gt;true&lt;/fork&gt;
            &lt;annotationProcessors&gt;
                &lt;!-- Add all the checkers you want to enable here --&gt;
                &lt;annotationProcessor&gt;org.checkerframework.checker.nullness.NullnessChecker&lt;/annotationProcessor&gt;
            &lt;/annotationProcessors&gt;
            &lt;compilerArgs&gt;
                &lt;!-- location of the annotated JDK, which comes from a Maven dependency --&gt;
                &lt;arg&gt;-Xbootclasspath/p:${annotatedJdk}&lt;/arg&gt;
                &lt;!-- Uncomment the following line to use the type annotations compiler. --&gt;
                &lt;!-- &lt;arg&gt;-J-Xbootclasspath/p:${typeAnnotationsJavac}&lt;/arg&gt; --&gt;
            &lt;/compilerArgs&gt;
        &lt;/configuration&gt;
    &lt;/plugin&gt;
</pre>
</div><p>Now, building with Maven should run the checkers during compilation.</p><p>Notice that using this approach, no external setup is necessary,
so your Maven build should be reproducible on any server.</p><p>If you want to allow Maven to compile your code without running the
checkers, you may want to move the declarations above to within a Maven
profile, so that the checkers run only if the profile was enabled.</p></li></ol>
<!--TOC section id="gradle" Gradle-->
<h2 id="gradle" class="section">29.4&#XA0;&#XA0;Gradle</h2><!--SEC END --><p>If you use <a href="http://gradle.org/">Gradle</a>,
then you can run a checker by following the instructions below.</p><p>These instructions can be used with Java 7 or Java 8. If using Java 7, then
type annotations should be placed in comments as explained in
Section&#XA0;<a href="#annotations-in-comments">25.2.1</a>.</p><p>See the directory <span style="font-family:monospace">examples/GradleExamples/</span> for examples of Gradle
build files that run a checker. You can use these examples to verify that
Gradle is correctly downloading the Checker Framework from
<a href="http://search.maven.org/#search%7Cga%7C1%7Corg.checkerframework">Maven
Central</a> and executing it.</p><ol class="enumerate" type=1><li class="li-enumerate">Indicate which version of Java you are using. We recommend the
following code, but you can also hard-code the <span style="font-family:monospace">ext.targetJavaVersion</span>
property.<div style="font-size:small;">
<pre class="verbatim">ext.targetJavaVersion = JavaVersion.current().isJava7() ? JavaVersion.VERSION_1_7 : JavaVersion.VERSION_1_8
</pre></div></li><li class="li-enumerate">Use the Maven Central repository:<pre class="verbatim">repositories {
  ... existing repositories...
  mavenCentral()
}
</pre></li><li class="li-enumerate">Add dependency configurations for the annotated JDK, <span style="font-family:monospace">checker.jar</span>, and the Type Annotations compiler:<div style="font-size:small;">
<pre class="verbatim">configurations {
    ... existing configurations ...
    if (targetJavaVersion.isJava7()) {
        checkerFrameworkJavac {
            description = 'a customization of the Open JDK javac compiler with additional support for type annotations'
        }
    }
    checkerFrameworkAnnotatedJDK {
       description = 'a copy of JDK classes with Checker Framework type qualifers inserted'
    }
    checkerFramework {
       description = 'The Checker Framework: custom pluggable types for Java'
    }
}
</pre></div></li><li class="li-enumerate">Declare the Checker Framework dependencies:<pre class="verbatim">dependencies {
    ... existing dependencies...
    ext.checkerFrameworkVersion = '2.0.0'
    ext.jdkVersion = JavaVersion.current().isJava7() ? 'jdk7' : 'jdk8'
    checkerFrameworkAnnotatedJDK "org.checkerframework:${jdkVersion}:${checkerFrameworkVersion}"

    if (targetJavaVersion.isJava7()) {
        checkerFrameworkJavac "org.checkerframework:compiler:${checkerFrameworkVersion}"
    }
    checkerFramework "org.checkerframework:checker:${checkerFrameworkVersion}"
    compile "org.checkerframework:checker-qual:${checkerFrameworkVersion}"
}
</pre></li><li class="li-enumerate">Direct all tasks of type <span style="font-family:monospace">JavaCompile</span> to use the desired checkers:<div style="font-size:small;">
<pre class="verbatim">allprojects {
    tasks.withType(JavaCompile).all { JavaCompile compile -&gt;
        compile.options.compilerArgs = [
                '-processor', 'org.checkerframework.checker.nullness.NullnessChecker',
                '-processorpath', "${configurations.checkerFramework.asPath}",
                // uncomment to turn Checker Framework errors into warnings
                // '-Awarns',
                "-Xbootclasspath/p:${configurations.checkerFrameworkAnnotatedJDK.asPath}"
        ]
        if (targetJavaVersion.isJava7()) {
            compile.options.compilerArgs += ['-source', '7', '-target', '7']
            options.fork = true
            options.forkOptions.jvmArgs += ["-Xbootclasspath/p:${configurations.checkerFrameworkJavac.asPath}"]
        }
    }
}
</pre></div></li></ol>
<!--TOC section id="android-gradle" Android plugin for Gradle-->
<h2 id="android-gradle" class="section">29.5&#XA0;&#XA0;Android plugin for Gradle</h2><!--SEC END --><p>If you use the
<a href="http://developer.android.com/tools/building/plugin-for-gradle.html">Android plugin for Gradle</a>,
then you can run a checker by following the instructions below.</p><p>These instructions can be used with Java 7 or Java 8. Because Android does not
support type annotations, they must be placed in comments as explained in
Section&#XA0;<a href="#annotations-in-comments">25.2.1</a>.</p><ol class="enumerate" type=1><li class="li-enumerate">Use the Maven Central repository:<pre class="verbatim">repositories {
  ... existing repositories...
  mavenCentral()
}
</pre></li><li class="li-enumerate">Add dependency configurations for the annotated JDK, <span style="font-family:monospace">checker.jar</span>, and the Type Annotations compiler:<div style="font-size:small;">
<pre class="verbatim">configurations {
    ... existing configurations ...
    checkerFrameworkJavac {
        description = 'a customization of the Open JDK javac compiler with additional support for type annotations'
    }
    checkerFrameworkAnnotatedJDK {
       description = 'a copy of JDK classes with Checker Framework type qualifers inserted'
    }
    checkerFramework {
       description = 'The Checker Framework: custom pluggable types for Java'
    }
}
</pre></div></li><li class="li-enumerate">Declare the Checker Framework dependencies:<div style="font-size:small;">
<pre class="verbatim">dependencies {
    ... existing dependencies...
    ext.checkerFrameworkVersion = '2.0.0'
    ext.jdkVersion = JavaVersion.current().isJava7() ? 'jdk7' : 'jdk8'
    checkerFrameworkAnnotatedJDK "org.checkerframework:${jdkVersion}:${checkerFrameworkVersion}"
    checkerFrameworkJavac "org.checkerframework:compiler:${checkerFrameworkVersion}"
    checkerFramework "org.checkerframework:checker:${checkerFrameworkVersion}"
    compile "org.checkerframework:checker-qual:${checkerFrameworkVersion}"
}
</pre></div></li><li class="li-enumerate">Direct all tasks of type <span style="font-family:monospace">JavaCompile</span> to use the desired checkers, when the <span style="font-family:monospace">typecheck</span> project property is set:<div style="font-size:small;">
<pre class="verbatim">def typecheck = project.properties['typecheck'] ?: false
allprojects {
if (typecheck) {
    gradle.projectsEvaluated {
        tasks.withType(JavaCompile).all { JavaCompile compile -&gt;
        compile.options.compilerArgs = [
                '-processor', 'org.checkerframework.checker.nullness.NullnessChecker',
                '-processorpath', "${configurations.checkerFramework.asPath}",
                // uncomment to turn Checker Framework errors into warnings
                //'-Awarns',
                "-Xbootclasspath/p:${configurations.checkerFrameworkAnnotatedJDK.asPath}"
        ]
            compile.options.compilerArgs += ['-source', '7', '-target', '7']
            options.bootClasspath = "${configurations.checkerFrameworkJavac.asPath}:" + System.getProperty("    sun.boot.class.path") + ":" + options.bootClasspath
            options.fork = true
            options.forkOptions.jvmArgs += ["-Xbootclasspath/p:${configurations.checkerFrameworkJavac.asPath}"]
        }
    }
}
}
</pre></div></li><li class="li-enumerate">Run the checkers:<pre class="verbatim">gradle compileReleaseJavaWithJavac -Ptypecheck=true
</pre></li></ol>
<!--TOC section id="intellij" IntelliJ IDEA-->
<h2 id="intellij" class="section">29.6&#XA0;&#XA0;IntelliJ IDEA</h2><!--SEC END --><p>To run a checker within IntelliJ:</p><ol class="enumerate" type=1><li class="li-enumerate">Set the language level for your project to 8. To do so, go to the
"Project Structure" menu via (File&gt;Project Structure) or
(Ctrl-Alt-Shift-S), and set the "Project language level" field in the
"Project" sub-menu to 8.</li><li class="li-enumerate">Add the Checker Framework libraries. In this same "Project Structure"
menu, navigate to the "Libraries" sub-menu. Click on the green "+" that
appears in this menu, select "Java" in the resulting pop-down menu,
select <span style="font-family:monospace">CHECKERFRAMEWORK/checker/dist/checker.jar</span> in the resulting menu,
and click "OK". Repeat this step for
<span style="font-family:monospace">CHECKERFRAMEWORK/checker/dist/javac.jar</span>.</li><li class="li-enumerate">Add the annotated JDK library.
Go to the "Settings" menu via (File&gt;Settings) or (Ctrl-Alt-S) and
navigate to the "Java Compiler" sub-menu via (Build, Execution,
Deployment&gt;Compiler&gt;Java Compiler). Add the following to the field
"Additional command line parameters":
<span style="font-family:monospace">-Xbootclasspath/p:CHECKERFRAMEWORK/checker/dist/jdk8.jar</span></li><li class="li-enumerate">Create an annotation profile and specify which checkers to run.
Directly under the "Java Compiler" sub-menu is the "Annotation
Processors" sub-menu. Navigate here and click on the green "+" to create
a new Annotation Processor profile. Select the modules you would like to
use checkers with from under the "Default" profile and move them to your
new profile via the button directly right of the "-" button.<p>Now select your new profile and check the "Enable annotation processing"
option. Select the "Processor path" radio button and enter
<span style="font-family:monospace">CHECKERFRAMEWORK/checker/dist/checker.jar</span> into the field to the right
of it. To add a checker to be run during compilation, click on the green
"+" in the "Processor FQ Name" section and write that checker&#X2019;s
fully-qualified name
(<span style="font-family:monospace">org.checkerframework.checker.</span><span style="font-family:monospace"><em>CHECKER</em></span><span style="font-family:monospace">.</span><span style="font-family:monospace"><em>CHECKER</em></span><span style="font-family:monospace">Checker</span>) in
the resulting text field, and press the "ENTER" key.
</p></li></ol><p>Now, when you compile your code, the checker will be run.</p>
<!--TOC section id="eclipse" Eclipse-->
<h2 id="eclipse" class="section">29.7&#XA0;&#XA0;Eclipse</h2><!--SEC END --><p>There are two ways to run a checker from within the Eclipse IDE: via Ant
or using an Eclipse plugin. These two methods are described below.</p><p>No matter what method you choose, we suggest that
all Checker Framework annotations be written in the comments
if you are using a version of Eclipse that
does not support Java 8. This will avoid many
text highlighting errors with versions of Eclipse that don&#X2019;t support Java 8
and type annotations.</p><p>Even in a version of Eclipse that supports Java 8&#X2019;s type annotations, you
still need to run the Checker Framework via Ant or via the plug-in, rather
than by supplying the <span style="font-family:monospace">-processor</span> command-line option to the ejc
compiler. The reason is that the Checker Framework is built upon javac,
and ejc represents the Java program differently. (If both javac and ejc
implemented JSR 198&#XA0;[<a href="#JSR198">Cro06</a>], then it would be possible to build
a type-checking plug-in that works with both compilers.)</p>
<!--TOC subsection id="eclipse-ant" Using an Ant task-->
<h3 id="eclipse-ant" class="subsection">29.7.1&#XA0;&#XA0;Using an Ant task</h3><!--SEC END --><p>Add an Ant target as described in Section&#XA0;<a href="#ant-task">29.2</a>. You can
run the Ant target by executing the following steps
(instructions copied from <a href="http://help.eclipse.org/luna/index.jsp?topic=%2Forg.eclipse.platform.doc.user%2FgettingStarted%2Fqs-84_run_ant.htm"><span style="font-family:monospace">http://help.eclipse.org/luna/index.jsp?topic=%2Forg.eclipse.platform.doc.user%2FgettingStarted%2Fqs-84_run_ant.htm</span></a>):</p><ol class="enumerate" type=1><li class="li-enumerate">Select <span style="font-family:monospace">build.xml</span> in one of the navigation views and choose
<span style="font-weight:bold">Run As </span>&gt;<span style="font-weight:bold"> Ant Build...</span> from its context menu.</li><li class="li-enumerate">A launch configuration dialog is opened on a launch configuration
for this Ant buildfile.</li><li class="li-enumerate">In the <span style="font-weight:bold">Targets</span> tab, select the new ant task (e.g., check-interning).</li><li class="li-enumerate">Click <span style="font-weight:bold">Run</span>.</li><li class="li-enumerate">The Ant buildfile is run, and the output is sent to the Console view.</li></ol><p><a id="eclipse-plug-in"></a> </p>
<!--TOC subsection id="eclipse-plugin" Eclipse plugin for the Checker Framework-->
<h3 id="eclipse-plugin" class="subsection">29.7.2&#XA0;&#XA0;Eclipse plugin for the Checker Framework</h3><!--SEC END --><p>The Checker framework Eclipse Plugin enables the use of the Checker
Framework within the Eclipse IDE.
Its website (<a href="http://types.cs.washington.edu/checker-framework/eclipse/"><span style="font-family:monospace">http://types.cs.washington.edu/checker-framework/eclipse/</span></a>).
The website contains instructions for installing and using the plugin.
</p>
<!--TOC subsection id="eclipse-troubleshooting" Troubleshooting Eclipse-->
<h3 id="eclipse-troubleshooting" class="subsection">29.7.3&#XA0;&#XA0;Troubleshooting Eclipse</h3><!--SEC END --><p>Eclipse issues an &#X201C;Unhandled Token in @SuppressWarnings&#X201D; warning if you
write a <span style="font-family:monospace">@SuppressWarnings</span> annotation containing a string that does not
know about. Unfortunately, Eclipse
<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=122475">hard-codes</a>
this list and there is not a way for the Eclipse plug-in to extend it.</p><p>To eliminate the warnings, you have two options:</p><ol class="enumerate" type=1><li class="li-enumerate">
Write <span style="font-family:monospace">@SuppressWarnings</span> annotations related to the Checker Framework in
comments (see Section&#XA0;<a href="#annotations-in-comments">25.2.1</a>).
</li><li class="li-enumerate">Disable all &#X201C;Unhandled Token in @SuppressWarnings&#X201D; warnings in Eclipse.
Look under the menu headings Java &#X2192; Compiler &#X2192; Errors/Warnings &#X2192; Annotations &#X2192; Unhandled Token in &#X2019;@SuppressWarnings&#X2019;, and set it to ignore.
</li></ol>
<!--TOC section id="tide" tIDE-->
<h2 id="tide" class="section">29.8&#XA0;&#XA0;tIDE</h2><!--SEC END --><p>
tIDE, an open-source Java IDE, supports the Checker Framework. See its
documentation at <a href="http://tide.olympe.in/"><span style="font-family:monospace">http://tide.olympe.in/</span></a>.
</p>
<!--TOC section id="sec371" Type inference tools-->
<h2 id="sec371" class="section">29.9&#XA0;&#XA0;Type inference tools</h2><!--SEC END -->
<!--TOC subsection id="type-inference-varieties" Varieties of type inference-->
<h3 id="type-inference-varieties" class="subsection">29.9.1&#XA0;&#XA0;Varieties of type inference</h3><!--SEC END --><p>There are two different tasks that are commonly called &#X201C;type inference&#X201D;.</p><ol class="enumerate" type=1><li class="li-enumerate">
Type inference during type-checking (Section&#XA0;<a href="#type-refinement">23.4</a>):
During type-checking, if certain variables have no type qualifier, the
type-checker determines whether there is some type qualifier that would
permit the program to type-check. If so, the type-checker uses that type
qualifier, but never tells the programmer what it was. Each time the
type-checker runs, it re-infers the type qualifier for that variable. If
no type qualifier exists that permits the program to type-check, the
type-checker issues a type warning.<p>This variety of type inference is built into the Checker Framework. Every
checker can take advantage of it at no extra effort. However, it only
works within a method, not across method boundaries.</p><p>Advantages of this variety of type inference include:
</p><ul class="itemize"><li class="li-itemize">
If the type qualifier is obvious to the programmer, then omitting it
can reduce annotation clutter in the program.
</li><li class="li-itemize">The type inference can take advantage of only the code currently being
compiled, rather than having to be correct for all possible calls.
Additionally, if the code changes, then there is no old annotation to
update.
</li></ul></li><li class="li-enumerate">Type inference to annotate a program (Section&#XA0;<a href="#type-inference-to-annotate">26.2</a>):
As a separate step before type-checking, a type inference tool takes the
program as input, and outputs a set of type qualifiers that would
type-check. These qualifiers are inserted into the source code or the
class file. They can be viewed and adjusted by the programmer, and can
be used by tools such as the type-checker.<p>This variety of type inference must be provided by a separate tool. It
is not built into the Checker Framework.</p><p>Advantages of this variety of type inference include:
</p><ul class="itemize"><li class="li-itemize">
The program contains documentation in the form of type qualifiers,
which can aid programmer understanding.
</li><li class="li-itemize">Error messages may be more comprehensible. With type inference
during type-checking, error messages can be obscure, because the
compiler has already inferred (possibly incorrect) types for a number
of variables.
</li><li class="li-itemize">A minor advantage is speed: type-checking can be modular, which can be
faster than re-doing type inference every time the
program is type-checked.
</li></ul></li></ol><p>Advantages of both varieties of inference include:
</p><ul class="itemize"><li class="li-itemize">
Less work for the programmer.
</li><li class="li-itemize">The tool chooses the most general type, whereas a programmer might
accidentally write a more specific, less generally-useful annotation.
</li></ul><p>Each variety of type inference has its place. When using the Checker
Framework, type inference during type-checking is performed only
<em>within</em> a method (Section&#XA0;<a href="#type-refinement">23.4</a>). Every method
signature (arguments and return values) and field must have already been explicitly annotated,
either by the programmer or by a separate type-checking tool
(Section&#XA0;<a href="#type-inference-to-annotate">26.2</a>).
This approach enables modular checking (one class or method at a time) and
gives documentation benefits.
The programmer still has to
put in some effort, but much less than without inference: typically, a
programmer does not have to write any qualifiers
inside the body of a method.</p>
<!--TOC subsection id="sec373" Type inference to annotate a program-->
<h3 id="sec373" class="subsection">29.9.2&#XA0;&#XA0;Type inference to annotate a program</h3><!--SEC END --><p>This section lists tools that take a program and output a set of
annotations for it.</p><p>Section&#XA0;<a href="#nullness-inference">3.3.7</a> lists several tools that infer
annotations for the Nullness Checker.</p><p><a href="https://github.com/reprogrammer/cascade/">Cascade</a>&#XA0;[<a href="#VakilianPEJ2014">VPEJ14</a>]
is an Eclipse plugin that implements interactive type qualifier inference.
Cascade is interactive rather than fully-automated: it makes it easier for
a developer to insert annotations.
Cascade starts with an unannotated program and runs a type-checker. For each
warning it suggests multiple fixes, the developer chooses a fix, and
Cascade applies it. Cascade works with any checker built on the Checker
Framework.
You can find installation instructions and a video tutorial at <a href="https://github.com/reprogrammer/cascade"><span style="font-family:monospace">https://github.com/reprogrammer/cascade</span></a>.</p><hr>
<!--TOC chapter id="faq" Frequently Asked Questions (FAQs)-->
<h1 id="faq" class="chapter">Chapter&#XA0;30&#XA0;&#XA0;Frequently Asked Questions (FAQs)</h1><!--SEC END --><p>These are some common questions about the Checker Framework and about
pluggable type-checking in general. Feel free to suggest improvements to
the answers, or other questions to include here.</p><p><span style="font-weight:bold">Contents:</span></p><p><a href="#faq-motivation-section"><span style="font-weight:bold">30.1</span></a><span style="font-weight:bold">: Motivation for pluggable type-checking</span>
<br>
<a href="#never-make-type-errors">30.1.1</a>: I don&#X2019;t make type errors, so would pluggable type-checking help me?
<br>
<a href="#faq-qualifiers-vs-subclasses">30.1.2</a>: When should I use type qualifiers, and when should I use subclasses?</p><p><a href="#faq-getting-started-section"><span style="font-weight:bold">30.2</span></a><span style="font-weight:bold">: Getting started</span>
<br>
<a href="#faq-annotate-existing-program">30.2.1</a>: How do I get started annotating an existing program?
<br>
<a href="#faq-first-checker">30.2.2</a>: Which checker should I start with?
<br>
<a href="#faq-typequals-vs-subtypes">30.2.3</a>: Should I use pluggable types or Java subtypes?
<br>
<a href="#faq-checker-framework-dev">30.2.4</a>: How can I join the checker-framework-dev mailing list?</p><p><a href="#faq-usability-section"><span style="font-weight:bold">30.3</span></a><span style="font-weight:bold">: Usability of pluggable type-checking</span>
<br>
<a href="#faq-ease-of-use">30.3.1</a>: Are type annotations easy to read and write?
<br>
<a href="#faq-code-clutter">30.3.2</a>: Will my code become cluttered with type annotations?
<br>
<a href="#faq-slowdown">30.3.3</a>: Will using the Checker Framework slow down my program? Will it slow down the compiler?
<br>
<a href="#faq-shorten-command-line">30.3.4</a>: How do I shorten the command line when invoking a checker?</p><p><a href="#faq-warnings-section"><span style="font-weight:bold">30.4</span></a><span style="font-weight:bold">: How to handle warnings</span>
<br>
<a href="#faq-handling-warnings">30.4.1</a>: What should I do if a checker issues a warning about my code?
<br>
<a href="#faq-interpreting-warnings">30.4.2</a>: What does a certain Checker Framework warning message mean?
<br>
<a href="#faq-no-absolute-guarantee">30.4.3</a>: Can a pluggable type-checker guarantee that my code is correct?
<br>
<a href="#faq-concurrency">30.4.4</a>: What guarantee does the Checker Framework give for concurrent code?
<br>
<a href="#faq-awarns">30.4.5</a>: How do I make compilation succeed even if a checker issues errors?
<br>
<a href="#faq-100-warnings">30.4.6</a>: Why does the checker always say there are 100 errors or warnings?
<br>
<a href="#faq-type-i-did-not-write">30.4.7</a>: Why does the Checker Framework report an error regarding a type I have not written in my program?
<br>
<a href="#faq-run-time-checking">30.4.8</a>: How can I do run-time monitoring of properties that were not statically checked?</p><p><a href="#faq-syntax-section"><span style="font-weight:bold">30.5</span></a><span style="font-weight:bold">: Syntax of type annotations</span>
<br>
<a href="#faq-receiver">30.5.1</a>: What is a &#X201C;receiver&#X201D;?
<br>
<a href="#faq-annotation-after-type">30.5.2</a>: What is the meaning of an annotation after a type, such as <span style="font-family:monospace">@NonNull Object @Nullable</span>?
<br>
<a href="#faq-array-syntax-meaning">30.5.3</a>: What is the meaning of array annotations such as <span style="font-family:monospace">@NonNull Object @Nullable []</span>?
<br>
<a href="#faq-varargs-syntax-meaning">30.5.4</a>: What is the meaning of varargs annotations such as <span style="font-family:monospace">@English String @NonEmpty&#XA0;...</span>?
<br>
<a href="#faq-type-qualifier-on-class-declaration">30.5.5</a>: What is the meaning of a type qualifier at a class declaration?
<br>
<a href="#faq-no-annotation-on-types-and-declarations">30.5.6</a>: Why shouldn&#X2019;t a qualifier apply to both types and declarations?
<br>
<a href="#faq-annotate-fully-qualified-name">30.5.7</a>: How do I annotate a
fully-qualified type name?</p><p><a href="#faq-semantics-section"><span style="font-weight:bold">30.6</span></a><span style="font-weight:bold">: Semantics of type annotations</span>
<br>
<a href="#faq-list-map-nonnull-typeargs">30.6.1</a>: Why are the type parameters to <span style="font-family:monospace">List</span> and <span style="font-family:monospace">Map</span> annotated as <span style="font-family:monospace">@NonNull</span>?
<br>
<a href="#faq-typestate">30.6.2</a>: How can I handle typestate, or phases of my program with different data properties?
<br>
<a href="#faq-implicit-bounds">30.6.3</a>: Why are explicit and implicit bounds defaulted differently?</p><p><a href="#faq-create-a-checker-section"><span style="font-weight:bold">30.7</span></a><span style="font-weight:bold">: Creating a new checker</span>
<br>
<a href="#faq-create-a-checker">30.7.1</a>: How do I create a new checker?
<br>
<a href="#faq-declarative-syntax-for-type-rules">30.7.2</a>: Why is there no declarative syntax for writing type rules?</p><p><a href="#faq-other-tools-section"><span style="font-weight:bold">30.8</span></a><span style="font-weight:bold">: Relationship to other tools</span>
<br>
<a href="#faq-type-checking-vs-bug-detectors">30.8.1</a>: Why not just use a bug detector (like FindBugs)?
<br>
<a href="#faq-eclipse">30.8.2</a>: How does the Checker Framework compare with Eclipse&#X2019;s Null Analysis?
<br>
<a href="#faq-jml">30.8.3</a>: How does pluggable type-checking compare with JML?
<br>
<a href="#faq-checker-framework-part-of-java">30.8.4</a>: Is the Checker Framework an official part of Java?
<br>
<a href="#faq-jsr-305">30.8.5</a>: What is the relationship between the Checker Framework and JSR 305?
<br>
<a href="#faq-jsr-308">30.8.6</a>: What is the relationship between the Checker Framework and JSR 308?</p>
<!--TOC section id="faq-motivation-section" Motivation for pluggable type-checking-->
<h2 id="faq-motivation-section" class="section">30.1&#XA0;&#XA0;Motivation for pluggable type-checking</h2><!--SEC END -->
<!--TOC subsection id="never-make-type-errors" I don&#X2019;t make type errors, so would pluggable type-checking help me?-->
<h3 id="never-make-type-errors" class="subsection">30.1.1&#XA0;&#XA0;I don&#X2019;t make type errors, so would pluggable type-checking help me?</h3><!--SEC END --><p>Occasionally, a developer says that he makes no errors that type-checking
could catch, or that any such errors are unimportant because they have low
impact and are easy to fix. When I investigate the claim, I invariably
find that the developer is mistaken.</p><p>Very frequently, the developer has underestimated what type-checking can
discover. Not every type error leads to an exception being thrown; and
even if an exception is thrown, it may not seem related to classical types.
Remember that a type system can discover
null pointer dereferences,
incorrect side effects,
security errors such as information leakage or SQL injection,
partially-initialized data,
wrong units of measurement,
and many other errors.
Every programmer makes errors sometimes and works with other people
who do.
Even where type-checking does not discover a
problem directly, it can indicate code with bad smells, thus revealing
problems, improving documentation, and making future maintenance easier.</p><p>There are other ways to discover errors, including extensive testing and
debugging. You should continue to use these.
But type-checking is a good complement to these. Type-checking is more
effective for some problems, and less effective for other problems. It can
reduce (but not eliminate) the time and effort that you spend on other
approaches. There are many important errors that type-checking and other
automated approaches cannot find; pluggable type-checking gives you more
time to focus on those.</p>
<!--TOC subsection id="faq-qualifiers-vs-subclasses" When should I use type qualifiers, and when should I use subclasses?-->
<h3 id="faq-qualifiers-vs-subclasses" class="subsection">30.1.2&#XA0;&#XA0;When should I use type qualifiers, and when should I use subclasses?</h3><!--SEC END --><p>In brief, use subtypes when you can, and use type qualifiers when you cannot
use subtypes.
For more details, see Section&#XA0;<a href="#when-to-use-type-qualifiers">30.2.3</a>.</p>
<!--TOC section id="faq-getting-started-section" Getting started-->
<h2 id="faq-getting-started-section" class="section">30.2&#XA0;&#XA0;Getting started</h2><!--SEC END -->
<!--TOC subsection id="faq-annotate-existing-program" How do I get started annotating an existing program?-->
<h3 id="faq-annotate-existing-program" class="subsection">30.2.1&#XA0;&#XA0;How do I get started annotating an existing program?</h3><!--SEC END --><p>See Section&#XA0;<a href="#get-started-with-legacy-code">2.4.1</a>.</p>
<!--TOC subsection id="faq-first-checker" Which checker should I start with?-->
<h3 id="faq-first-checker" class="subsection">30.2.2&#XA0;&#XA0;Which checker should I start with?</h3><!--SEC END --><p>You should start with a property that matters to you. Think about what
aspects of your code cause the most errors, or cost the most time during
maintenance, or are the most common to be incorrectly-documented. Focusing
on what you care about will give you the best benefits.</p><p>When you first start out with the Checker Framework, it&#X2019;s usually best to
get experience with an existing type-checker before you write your own new
checker.</p><p>Many users are tempted to start with the
<a href="#nullness-checker">Nullness Checker</a> (see
Chapter&#XA0;<a href="#nullness-checker">3</a>), since null pointer errors are common
and familiar. The Nullness Checker works very well, but be warned of three
facts that make the absence of null pointer exceptions challenging to
verify.</p><ol class="enumerate" type=1><li class="li-enumerate">
Dereferences happen throughout your codebase, so there are a lot of
potential problems. By contrast, fewer lines of code are related to
locking, regular expressions, etc., so those properties are easier to
check.
</li><li class="li-enumerate">Programmers use <span style="font-family:monospace">null</span> for many different purposes. More seriously,
programmers write run-time tests against <span style="font-family:monospace">null</span>, and those are difficult
for any static analysis to capture.
</li><li class="li-enumerate">The Nullness Checker interacts with initialization and map keys.
</li></ol><p>If null pointer exceptions are most important to you, then by all means use
the Nullness Checker. But if you just want to try <em>some</em>
type-checker, there are others that are easier to use.</p><p>we do not recommend indiscriminately running all the checkers on your code.
The reason is that each one has a cost &#X2014; not just at compile time, but
also in terms of code clutter and human time to maintain the annotations.
If the property is important to you, is difficult for people to reason
about, or has caused problems in the past, then you should run that
checker. For other properties, the benefits may not repay the effort to
use it. You will be the best judge of this for your own code, of course.</p><p>The <a href="#linear-checker">Linear Checker</a> (see
Chapter&#XA0;<a href="#linear-checker">18</a>) has not been extensively tested.
Some of the third-party checkers (see
Chapter&#XA0;<a href="#third-party-checkers">21</a>)
have known bugs that limit their
usability. (Report the ones that affect you, so the developers
will prioritize fixing them.)</p>
<!--TOC subsection id="faq-typequals-vs-subtypes" Should I use pluggable types or Java subtypes?-->
<h3 id="faq-typequals-vs-subtypes" class="subsection">30.2.3&#XA0;&#XA0;Should I use pluggable types or Java subtypes?</h3><!--SEC END --><p><a id="when-to-use-type-qualifiers"></a></p><p>For some programming tasks, you can use either a Java subclass or a type
qualifier. As an example that your code currently uses <span style="font-family:monospace">String</span> to
represent an address. You could use Java subclasses by creating a new
<span style="font-family:monospace">Address</span> class and refactor your code to use it, or you could use
type qualifiers by creating an <span style="font-family:monospace">@Address</span> annotation and applying it
to some uses of <span style="font-family:monospace">String</span> in your code. As another example, suppose
that your code currently uses <span style="font-family:monospace">MyClass</span> in two different ways that
should not interact with one another. You could use Java subclasses by
changing MyClass into an interface or abstract class, defining two
subclasses, and ensuring that neither subclass ever refers to the other
subclass nor to the parent class.</p><p>If Java subclasses solve your problem, then that is probably better.
We do not encourage you to use type qualifiers as a poor substitute for
classes. An advantage of using classes is that the Java type-checker
always runs; by contrast, it is possible to forget to run the pluggable
type-checker. However, here are some reasons type qualifiers may be a
better choice.</p><dl class="description"><dt class="dt-description"><span style="font-weight:bold">Backward compatibility</span></dt><dd class="dd-description">
Using a new class may make your code incompatible with existing libraries or
clients. Brian Goetz expands on this issue in an article on the
pseudo-typedef antipattern&#XA0;[<a href="#Goetz2006%3Atypedef">Goe06</a>]. Even if compatibility
is not a concern, a code change may introduce bugs, whereas adding
annotations does not change the run-time behavior. It is possible to add
annotations to existing code, including code you do not maintain or cannot
change. For code that strictly cannot be changed, you can add
annotations in comments (see Section&#XA0;<a href="#annotations-in-comments">25.2.1</a>), or you
can write library annotations (see Chapter&#XA0;<a href="#annotating-libraries">27</a>).</dd><dt class="dt-description"><span style="font-weight:bold">Broader applicability</span></dt><dd class="dd-description">
Type annotations can be applied to primitives and to final classes such as
<span style="font-family:monospace">String</span>, which cannot be subclassed.</dd><dt class="dt-description"><span style="font-weight:bold">Richer semantics and new supertypes</span></dt><dd class="dd-description">
Type qualifiers permit you to remove operations, with a compile-time
guarantee. More
generally, type qualifiers permit creating a new supertype, not just a
subtype, of an existing Java type.</dd><dt class="dt-description"><span style="font-weight:bold">More precise type-checking</span></dt><dd class="dd-description">
The Checker Framework is able to verify the correctness of code that the
Java type-checker would reject. Here are a few examples.
<ul class="itemize"><li class="li-itemize">
It uses a dataflow analysis to determine a more precise type for
variables after conditional tests or assignments.
</li><li class="li-itemize">It treats certain Java constructs more precisely, such as
reflection (see Chapter&#XA0;<a href="#reflection-resolution">19</a>).
</li><li class="li-itemize">It includes special-case logic for type-checking specific methods, such
as the Nullness Checker&#X2019;s treatment of <span style="font-family:monospace">Map.get</span>.
</li></ul></dd><dt class="dt-description"><span style="font-weight:bold">Efficiency</span></dt><dd class="dd-description">
Type qualifiers have no run-time representation. Therefore, there is no
space overhead for separate classes or for wrapper classes for
primitives. There is no run-time overhead for due to extra dereferences
or dynamic dispatch for methods that could otherwise be statically
dispatched.</dd><dt class="dt-description"><span style="font-weight:bold">Less code clutter</span></dt><dd class="dd-description">
The programmer does not have to convert primitive types to wrappers,
which would make the code both uglier and slower. Thanks to defaults and
type inference (Section&#XA0;<a href="#defaults">23.3.1</a>),
you may be able to write and think in terms of the
original Java type, rather than having to explicitly write one of the
subtypes in all locations.</dd></dl>
<!--TOC subsection id="faq-checker-framework-dev" How can I join the checker-framework-dev mailing list?-->
<h3 id="faq-checker-framework-dev" class="subsection">30.2.4&#XA0;&#XA0;How can I join the checker-framework-dev mailing list?</h3><!--SEC END --><p>The <span style="font-family:monospace">checker-framework-dev@googlegroups.com</span> mailing list is for
Checker Framework developers. Anyone is welcome to
<a href="https://groups.google.com/forum/#!forum/checker-framework-dev">join
<span style="font-family:monospace">checker-framework-dev</span></a>, after they have had several pull requests
accepted.</p><p>Anyone is welcome to send mail to the
<span style="font-family:monospace">checker-framework-dev@googlegroups.com</span> mailing list &#X2014; for
implementation details it is generally a better place for discussions than
the general <span style="font-family:monospace">checker-framework-discuss@googlegroups.com</span> mailing list,
which is for user-focused discussions.</p><p>Anyone is welcome to
<a href="https://groups.google.com/forum/#!forum/checker-framework-discuss">join
<span style="font-family:monospace">checker-framework-discuss@googlegroups.com</span></a> and send mail to it.</p>
<!--TOC section id="faq-usability-section" Usability of pluggable type-checking-->
<h2 id="faq-usability-section" class="section">30.3&#XA0;&#XA0;Usability of pluggable type-checking</h2><!--SEC END -->
<!--TOC subsection id="faq-ease-of-use" Are type annotations easy to read and write?-->
<h3 id="faq-ease-of-use" class="subsection">30.3.1&#XA0;&#XA0;Are type annotations easy to read and write?</h3><!--SEC END --><p>The papers
<a href="http://homes.cs.washington.edu/~mernst/pubs/pluggable-checkers-issta2008-abstract.html">&#X201C;Practical
pluggable types for Java&#X201D;</a>&#XA0;[<a href="#PapiACPE2008">PAC+08</a>]
and
<a href="http://homes.cs.washington.edu/~mernst/pubs/pluggable-checkers-icse2011-abstract.html">&#X201C;Building
and using pluggable type-checkers&#X201D;</a>&#XA0;[<a href="#DietlDEMS2011">DDE+11</a>]
discuss case studies in
which programmers
found type annotations to be natural to read and write. The code
continued to feel like Java, and the type-checking errors were easy to
comprehend and often led to real bugs.</p><p>You don&#X2019;t have to take our word for it, though. You can try the
Checker Framework for yourself.</p><p>The difficulty of adding and verifying annotations depends on your program.
If your program is well-designed and -documented, then skimming the
existing documentation and writing type annotations is extremely easy.
Otherwise, you may find yourself spending a lot of time trying to
understand, reverse-engineer, or fix bugs in your program, and then just a
moment writing a type annotation that describes what you discovered. This
process inevitably improves your code. You must decide whether it is a
good use of your time. For code that is not causing trouble now and is
unlikely to do so in the future (the code is bug-free, and you do not
anticipate changing it or using it in new contexts), then the
effort of writing type annotations for it may not be justified.</p>
<!--TOC subsection id="faq-code-clutter" Will my code become cluttered with type annotations?-->
<h3 id="faq-code-clutter" class="subsection">30.3.2&#XA0;&#XA0;Will my code become cluttered with type annotations?</h3><!--SEC END --><p>In summary: annotations do not clutter code; they are used much
less frequently than generic types, which Java programmers find acceptable;
and they reduce the overall volume of documentation that a codebase needs.</p><p>As with any language feature, it is possible to write ugly code that
over-uses annotations. However, in normal use, very few annotations need
to be written. Figure 1 of the paper
<a href="http://homes.cs.washington.edu/~mernst/pubs/pluggable-checkers-issta2008-abstract.html">Practical
pluggable types for Java</a>&#XA0;[<a href="#PapiACPE2008">PAC+08</a>] reports data for over
350,000 lines of type-annotated code:</p><ul class="itemize"><li class="li-itemize">
1 annotation per 62 lines for nullness annotations (<span style="font-family:monospace">@NonNull</span>, <span style="font-family:monospace">@Nullable</span>, etc.)
</li><li class="li-itemize">1 annotation per 1736 lines for interning annotations (<span style="font-family:monospace">@Interned</span>)
</li></ul><p>These numbers are for annotating existing code. New code that
is written with the type annotation system in mind is cleaner and more
correct, so it requires even fewer annotations.</p><p>Each annotation that a programmer writes replaces a sentence or phrase of
English descriptive text that would otherwise have been written in the
Javadoc. So, use of annotations actually reduces the overall size of the
documentation, at the same time as making it machine-processable
and less ambiguous.</p>
<!--TOC subsection id="faq-slowdown" Will using the Checker Framework slow down my program? Will it slow down the compiler?-->
<h3 id="faq-slowdown" class="subsection">30.3.3&#XA0;&#XA0;Will using the Checker Framework slow down my program? Will it slow down the compiler?</h3><!--SEC END --><p>Using the Checker Framework has no impact on the execution of your program:
the compiler emits the identical bytecodes as the Java 8
compiler and so there is no run-time effect. Because there is no run-time
representation of type qualifiers, there is no way to use reflection to
query the qualifier on a given object, though you can use reflection to
examine a class/method/field declaration.</p><p>Using the Checker Framework does increase compilation time. In theory it
should only add a few percent overhead, but our current implementation
can double the compilation time &#X2014; or more, if you run many pluggable
type-checkers at once. This is especially true if you run pluggable
type-checking on every file (as we recommend) instead of just on the ones
that have recently changed.
Nonetheless, compilation with pluggable type-checking still feels like
compilation, and you can do it as part of your normal development process.</p>
<!--TOC subsection id="faq-shorten-command-line" How do I shorten the command line when invoking a checker?-->
<h3 id="faq-shorten-command-line" class="subsection">30.3.4&#XA0;&#XA0;How do I shorten the command line when invoking a checker?</h3><!--SEC END --><p>
The compile options to javac can be a pain to type; for example,
<span style="font-family:monospace">javac -processor org.checkerframework.checker.nullness.NullnessChecker ...</span>.
See Section&#XA0;<a href="#checker-auto-discovery">2.2.3</a> for a way to avoid the need for
the <span style="font-family:monospace">-processor</span> command-line option.
</p>
<!--TOC section id="faq-warnings-section" How to handle warnings and errors-->
<h2 id="faq-warnings-section" class="section">30.4&#XA0;&#XA0;How to handle warnings and errors</h2><!--SEC END -->
<!--TOC subsection id="faq-handling-warnings" What should I do if a checker issues a warning about my code?-->
<h3 id="faq-handling-warnings" class="subsection">30.4.1&#XA0;&#XA0;What should I do if a checker issues a warning about my code?</h3><!--SEC END --><p>For a discussion of this issue, see Section&#XA0;<a href="#handling-warnings">2.4.6</a>.</p>
<!--TOC subsection id="faq-interpreting-warnings" What does a certain Checker Framework warning message mean?-->
<h3 id="faq-interpreting-warnings" class="subsection">30.4.2&#XA0;&#XA0;What does a certain Checker Framework warning message mean?</h3><!--SEC END --><p>Search through this manual for the text of the warning message.
Oftentimes the manual explains it. If not, ask on the <a href="https://groups.google.com/forum/#!forum/checker-framework-discuss">mailing list</a>.</p>
<!--TOC subsection id="faq-no-absolute-guarantee" Can a pluggable type-checker guarantee that my code is correct?-->
<h3 id="faq-no-absolute-guarantee" class="subsection">30.4.3&#XA0;&#XA0;Can a pluggable type-checker guarantee that my code is correct?</h3><!--SEC END --><p>Each checker looks for certain errors. You can use multiple checkers to
detect more errors in your code, but you will never have a guarantee that
your code is completely bug-free.</p><p>If the type-checker issues no warning, then you have a guarantee that your
code is free of some particular error. There are some limitations to the
guarantee.</p><p>Most importantly, if you run a pluggable checker on only part of a program, then
you only get a guarantee that those parts of the program are error-free.
For example, suppose you have type-checked a framework that clients
are intended to extend. You should recommend that clients
run the pluggable checker. There is no way to force users to do so, so you
may want to retain dynamic checks or use other mechanisms to detect errors.</p><p>Section&#XA0;<a href="#checker-guarantees">2.3</a> states other limitations to a checker&#X2019;s
guarantee, such as regarding concurrency. Java&#X2019;s type system is also
unsound in certain situations, such as for arrays and casts (however, the
Checker Framework is sound for arrays and casts). Java uses dynamic checks
is some places it is unsound, so that errors are thrown at run time. The
pluggable type-checkers do not currently have built-in dynamic checkers to
check for the places they are unsound.
Writing dynamic checkers would be an interesting and valuable project.</p><p>Other types of dynamism in a Java application do not jeopardize the
guarantee, because the type-checker is conservative. For example, at a
method call, dynamic dispatch chooses some implementation of the method,
but it is impossible to know at compile time which one it will be. The
type-checker gives a guarantee no matter what implementation of the method
is invoked.</p><p>Even if a pluggable checker cannot give an ironclad
guarantee of correctness, it is still useful. It can find errors,
exclude certain types of possible problems (e.g., restricting the
possible class of problems), improve documentation, and increase confidence
in your software.</p>
<!--TOC subsection id="faq-concurrency" What guarantee does the Checker Framework give for concurrent code?-->
<h3 id="faq-concurrency" class="subsection">30.4.4&#XA0;&#XA0;What guarantee does the Checker Framework give for concurrent code?</h3><!--SEC END --><p>The Lock Checker (see Chapter&#XA0;<a href="#lock-checker">6</a>) offers a way to detect
and prevent certain concurrency errors.</p><p>By default, the Checker Framework assumes that the code that it is checking
is sequential: that is, there are no concurrent accesses from another
thread. This means that the Checker Framework is unsound for concurrent
code, in the sense that it may fail to issue a warning about errors that
occur only when the code is running in a concurrent setting.
For example, the Nullness Checker issues no warning for this
code:</p><pre class="verbatim">  if (myobject.myfield != null) {
    myobject.myfield.toString();
  }
</pre><p>This code is safe when run on its own.
However, in the presence of multithreading, the call to <span style="font-family:monospace">toString</span> may
fail because another thread may set <span style="font-family:monospace">myobject.myfield</span> to <span style="font-family:monospace">null</span> after
the nullness check in the <span style="font-family:monospace">if</span> condition, but before the <span style="font-family:monospace">if</span> body is
executed.</p><p>If you supply the <span style="font-family:monospace">-AconcurrentSemantics</span> command-line option, then the
Checker Framework assumes that any field can be changed at any time. This
limits the amount of flow-sensitive type qualifier refinement
(Section&#XA0;<a href="#type-refinement">23.4</a>) that the Checker Framework can do.</p>
<!--TOC subsection id="faq-awarns" How do I make compilation succeed even if a checker issues errors?-->
<h3 id="faq-awarns" class="subsection">30.4.5&#XA0;&#XA0;How do I make compilation succeed even if a checker issues errors?</h3><!--SEC END --><p>Section&#XA0;<a href="#running">2.2</a> describes the <span style="font-family:monospace">-Awarns</span> command-line
option that turns checker errors into warnings, so type-checking errors
will not cause <span style="font-family:monospace">javac</span> to exit with a failure status.</p>
<!--TOC subsection id="faq-100-warnings" Why does the checker always say there are 100 errors or warnings?-->
<h3 id="faq-100-warnings" class="subsection">30.4.6&#XA0;&#XA0;Why does the checker always say there are 100 errors or warnings?</h3><!--SEC END --><p>By default, javac only reports the first 100 errors or warnings.
Furthermore, once javac encounters an error, it doesn&#X2019;t try compiling any
more files (but does complete compilation of all the ones that it has
started so far).</p><p>To see more than 100 errors or warnings, use the javac options <span style="font-family:monospace">-Xmaxerrs</span>
and <span style="font-family:monospace">-Xmaxwarns</span>. To convert Checker Framework errors into warnings so
that javac will process all your source files, use the option <span style="font-family:monospace">-Awarns</span>.
See Section&#XA0;<a href="#running">2.2</a> for more details.</p>
<!--TOC subsection id="faq-type-i-did-not-write" Why does the Checker Framework report an error regarding a type I have not written in my program?-->
<h3 id="faq-type-i-did-not-write" class="subsection">30.4.7&#XA0;&#XA0;Why does the Checker Framework report an error regarding a type I have not written in my program?</h3><!--SEC END --><p>Sometimes, a Checker Framework warning message will mention a type you have
not written in your program. This is typically because a default has been
applied where you did not write a type; see Section&#XA0;<a href="#defaults">23.3.1</a>. In
other cases, this is because flow-sensitive type refinement has given an
expression a more specific type than you wrote or than was defaulted; see
Section&#XA0;<a href="#type-refinement">23.4</a>.</p>
<!--TOC subsection id="faq-run-time-checking" How can I do run-time monitoring of properties that were not statically checked?-->
<h3 id="faq-run-time-checking" class="subsection">30.4.8&#XA0;&#XA0;How can I do run-time monitoring of properties that were not statically checked?</h3><!--SEC END --><p>Some properties are not checked statically (see
Chapter&#XA0;<a href="#suppressing-warnings">24</a> for reasons that code might not be
statically checked). In such cases, it would be desirable to check the
property dynamically, at run time.
Currently, the Checker Framework has no support for adding code to perform
run-time checking.</p><p>Adding such support would be an interesting and valuable project.
An example would be an option that causes the Checker Framework to
automatically insert a run-time check anywhere that static checking is
suppressed.
If you
are able to add run-time verification functionality, we would gladly
welcome it as a contribution to the Checker Framework.</p><p>Some checkers have library methods that you can explicitly insert in your
source code.
Examples include the Nullness Checker&#X2019;s
<a href="api/org/checkerframework/checker/nullness/NullnessUtils.html#castNonNull-T-"><span style="font-family:monospace">NullnessUtils.castNonNull</span></a> method (see
Section&#XA0;<a href="#suppressing-warnings-with-assertions">3.4.1</a>) and the Regex Checker&#X2019;s
<span style="font-family:monospace">RegexUtil</span> class (see Section&#XA0;<a href="#regexutil-methods">9.2.4</a>).
But, it would be better to have more general support that does not require
the user to explicitly insert method calls.</p>
<!--TOC section id="faq-syntax-section" Syntax of type annotations-->
<h2 id="faq-syntax-section" class="section">30.5&#XA0;&#XA0;Syntax of type annotations</h2><!--SEC END --><p>There is also a separate FAQ for the type annotations syntax
(<a href="http://types.cs.washington.edu/jsr308/current/jsr308-faq.html"><span style="font-family:monospace">http://types.cs.washington.edu/jsr308/current/jsr308-faq.html</span></a>).</p>
<!--TOC subsection id="faq-receiver" What is a &#X201C;receiver&#X201D;?-->
<h3 id="faq-receiver" class="subsection">30.5.1&#XA0;&#XA0;What is a &#X201C;receiver&#X201D;?</h3><!--SEC END --><p>The <em>receiver</em> of a method is the <span style="font-family:monospace">this</span> formal parameter, sometimes
also called the &#X201C;current object&#X201D;. Within the method declaration, <span style="font-family:monospace">this</span>
is used to refer to the receiver formal parameter. At a method call, the
receiver actual argument is written before the method name.</p><p>The method <span style="font-family:monospace">compareTo</span> takes <em>two</em> formal parameters. At a call site
like <span style="font-family:monospace">x.compareTo(y)</span>, the two arguments are <span style="font-family:monospace">x</span> and <span style="font-family:monospace">y</span>. It is
desirable to be able to annotate the types of both of the formal
parameters, and doing so is supported by both Java&#X2019;s type annotations
syntax and by the Checker Framework.</p><p>A type annotation on the receiver is treated exactly like a type annotation
on any other formal parameter. At each call site, the type of the argument
must be a consistent with (a subtype of or equal to) the declaration of the
corresponding formal parameter. If not, the type-checker issues a warning.</p><p>Here is an example. Suppose that <span style="font-family:monospace">@A Object</span> is a supertype of <span style="font-family:monospace">@B
Object</span> in the following declaration:</p><pre class="verbatim">  class MyClass {
    void requiresA(@A MyClass this) { ... }
    void requiresB(@B MyClass this) { ... }
  }
</pre><p>Then the behavior of four different invocations is as follows:</p><pre class="verbatim">  @A MyClass myA = ...;
  @B MyClass myB = ...;

  myA.requiresA()    // OK
  myA.requiresB()    // compile-time error
  myB.requiresA()    // OK
  myB.requiresB()    // OK
</pre><p>The invocation <span style="font-family:monospace">myA.requiresB()</span> does not type-check because the actual
argument&#X2019;s type is not a subtype of the formal parameter&#X2019;s type.</p><p>A top-level constructor does not have a receiver. An inner class
constructor does have a receiver, whose type is the same as the containing
outer class. The receiver is distinct from the object being constructed.
In a method of a top-level class, the receiver is named <span style="font-family:monospace">this</span>. In a
constructor of an inner class, the receiver is named <span style="font-family:monospace">Outer.this</span> and the
result is named <span style="font-family:monospace">this</span>.</p>
<!--TOC subsection id="faq-annotation-after-type" What is the meaning of an annotation after a type, such as <span style="font-family:monospace">@NonNull Object @Nullable</span>?-->
<h3 id="faq-annotation-after-type" class="subsection">30.5.2&#XA0;&#XA0;What is the meaning of an annotation after a type, such as <span style="font-family:monospace">@NonNull Object @Nullable</span>?</h3><!--SEC END --><p>In a type such as <span style="font-family:monospace">@NonNull Object @Nullable []</span>, it may appear that the
<span style="font-family:monospace">@Nullable</span> annotation is written <em>after</em> the type <span style="font-family:monospace">Object</span>. In
fact, <span style="font-family:monospace">@Nullable</span> modifies <span style="font-family:monospace">[]</span>. See the next FAQ, about array
annotations (Section&#XA0;<a href="#faq-array-syntax-meaning">30.5.3</a>).</p>
<!--TOC subsection id="faq-array-syntax-meaning" What is the meaning of array annotations such as <span style="font-family:monospace">@NonNull Object @Nullable []</span>?-->
<h3 id="faq-array-syntax-meaning" class="subsection">30.5.3&#XA0;&#XA0;What is the meaning of array annotations such as <span style="font-family:monospace">@NonNull Object @Nullable []</span>?</h3><!--SEC END --><p>You should parse this as:
(<span style="font-weight:bold"><span style="font-family:monospace">@NonNull Object</span></span>) (<span style="font-weight:bold"><span style="font-family:monospace">@Nullable []</span></span>).
Each annotation precedes the component of the type that it qualifies.</p><p>Thus,
<span style="font-family:monospace">@NonNull Object @Nullable []</span> is a possibly-null array of non-null
objects. Note that the first token in the type,
&#X201C;<span style="font-family:monospace">@NonNull</span>&#X201D;, applies to the element
type <span style="font-family:monospace">Object</span>, not to the array type as a whole. The annotation <span style="font-family:monospace">@Nullable</span> applies to the
array (<span style="font-family:monospace">[]</span>).</p><p>Similarly,
<span style="font-family:monospace">@Nullable Object @NonNull []</span> is a non-null array of possibly-null
objects.</p><p>Some older tools interpret a declaration like <span style="font-family:monospace">@NonEmpty String[] var</span> as
&#X201C;non-empty array of strings&#X201D;. This is in conflict with the Java type
annotations specification, which defines it as meaning &#X201C;array of
non-empty strings&#X201D;.
If you use one of these
older tools, you will find this incompatibility confusing.
You will have to live with it until the older
tool is updated to conform to the Java specification, or until you
transition to a newer tool that conforms to the Java specification.</p>
<!--TOC subsection id="faq-varargs-syntax-meaning" What is the meaning of varargs annotations such as <span style="font-family:monospace">@English String @NonEmpty&#XA0;...</span>?-->
<h3 id="faq-varargs-syntax-meaning" class="subsection">30.5.4&#XA0;&#XA0;What is the meaning of varargs annotations such as <span style="font-family:monospace">@English String @NonEmpty&#XA0;...</span>?</h3><!--SEC END --><p>Varargs annotations are treated similarly to array annotations.
(A way to remember this is that
when you write a varargs formal parameter such as
<span style="font-family:monospace">void method(String... x) </span><span style="font-family:monospace">{</span><span style="font-family:monospace">}</span>, the Java compiler generates a
method that takes an array of strings; whenever your source code calls the
method with multiple arguments, the Java compiler packages them up into an
array before calling the method.)</p><p>Either of these annotations</p><pre class="verbatim">  void method(String @NonEmpty [] x) {}
  void method(String @NonEmpty ... x) {}
</pre><p>applies to the array: the method takes a non-empty array of strings, or
the varargs list must not be empty.</p><p>Either of these annotations</p><pre class="verbatim">  void method(@English String [] x) {}
  void method(@English String ... x) {}
</pre><p>.
applies to the element type. The annotation documents that the method takes an array of English strings.</p>
<!--TOC subsection id="faq-type-qualifier-on-class-declaration" What is the meaning of a type qualifier at a class declaration?-->
<h3 id="faq-type-qualifier-on-class-declaration" class="subsection">30.5.5&#XA0;&#XA0;What is the meaning of a type qualifier at a class declaration?</h3><!--SEC END --><p>Writing an annotation on a class declaration makes that annotation implicit
for all uses of the class (see Section&#XA0;<a href="#effective-qualifier">23.3</a>). If you
write <span style="font-family:monospace">class @MyQual MyClass </span><span style="font-family:monospace">{</span><span style="font-family:monospace"> ... </span><span style="font-family:monospace">}</span>, then every unannotated
use of <span style="font-family:monospace">MyClass</span> is <span style="font-family:monospace">@MyQual MyClass</span>. A user is permitted to strengthen
the type by writing a more restrictive annotation on a use of MyClass, such
as <span style="font-family:monospace">@MyMoreRestrictiveQual MyClass</span>.</p>
<!--TOC subsection id="faq-no-annotation-on-types-and-declarations" Why shouldn&#X2019;t a qualifier apply to both types and declarations?-->
<h3 id="faq-no-annotation-on-types-and-declarations" class="subsection">30.5.6&#XA0;&#XA0;Why shouldn&#X2019;t a qualifier apply to both types and declarations?</h3><!--SEC END --><p>It is bad style for an annotation to apply to both types and declarations.
In other words, every annotation should have a <span style="font-family:monospace">@Target</span> meta-annotation,
and the <span style="font-family:monospace">@Target</span> meta-annotation should list either only declaration
locations or only type annotations. (It&#X2019;s OK for an annotation to target
both <span style="font-family:monospace">ElementType.TYPE_PARAMETER</span> and <span style="font-family:monospace">ElementType.TYPE_USE</span>, but no
other declaration location along with <span style="font-family:monospace">ElementType.TYPE_USE</span>.)</p><p>Sometimes, it may seem tempting for an annotation to apply to both type
uses and (say) method declarations. Here is a hypothetical example:</p><blockquote class="quote">
&#X201C;Each <span style="font-family:monospace">Widget</span> type may have a <span style="font-family:monospace">@Version</span> annotation.
I wish to prove that versions of widgets don&#X2019;t get assigned to
incompatible variables, and that older code does not call newer code (to
avoid problems when backporting).<p>A <span style="font-family:monospace">@Version</span> annotation could be written like so:</p><pre class="verbatim">  @Version("2.0") Widget createWidget(String value) { ... }
</pre><p><span style="font-family:monospace">@Version("2.0")</span> on the method could mean that the <span style="font-family:monospace">createWidget</span> method
only appears in the 2.0 version. <span style="font-family:monospace">@Version("2.0")</span> on the return type
could mean that the returned <span style="font-family:monospace">Widget</span> should only be used by code that
uses the 2.0 API of <span style="font-family:monospace">Widget</span>. It should be possible to specify these
independently, such as a 2.0 method that returns a value that allows the
1.0 API method invocations.&#X201D;
</p></blockquote><p>Both of these are type properties and should be specified with type
annotations. No method annotation is necessary or desirable. The best way
to require that the receiver has a certain property is to use a type
annotation on the receiver of the method. (Slightly more formally, the
property being checked is compatibility between the annotation on the type
of the formal parameter receiver and the annotation on the type of the
actual receiver.) If you do not know what &#X201C;receiver&#X201D; means, see the next
question.</p><p>Another example of a type-and-declaration annotation that represents poor
design is JCIP&#X2019;s <span style="font-family:monospace">@GuardedBy</span> annotation&#XA0;[<a href="#Goetz2006">GPB+06</a>]. As discussed
in Section&#XA0;<a href="#lock-jcip-annotations">6.6.1</a>, it means two different things when
applied to a field or a method. To reduce confusion and increase
expressiveness, the Lock Checker (see Chapter&#XA0;<a href="#lock-checker">6</a>) uses the
<span style="font-family:monospace">@Holding</span> annotation for one of these meanings, rather than overloading
<span style="font-family:monospace">@GuardedBy</span> with two distinct meanings.</p>
<!--TOC subsection id="faq-annotate-fully-qualified-name" How do I annotate a fully-qualified type name?-->
<h3 id="faq-annotate-fully-qualified-name" class="subsection">30.5.7&#XA0;&#XA0;How do I annotate a fully-qualified type name?</h3><!--SEC END --><p>If you write a fully-qualified type name in your program, then the Java
language requires you to write a type annotation on the simple name part,
such as
</p><pre class="verbatim">  entity.hibernate. @Nullable User x;
</pre><p>If you try to write the type annotation before the entire fully-qualified
name, such as
</p><pre class="verbatim">  @Nullable entity.hibernate.User x;  // illegal Java syntax
</pre><p>then you will get an error like one of the following:
</p><pre class="verbatim">error: scoping construct for static nested type cannot be annotated
error: scoping construct cannot be annotated with type-use annotation
</pre>
<!--TOC section id="faq-semantics-section" Semantics of type annotations-->
<h2 id="faq-semantics-section" class="section">30.6&#XA0;&#XA0;Semantics of type annotations</h2><!--SEC END -->
<!--TOC subsection id="faq-list-map-nonnull-typeargs" Why are the type parameters to <span style="font-family:monospace">List</span> and <span style="font-family:monospace">Map</span> annotated as <span style="font-family:monospace">@NonNull</span>?-->
<h3 id="faq-list-map-nonnull-typeargs" class="subsection">30.6.1&#XA0;&#XA0;Why are the type parameters to <span style="font-family:monospace">List</span> and <span style="font-family:monospace">Map</span> annotated as <span style="font-family:monospace">@NonNull</span>?</h3><!--SEC END --><p>The annotation on <span style="font-family:monospace">java.util.Collection</span> only allows non-null elements:</p><pre class="verbatim">  public interface Collection&lt;E extends @NonNull Object&gt; {
    ...
  }
</pre><p>Thus, you will get a type error if you write code like
<span style="font-family:monospace">Collection&lt;@Nullable Object&gt;</span>.
A nullable
type parameter is also forbidden for certain other collections, including
<span style="font-family:monospace">AbstractCollection</span>, <span style="font-family:monospace">List</span>, <span style="font-family:monospace">Map</span>, and <span style="font-family:monospace">Queue</span>.</p><p>The <span style="font-family:monospace">extends @NonNull Object</span> bound is a direct consequence of the design
of the collections classes; it merely formalizes the Javadoc specification.
The Javadoc for <span style="font-family:monospace">Collection</span> states:</p><blockquote class="quote">
Some list implementations have restrictions on the elements that they may
contain. For example, some implementations prohibit null elements, &#X2026;</blockquote><p>Here are some consequences of the requirement to detect all nullness errors
at compile time. If even one subclass of a given collection class may
prohibit null, then the collection class and all its subclasses must
prohibit null. Conversely, if a collection class is specified to accept
null, then all its subclasses must honor that specification.</p><p>The Checker Framework&#X2019;s annotations make apparent a flaw in the JDK
design, and helps you to avoid problems that might be caused by that flaw.</p>
<!--TOC paragraph id="faq-list-map-nonnull-typeargs-junification-from-type-theory" Justification from type theory-->
<h5 id="faq-list-map-nonnull-typeargs-junification-from-type-theory" class="paragraph">Justification from type theory</h5><!--SEC END --><p>
Suppose <span style="font-family:monospace">B</span> is a subtype of <span style="font-family:monospace">A</span>.
Then an overriding method in <span style="font-family:monospace">B</span> must have a stronger (or equal) signature
than the overridden method in&#XA0;<span style="font-family:monospace">A</span>. In a stronger signature, the formal
parameter types may be supertypes, and the return type may be a subtype.
Here are examples:</p><pre class="verbatim">  class A           {  @NonNull Object Number m1( @NonNull Object arg) { ... } }
  class B extends A { @Nullable Object Number m1( @NonNull Object arg) { ... } } // error!
  class C extends A {  @NonNull Object Number m1(@Nullable Object arg) { ... } } // OK
  class D           { @Nullable Object Number m2(@Nullable Object arg) { ... } }
  class E extends D {  @NonNull Object Number m2(@Nullable Object arg) { ... } } // OK
  class F extends D { @Nullable Object Number m2( @NonNull Object arg) { ... } } // error!
</pre><p>According to these rules, since some subclasses of <span style="font-family:monospace">Collection</span> do not
permit nulls, then <span style="font-family:monospace">Collection</span> cannot either:</p><pre class="verbatim">  // does not permit null elements
  class PriorityQueue&lt;E&gt; implements Collection&lt;E&gt; {
    boolean add(E);
    ...
  }
  // must not permit null elements, or PriorityQueue would not be a subtype of Collection
  interface Collection&lt;E&gt; {
    boolean add(E);
    ...
  }
</pre>
<!--TOC paragraph id="faq-list-map-nonnull-typeargs-justification-from-behavior" Justification from checker behavior-->
<h5 id="faq-list-map-nonnull-typeargs-justification-from-behavior" class="paragraph">Justification from checker behavior</h5><!--SEC END --><p>Suppose that you changed the bound in the <span style="font-family:monospace">Collection</span> declaration to
<span style="font-family:monospace">extends @Nullable Object</span>. Then, the checker would issue no warning for
this method:</p><pre class="verbatim">  static void addNull(Collection l) {
    l.add(null);
  }
</pre><p>However, calling this method <em>can</em> result in a null pointer exception,
for instance caused by the following code:</p><pre class="verbatim">  addNull(new PriorityQueue());
</pre><p>Therefore, the bound must remain as <span style="font-family:monospace">extends @NonNull Object</span>.</p><p>By contrast, this code is OK because <span style="font-family:monospace">ArrayList</span> is documented to support
null elements:</p><pre class="verbatim">  static void addNull(ArrayList l) {
    l.add(null);
  }
</pre><p>Therefore, the upper bound in <span style="font-family:monospace">ArrayList</span> is <span style="font-family:monospace">extends @Nullable Object</span>.
Any subclass of <span style="font-family:monospace">ArrayList</span> must also support null elements.</p>
<!--TOC paragraph id="faq-list-map-nonnull-typeargs-suppressing-warnings" Suppressing warnings-->
<h5 id="faq-list-map-nonnull-typeargs-suppressing-warnings" class="paragraph">Suppressing warnings</h5><!--SEC END --><p>Suppose your program has a list variable, and you know that any list referenced
by that variable will definitely support null elements. Then, you can suppress the
warning:</p><pre class="verbatim">  @SuppressWarnings("nullness:generic.argument") // any list passed to this
  method will support null elements
  static void addNull(List l) {
    l.add(null);
  }
</pre><p>You need to use <span style="font-family:monospace">@SuppressWarnings("nullness:generic.argument")</span>
whenever you use a collection that may contain <span style="font-family:monospace">null</span> elements in
contradiction to its documentation. Fortunately, such uses are relatively
rare.</p><p>For more details on suppressing nullness warnings, see
Section&#XA0;<a href="#suppressing-warnings-nullness">3.4</a>.</p>
<!--TOC subsection id="faq-typestate" How can I handle typestate, or phases of my program with different data properties?-->
<h3 id="faq-typestate" class="subsection">30.6.2&#XA0;&#XA0;How can I handle typestate, or phases of my program with different data properties?</h3><!--SEC END --><p>Sometimes, your program works in phases that have different behavior. For
example, you might have a field that starts out null and becomes non-null
at some point during execution, such as after a method is called. You can
express this property as follows:</p><ol class="enumerate" type=1><li class="li-enumerate">
Annotate the field type as <a href="api/org/checkerframework/checker/nullness/qual/MonotonicNonNull.html"><span style="font-family:monospace">@MonotonicNonNull</span></a>.
</li><li class="li-enumerate">Annotate the method that sets the field as <a href="api/org/checkerframework/checker/nullness/qual/EnsuresNonNull.html"><span style="font-family:monospace">@EnsuresNonNull</span></a><span style="font-family:monospace">("</span><em><span style="font-family:monospace">myFieldName</span></em><span style="font-family:monospace">")</span>.
(If method <span style="font-family:monospace">m1</span> calls method <span style="font-family:monospace">m2</span>, which actually sets the field, then
you would probably write this annotation on both <span style="font-family:monospace">m1</span> and <span style="font-family:monospace">m2</span>.)
</li><li class="li-enumerate">Annotate any method that depends on the field being non-null as
<a href="api/org/checkerframework/checker/nullness/qual/RequiresNonNull.html"><span style="font-family:monospace">@RequiresNonNull</span></a><span style="font-family:monospace">("</span><em><span style="font-family:monospace">myFieldName</span></em><span style="font-family:monospace">")</span>.
The type-checker will verify that such a method is only called when the
field isn&#X2019;t null &#X2014; that is, the method is only called after the setting
method.
</li></ol><p>You can also use a typestate checker (see
Chapter&#XA0;<a href="#typestate-checker">21.1</a>), but they have not been as extensively
tested.</p>
<!--TOC subsection id="faq-implicit-bounds" Why are explicit and implicit bounds defaulted differently?-->
<h3 id="faq-implicit-bounds" class="subsection">30.6.3&#XA0;&#XA0;Why are explicit and implicit bounds defaulted differently?</h3><!--SEC END --><p>The following two bits of code have the same semantics under Java, but are
treated differently by the Checker Framework&#X2019;s CLIMB-to-top defaulting
rules (Section&#XA0;<a href="#climb-to-top">23.3.2</a>):</p><pre class="verbatim">class MyClass&lt;T&gt; { ... }
class MyClass&lt;T extends Object&gt; { ... }
</pre><p>The difference is the annotation on the upper bound of the type argument
<span style="font-family:monospace">T</span>. They are treated in the following.</p><pre class="verbatim">class MyClass&lt;T&gt;  ==  class MyClass&lt;T extends @TOPTYPEANNO Object&gt; { ... }
class MyClass&lt;T extends Object&gt;  ==  class MyClass&lt;T extends @DEFAULTANNO Object&gt;
</pre><p><span style="font-family:monospace">@TOPTYPEANNO</span> is the top annotation in the type qualifier hierarchy. For
example, for the nullness type system, the top type annotation is
<span style="font-family:monospace">@Nullable</span>; as shown in Figure&#XA0;<a href="#fig-nullness-hierarchy">3.1</a>.
<span style="font-family:monospace">@DEFAULTANNO</span> is the default annotation for the type system. For
example, for the nullness type system, the default type annotation is
<span style="font-family:monospace">@NonNull</span>.</p><p>In some type systems, the top qualifier and the default are the same. For
such type systems, the two code snippets shown above are treated the same.
An example is the regular expression type system; see
Figure&#XA0;<a href="#fig-regex-hierarchy">9.1</a>.</p><p>The CLIMB-to-top rule reduces the code edits required to annotate an
existing program, and it treats types written in the program consistently.</p><p>When a user writes no upper bound, as in
<span style="font-family:monospace">class C&lt;T&gt; </span><span style="font-family:monospace">{</span><span style="font-family:monospace"> ... </span><span style="font-family:monospace">}</span>,
then Java permits the class to be instantiated with any type parameter.
The Checker Framework behaves exactly the same, no matter what the default
is for a particular type system &#X2013; and no matter whether the user has
changed the default locally.</p><p>When a user writes an upper bound, as in
<span style="font-family:monospace">class C&lt;T extends OtherClass&gt; </span><span style="font-family:monospace">{</span><span style="font-family:monospace"> ... </span><span style="font-family:monospace">}</span>,
then the Checker Framework treats this occurrence of <span style="font-family:monospace">OtherClass</span> exactly
like any other occurrence, and applies the usual defaulting rules. Use of
<span style="font-family:monospace">Object</span> is treated consistently with all other types in this location and
all other occurrences of <span style="font-family:monospace">Object</span> in the program.</p><p>It is uncommon for a user to write <span style="font-family:monospace">Object</span> as an upper bound with no type
qualifier:
<span style="font-family:monospace">class C&lt;T extends Object&gt; </span><span style="font-family:monospace">{</span><span style="font-family:monospace"> ... </span><span style="font-family:monospace">}</span>.
It is better style to write no upper bound or to write an explicit type
annotation on <span style="font-family:monospace">Object</span>.</p>
<!--TOC section id="faq-create-a-checker-section" Creating a new checker-->
<h2 id="faq-create-a-checker-section" class="section">30.7&#XA0;&#XA0;Creating a new checker</h2><!--SEC END -->
<!--TOC subsection id="faq-create-a-checker" How do I create a new checker?-->
<h3 id="faq-create-a-checker" class="subsection">30.7.1&#XA0;&#XA0;How do I create a new checker?</h3><!--SEC END --><p>In addition to using the checkers that are distributed with the Checker
Framework, you can write your own checker to check specific properties that
you care about. Thus, you can find and prevent the bugs that are most
important to you.</p><p>Chapter&#XA0;<a href="#writing-a-checker">28</a> gives
complete details regarding how to write a checker. It also suggests places
to look for more help, such as the <a href="api/">Checker Framework
API documentation (Javadoc)</a> and the source code of the distributed
checkers.</p><p>To whet your interest and demonstrate how easy it is to get started, here
is an example of a complete, useful type-checker.</p><pre class="verbatim">  @SubtypeOf(Unqualified.class)
  @Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})
  public @interface Encrypted { }
</pre><p>Section&#XA0;<a href="#subtyping-example">20.2</a> explains this checker and tells
you how to run it.</p>
<!--TOC subsection id="faq-declarative-syntax-for-type-rules" Why is there no declarative syntax for writing type rules?-->
<h3 id="faq-declarative-syntax-for-type-rules" class="subsection">30.7.2&#XA0;&#XA0;Why is there no declarative syntax for writing type rules?</h3><!--SEC END --><p>A type system implementer can declaratively specify the type qualifier
hierarchy (Section&#XA0;<a href="#declarative-hierarchy">28.3.2</a>) and the type introduction rules
(Section&#XA0;<a href="#declarative-type-introduction">28.5.1</a>). However, the Checker
Framework uses a procedural syntax for specifying type-checking
rules (Section&#XA0;<a href="#extending-visitor">28.4</a>).
A declarative syntax might be more concise, more readable, and more
verifiable than a procedural syntax.</p><p>We have not found the procedural syntax to be the most important impediment
to writing a checker.</p><p>Previous attempts to devise a declarative syntax
for realistic type systems have failed; see a technical
paper&#XA0;[<a href="#PapiACPE2008">PAC+08</a>] for a discussion. When an
adequate syntax exists, then the Checker Framework can be extended to
support it.</p>
<!--TOC section id="faq-other-tools-section" Relationship to other tools-->
<h2 id="faq-other-tools-section" class="section">30.8&#XA0;&#XA0;Relationship to other tools</h2><!--SEC END -->
<!--TOC subsection id="faq-type-checking-vs-bug-detectors" Why not just use a bug detector (like FindBugs)?-->
<h3 id="faq-type-checking-vs-bug-detectors" class="subsection">30.8.1&#XA0;&#XA0;Why not just use a bug detector (like FindBugs)?</h3><!--SEC END --><p>Pluggable type-checking finds more bugs than a bug detector does, for any
given variety of bug.</p><p>A bug detector like <a href="http://findbugs.sourceforge.net/">FindBugs</a>&#XA0;[<a href="#HovemeyerP2004">HP04</a>, <a href="#HovemeyerSP2005">HSP05</a>],
<a href="http://jlint.sourceforge.net/">Jlint</a>&#XA0;[<a href="#Artho2001">Art01</a>], or
<a href="http://pmd.sourceforge.net/">PMD</a>&#XA0;[<a href="#Copeland2005">Cop05</a>] aims to find <em>some</em>
of the most obvious bugs in your program. It uses a lightweight analysis,
then uses heuristics to discard some of its warnings. Thus, even if the tool
prints no warnings, your code might still have errors &#X2014; maybe the
analysis was too weak to find them, or the tool&#X2019;s heuristics classified the
warnings as likely false positives and discarded them.</p><p>A type-checker aims to find <em>all</em> the bugs (of certain varieties).
It requires you to write type qualifiers in your program, or to use a tool
that infers types. Thus, it requires more work from the programmer, and in
return it gives stronger guarantees.</p><p>Each tool is useful in different circumstances, depending on how important
your code is and your desired level of confidence in your code. For more
details on the comparison, see Section&#XA0;<a href="#other-tools">31.5</a>. For a case study
that compared the nullness analysis of FindBugs, Jlint, PMD, and the
Checker Framework, see section 6 of the paper
<a href="http://homes.cs.washington.edu/~mernst/pubs/pluggable-checkers-issta2008.pdf">&#X201C;Practical pluggable types for Java&#X201D;</a>&#XA0;[<a href="#PapiACPE2008">PAC+08</a>].</p>
<!--TOC subsection id="faq-eclipse" How does the Checker Framework compare with Eclipse&#X2019;s null analysis?-->
<h3 id="faq-eclipse" class="subsection">30.8.2&#XA0;&#XA0;How does the Checker Framework compare with Eclipse&#X2019;s null analysis?</h3><!--SEC END --><p>Eclipse comes with a
<a href="http://help.eclipse.org/luna/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Ftasks%2Ftask-using_null_annotations.htm">null analysis</a> that
can detect potential null pointer errors in your code. Eclipse&#X2019;s built-in
analysis differs from the Checker Framework in several respects.</p><p>The Checker Framework&#X2019;s Nullness Checker
(see&#XA0;Chapter&#XA0;<a href="#nullness-checker">3</a>) is more precise: it does a deeper
semantic analysis, so it issues fewer false positives than Eclipse. For
example, the Nullness Checker handles initialization and map key checking,
it supports method pre- and post-conditions, and it includes a powerful
dataflow analysis.</p><p>Eclipse assumes that all code is multi-threaded, which cripples its local
type inference. By contrast, the Checker Framework allows the user to
specify whether code will be run concurrently or not via the
<span style="font-family:monospace">-AconcurrentSemantics</span> command-line option (see
Section&#XA0;<a href="#faq-concurrency">30.4.4</a>).</p><p>The Checker Framework is easier to run in integration scripts or in
environments where not all developers are using Eclipse.
</p><p>Eclipse handles only nullness properties and is not extensible, whereas the
Checker Framework comes with over 20 type-checkers (for a list,
see&#XA0;Chapter&#XA0;<a href="#introduction">1</a>) and is extensible to more properties.</p><p>There are also some benefits to Eclipse&#X2019;s Null Analysis.
It is faster than the Checker Framework, in part because it is less featureful.
It is built into Eclipse, so you do not have to download and install a
separate Eclipse plugin as you do for the Checker Framework (see
Section&#XA0;<a href="#eclipse-plugin">29.7.2</a>).
Its IDE integration is tighter and slicker.</p><p>(If you know of other differences, please let us know at
checker-framework-dev@googlegroups.com so we can update the manual.)</p>
<!--TOC subsection id="faq-jml" How does pluggable type-checking compare with JML?-->
<h3 id="faq-jml" class="subsection">30.8.3&#XA0;&#XA0;How does pluggable type-checking compare with JML?</h3><!--SEC END --><p><a href="http://www.cs.ucf.edu/~leavens/JML/">JML</a>, the Java Modeling
Language&#XA0;[<a href="#LeavensBR2006%3AJML">LBR06</a>], is a language for writing formal
specifications.</p><p><span style="font-weight:bold">JML aims to be more expressive than pluggable type-checking.</span>
A programmer can write a JML specification that
describes arbitrary facts about program behavior. Then, the programmer can
use formal reasoning or a theorem-proving tool to verify that the code
meets the specification. Run-time checking is also possible.
By contrast, pluggable type-checking can express a more limited set of
properties about your program. Pluggable type-checking annotations are
more concise and easier to understand.</p><p><span style="font-weight:bold">JML is not as practical as pluggable type-checking.</span>
The JML toolset is less mature. For instance, if your code uses
generics or other features of Java 5, then you cannot use JML.
However, JML has a run-time checker, which the Checker Framework currently
lacks.</p>
<!--TOC subsection id="faq-checker-framework-part-of-java" Is the Checker Framework an official part of Java?-->
<h3 id="faq-checker-framework-part-of-java" class="subsection">30.8.4&#XA0;&#XA0;Is the Checker Framework an official part of Java?</h3><!--SEC END --><p>The Checker Framework is not an official part of Java.
The Checker Framework relies on
type annotations, which are part of Java 8. See the
<a href="http://types.cs.washington.edu/jsr308/current/jsr308-faq.html#pluggable-type-checking-in-java">Type
Annotations (JSR 308) FAQ</a> for more details.</p>
<!--TOC subsection id="faq-jsr-305" What is the relationship between the Checker Framework and JSR 305?-->
<h3 id="faq-jsr-305" class="subsection">30.8.5&#XA0;&#XA0;What is the relationship between the Checker Framework and JSR 305?</h3><!--SEC END --><p>JSR 305 aimed to define official Java names for some annotations, such as
<span style="font-family:monospace">@NonNull</span> and <span style="font-family:monospace">@Nullable</span>. However, it did not aim to precisely define
the semantics of those annotations nor to provide a reference
implementation of an annotation processor that validated their use;
as a result, JSR 305 was of limited utility as a specification.
JSR 305 has been abandoned; there has been
no activity by its expert group since
2009.</p><p>By contrast, the Checker Framework precisely defines the meaning of a set
of annotations and provides powerful type-checkers that validate them.
However, the Checker Framework is not an official part of the Java
language; it chooses one set of names, but another tool might choose other
names.</p><p>In the future, the Java Community Process might revitalize JSR 305 or
create a replacement JSR to standardize the names and
meanings of specific annotations, after there is more experience with their
use in practice.</p><p>The Checker Framework defines annotations <span style="font-family:monospace">@NonNull</span> and <span style="font-family:monospace">@Nullable</span> that
are compatible with annotations defined by JSR 305, FindBugs, IntelliJ, and
other tools; see Section&#XA0;<a href="#nullness-related-work">3.7</a>.</p>
<!--TOC subsection id="faq-jsr-308" What is the relationship between the Checker Framework and JSR 308?-->
<h3 id="faq-jsr-308" class="subsection">30.8.6&#XA0;&#XA0;What is the relationship between the Checker Framework and JSR 308?</h3><!--SEC END --><p>JSR 308, also known as the Type Annotations specification, dictates the
syntax of type annotations in Java SE 8: how they are expressed in the
Java language.</p><p>JSR 308 does not define any type annotations such as <span style="font-family:monospace">@NonNull</span>, and it does
not specify the semantics of any annotations. Those tasks are left to
third-party tools. The Checker Framework is one such tool.</p><p>The Checker Framework makes use of Java SE 8&#X2019;s type annotation syntax, but
the Checker Framework can
be used with previous versions of the Java language via the
annotations-in-comments feature (Section&#XA0;<a href="#annotations-in-comments">25.2.1</a>).</p><hr>
<!--TOC chapter id="troubleshooting" Troubleshooting and getting help-->
<h1 id="troubleshooting" class="chapter">Chapter&#XA0;31&#XA0;&#XA0;Troubleshooting and getting help</h1><!--SEC END --><p>
The manual might already answer your question, so first please look for
your answer in the manual,
including this chapter and the FAQ (Chapter&#XA0;<a href="#faq">30</a>).
If not, you can use the mailing list,
<span style="font-family:monospace">checker-framework-discuss@googlegroups.com</span>, to ask other users for
help. For archives and to subscribe, see <a href="https://groups.google.com/forum/#!forum/checker-framework-discuss"><span style="font-family:monospace">https://groups.google.com/forum/#!forum/checker-framework-discuss</span></a>.
To report bugs, please see Section&#XA0;<a href="#reporting-bugs">31.2</a>.
If you want to help out, you can give feedback (including on the
documentation), choose a bug and fix it, or select a
project from the ideas list at
<a href="https://github.com/typetools/checker-framework/wiki/Ideas"><span style="font-family:monospace">https://github.com/typetools/checker-framework/wiki/Ideas</span></a>.
</p>
<!--TOC section id="common-problems" Common problems and solutions-->
<h2 id="common-problems" class="section">31.1&#XA0;&#XA0;Common problems and solutions</h2><!--SEC END --><ul class="itemize"><li class="li-itemize">
To verify that you are using the compiler you think you are, you can add
<span style="font-family:monospace">-version</span> to the command line. For instance, instead of running
<span style="font-family:monospace">javac -g MyFile.java</span>, you can run <span style="font-family:monospace">javac </span><span style="font-family:monospace"><U>-version</U></span><span style="font-family:monospace"> -g
MyFile.java</span>. Then, javac will print out its version number in addition
to doing its normal processing.</li></ul>
<!--TOC subsection id="common-problems-running" Unable to run the checker, or checker crashes-->
<h3 id="common-problems-running" class="subsection">31.1.1&#XA0;&#XA0;Unable to run the checker, or checker crashes</h3><!--SEC END --><p>If you are unable to run the checker, or if the checker or the compiler
terminates with an error, then the problem may be a problem with your environment.
(If the checker or the compiler crashes, that is a bug in the Checker
Framework; please report it. See Section&#XA0;<a href="#reporting-bugs">31.2</a>.)
This section describes some possible problems and solutions.</p><ul class="itemize"><li class="li-itemize">
If you get the error<pre class="verbatim">com.sun.tools.javac.code.Symbol$CompletionFailure: class file for com.sun.source.tree.Tree not found
</pre><p>then you are using the source installation and file <span style="font-family:monospace">tools.jar</span> is not
on your classpath. See the installation instructions
(Section&#XA0;<a href="#installation">1.3</a>).</p></li><li class="li-itemize">If you get an error such as<pre class="verbatim">package org.checkerframework.checker.nullness.qual does not exist
</pre><p>
despite no apparent use of <span style="font-family:monospace">import org.checkerframework.checker.nullness.qual.*;</span> in
the source code, then perhaps
<span style="font-family:monospace">jsr308_imports</span> is set as a Java system property, a shell
environment variable, or a command-line option.
You should solve this by unsetting the variable/option, which it is deprecated.
</p><p>If the error is</p><pre class="verbatim">package org.checkerframework.checker.nullness.qual does not exist
</pre><p>
(note the extra apostrophe!), then you have probably misused quoting when
supplying the (deprecated) <span style="font-family:monospace">jsr308_imports</span> environment variable.
</p></li><li class="li-itemize">If you get an error like one of the following,<pre class="verbatim">...\build.xml:59: Error running ${env.CHECKERFRAMEWORK}\checker\bin\javac.bat compiler
</pre><pre class="verbatim">.../bin/javac: Command not found
</pre><p>then the problem may be that you have not set the <span style="font-family:monospace">CHECKERFRAMEWORK</span> environment
variable, as described in Section&#XA0;<a href="#javac-installation">29.1</a>. Or, maybe
you made it a user variable instead of a system variable.</p></li><li class="li-itemize">If you get one of these errors:<pre>
The hierarchy of the type <em>ClassName</em> is inconsistent

The type com.sun.source.util.AbstractTypeProcessor cannot be resolved.
  It is indirectly referenced from required .class files
</pre><p>
then you are likely <span style="font-weight:bold">not</span> using the Checker Framework compiler. Use
either <span style="font-family:monospace">$CHECKERFRAMEWORK/checker/bin/javac</span> or one of the alternatives
described in Section&#XA0;<a href="#javac-installation">29.1</a>.
</p></li><li class="li-itemize">If you get the error<pre class="verbatim">  java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy
</pre><p>If you get an error such as</p><pre class="verbatim">  java.lang.NoClassDefFoundError: java/util/Objects
</pre><p>then you are trying to run the compiler using a JDK 6 or earlier JVM.
Install and use a Java 7 or 8 JDK, at least for running the Checker
Framework.</p><p>then an annotation is not present at run time that was present at compile
time. For example, maybe when you compiled the code, the <span style="font-family:monospace">@Nullable</span>
annotation was available, but it was not available at run time.
You can use JDK 8 at run time, or compile
with a Java 6 or 7 compiler that will ignore the annotations in comments.</p></li><li class="li-itemize">A &#X201C;class file for &#X2026; not found&#X201D; error, especially for an inner class
in the JDK, is probably due to a JDK version mismatch. To solve the
problem, you need to perform compilation with a different Java version or
different version of the JDK.<p>In general, Java issues a &#X201C;class file for &#X2026; not found&#X201D; error when
your classpath contains code that was compiled
with some library, but your classpath does not contain that library itself.</p><p>For example, suppose that when you run the compiler, you are using JDK 8,
but some library on your classpath was compiled against JDK 6 or 7, and the
compiled library refers to a class that only appears in JDK 6 or 7. (If only
one version of Java existed, or the Checker Framework didn&#X2019;t try to support
multiple different versions of Java, this would not be a problem.)</p><p>Examples of classes that were in JDK 7 but were removed in JDK 8 include:</p><pre class="verbatim">  class file for java.util.TimeZone$DisplayNames not found
</pre><p>Examples of classes that were in JDK 6 but were removed in JDK 7 include:</p><pre class="verbatim">  class file for java.io.File$LazyInitialization not found
  class file for java.util.Hashtable$EmptyIterator not found
  java.lang.NoClassDefFoundError: java/util/Hashtable$EmptyEnumerator
</pre><p>Examples of classes that were not in JDK 7 but were introduced in JDK 8 include:</p><pre class="verbatim">  The type java.lang.Class$ReflectionData cannot be resolved
</pre><p>Examples of classes that were not in JDK 6 but were introduced in JDK 7 include:</p><pre class="verbatim">  class file for java.util.Vector$Itr not found
</pre><p>There are even classes that were introduced within a single JDK release.
Classes that appear in JDK 7 release 71 but not in JDK 7 release 45 include:</p><pre class="verbatim">  class file for java.lang.Class$ReflectionData not found
</pre><p>You may be able to solve the problem by running</p><pre class="verbatim">  cd checker
  ant jdk.jar bindist
</pre><p>to re-generate files <span style="font-family:monospace">checker/jdk/jdk{7,8}.jar</span> and <span style="font-family:monospace">checker/bin/jdk{7,8}.jar</span>.</p><p>That usually works, but if not, then you should recompile the Checker
Framework from source rather than using the pre-compiled distribution.</p></li><li class="li-itemize">A <span style="font-family:monospace">NoSuchFieldError</span> such as this:<pre class="verbatim">java.lang.NoSuchFieldError: NATIVE_HEADER_OUTPUT
</pre><p>Field <span style="font-family:monospace">NATIVE_HEADER_OUTPUT</span> was added in JDK 8.
The error message suggests that
you&#X2019;re not executing with the right bootclasspath: some classes were
compiled with the JDK 8 version and expect the field, but you&#X2019;re
executing the compiler on a JDK without the field.</p><p>One possibility is that you are not running the Checker Framework compiler
&#X2014; use <span style="font-family:monospace">javac -version</span> to check this, then use the right one. (Maybe
the Checker Framework javac is at the end rather than the beginning of your
path.)</p><p>If you are using Ant, then one possibility
is that the javac compiler is using the same JDK as Ant is using. You can
correct this by being sure to use <span style="font-family:monospace">fork="yes"</span> (see
Section&#XA0;<a href="#ant-task">29.2</a>) and/or setting the <span style="font-family:monospace">build.compiler</span> property to
<span style="font-family:monospace">extJavac</span>.</p><p>If you are building from source (Section&#XA0;<a href="#build-source">31.3</a>),
you might need to rebuild the Annotation
File Utilities before recompiling or using the Checker Framework.</p></li><li class="li-itemize">If you get an error that contains lines like these:<pre class="verbatim">Caused by: java.util.zip.ZipException: error in opening zip file
    at java.util.zip.ZipFile.open(Native Method)
    at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:131)
</pre><p>then one possibility is that you have installed the Checker Framework in a
directory that contains special characters that Java&#X2019;s ZipFile
implementation cannot handle. For instance, if the directory name contains
&#X201C;<span style="font-family:monospace">+</span>&#X201D;, then Java 1.6 throws a ZipException, and Java 1.7 throws a
FileNotFoundException and prints out the directory name with &#X201C;<span style="font-family:monospace">+</span>&#X201D;
replaced by blanks.</p></li><li class="li-itemize">If you get an error like the following<pre class="verbatim">error: scoping construct for static nested type cannot be annotated
error: scoping construct cannot be annotated with type-use annotation
</pre><p>
then you have probably written something like <span style="font-family:monospace">@Nullable java.util.List</span>.
The correct Java syntax to write an annotation on a fully-qualified type
name is to put the annotation on the simple name part, as in
<span style="font-family:monospace">java.util.@Nullable List</span>. But, it&#X2019;s usually
better to add <span style="font-family:monospace">import java.util.List</span> to your source file, so that you can
just write <span style="font-family:monospace">@Nullable List</span>. Likewise, you must write <span style="font-family:monospace">Outer.@Nullable
StaticNestedClass</span> rather than <span style="font-family:monospace">@Nullable Outer.StaticNestedClass</span>.
</p><p>Java 8 requires that a type qualifier be written directly on the type that
it qualifies, rather than on a scoping mechanism that assists in resolving
the name. Examples of scoping mechanisms are package names and outer
classes of static nested classes.</p><p>The reason for the Java 8 syntax is to avoid syntactic irregularity. When
writing a member nested class (also known as an inner class), it is
possible to write annotations on both the outer and the inner class: <span style="font-family:monospace">@A1
Outer. @A2 Inner</span>. Therefore, when writing a static nested class, the
annotations should go on the same place: <span style="font-family:monospace">Outer. @A3 StaticNested</span> (rather
than <span style="font-family:monospace">@ConfusingAnnotation Outer. Nested</span> where
<span style="font-family:monospace">@ConfusingAnnotation</span> applies to <span style="font-family:monospace">Outer</span> if <span style="font-family:monospace">Nested</span> is a member class
and applies to <span style="font-family:monospace">Nested</span> if <span style="font-family:monospace">Nested</span> is a static class). It&#X2019;s not legal
to write an annotation on the outer class of a static nested class, because
neither annotations nor instantiations of the outer class affect the static
nested class.</p><p>Similar arguments apply when annotating <span style="font-family:monospace">package.Outer.Nested</span>.</p></li></ul>
<!--TOC subsection id="common-problems-typechecking" Unexpected type-checking results-->
<h3 id="common-problems-typechecking" class="subsection">31.1.2&#XA0;&#XA0;Unexpected type-checking results</h3><!--SEC END --><p>This section describes possible problems that can lead the type-checker to
give unexpected results.</p><ul class="itemize"><li class="li-itemize">
If the Checker Framework is unable to verify a property that you know is
true, then it is helpful to formulate an argument about why the property
is true. Recall that the Checker Framework does modular verification,
one procedure at a time; it observes the specifications, but not the
implementations, of other methods.<p>If any aspects of your argument are not expressed as annotations, then
you may need to write more annotations. If any aspects of your argument
are not expressible as annotations, then you may need to extend the
type-checker.</p></li><li class="li-itemize">If a checker seems to be ignoring the annotation on a method, then it is
possible that the checker is reading the method&#X2019;s signature from its
<span style="font-family:monospace">.class</span> file, but the <span style="font-family:monospace">.class</span> file was not created by the JSR
308 compiler. You can check whether the annotations actually appear in the
<span style="font-family:monospace">.class</span> file by using the <span style="font-family:monospace">javap</span> tool.<p>If the annotations do not appear in the <span style="font-family:monospace">.class</span> file, here are two
ways to solve the problem:
</p><ul class="itemize"><li class="li-itemize">
Re-compile the method&#X2019;s class with the Checker Framework compiler. This will
ensure that the type annotations are written to the class file, even if
no type-checking happens during that execution.
</li><li class="li-itemize">Pass the method&#X2019;s file explicitly on the command line when type-checking,
so that the compiler reads its source code instead of its <span style="font-family:monospace">.class</span>
file.
</li></ul></li><li class="li-itemize">If a checker issues a warning about a property that it accepted (or that
was checked) on a previous line, then probably there was a side-effecting
method call in between that could invalidate the property. For example, in
this code:<pre class="verbatim">if (currentOutgoing != null &amp;&amp; !message.isCompleted()) {
    currentOutgoing.continueBuffering(message);
}
</pre><p>the Nullness Checker will issue a warning on the second line:
</p><pre class="verbatim">warning: [dereference.of.nullable] dereference of possibly-null reference currentOutgoing
    currentOutgoing.continueBuffering(message);
    ^
</pre><p>If <span style="font-family:monospace">currentOutgoing</span> is a field rather than a local variable, and
<span style="font-family:monospace">isCompleted()</span> is not a pure method, then a null pointer
dereference can occur at the given location, because <span style="font-family:monospace">isCompleted()</span> might set
the field <span style="font-family:monospace">currentOutgoing</span> to <span style="font-family:monospace">null</span>.</p><p>If you want to communicate that
isCompleted() does not set the field <span style="font-family:monospace">currentOutgoing</span> to <span style="font-family:monospace">null</span>, you can use
<a href="api/org/checkerframework/dataflow/qual/Pure.html"><span style="font-family:monospace">@Pure</span></a>,
<a href="api/org/checkerframework/dataflow/qual/SideEffectFree.html"><span style="font-family:monospace">@SideEffectFree</span></a>,
or <a href="api/org/checkerframework/checker/nullness/qual/EnsuresNonNull.html"><span style="font-family:monospace">@EnsuresNonNull</span></a> on the
declaration of <span style="font-family:monospace">isCompleted()</span>; see Sections&#XA0;<a href="#type-refinement-purity">23.4.5</a>
and&#XA0;<a href="#nullness-method-annotations">3.2.2</a>.</p></li><li class="li-itemize">If a checker issues a type-checking error for a call that the library&#X2019;s
documentation states is correct, then maybe that library method has not yet
been annotated, so default annotations are being used.<p>To solve the problem, add the missing annotations to the library (see
Chapter&#XA0;<a href="#annotating-libraries">27</a>). Depending on the checker, the
annotations might be expressed in the form of stub files (which appear
together with the checker&#X2019;s source code, such as in file
<span style="font-family:monospace">checker/src/org/checkerframework/checker/interning/jdk.astub</span> for the
Interning Checker) or in the form of annotated libraries (which appear
under <span style="font-family:monospace">checker/jdk/</span>, such as at <span style="font-family:monospace">checker/jdk/nullness/src/</span> for
the Nullness Checker.</p></li><li class="li-itemize">If the compiler reports that it cannot find a method from the JDK or
another external library, then maybe the stub file for that class
is incomplete.<p>To solve the problem, add the missing annotations to the library, as
described in the previous item.</p><p>The error might take one of these forms:</p><pre class="verbatim">method sleep in class Thread cannot be applied to given types
cannot find symbol: constructor StringBuffer(StringBuffer)
</pre></li><li class="li-itemize">If you get an error related to a bounded type parameter and a literal such
as <span style="font-family:monospace">null</span>, the problem may be missing defaulting. Here is an example:<pre class="verbatim">mypackage/MyClass.java:2044: warning: incompatible types in assignment.
      T retval = null;
                 ^
  found   : null
  required: T extends @MyQualifier Object
</pre><p>A value that can be assigned to a variable of type <span style="font-family:monospace">T extends @MyQualifier
Object</span> only if that value is of the bottom type, since the bottom type is
the only one that is a subtype of every subtype of <span style="font-family:monospace">T extends @MyQualifier
Object</span>. The value <span style="font-family:monospace">null</span> satisfies this for the Java type system, and it
must be made to satisfy it for the pluggable type system as well. The
typical way to address this is to write the meta-annotation
<span style="font-family:monospace">@ImplicitFor(literals=</span><span style="font-family:monospace">LiteralKind.NULL</span><span style="font-family:monospace">)</span> on the definition of the
bottom type qualifier.</p></li><li class="li-itemize">An error such as<pre class="verbatim">MyFile.java:123: error: incompatible types in argument.
                        myModel.addElement("Scanning directories...");
                                           ^
  found   : String
  required: ? extends Object
</pre><p>may stem from use of raw types. (&#X201C;<span style="font-family:monospace">String</span>&#X201D; might be a different type
and might have type annotations.) If your declaration was</p><pre class="verbatim">  DefaultListModel myModel;
</pre><p>then it should be
</p><pre class="verbatim">  DefaultListModel&lt;String&gt; myModel;
</pre><p>Running the regular Java compiler with the <span style="font-family:monospace">-Xlint:unchecked</span> command-line
option will help you to find and fix problems such as raw types.</p></li><li class="li-itemize">The error<pre class="verbatim">error: annotation type not applicable to this kind of declaration
    ... List&lt;@NonNull String&gt; ...
</pre><p>indicates that you are using a definition of <span style="font-family:monospace">@NonNull</span> that is a
declaration annotation, which cannot be used in that syntactic location.
For example, many legacy annotations such as those listed in
Figure&#XA0;<a href="#fig-nullness-refactoring">3.2</a> are declaration annotations. You can
fix the problem by instead using a definition of <span style="font-family:monospace">@NonNull</span> that is a type
annotation, such as the Checker Framework&#X2019;s annotations; often this only
requires changing an <span style="font-family:monospace">import</span> statement.
Alternately, if you wish to continue using the legacy annotations in
declaration locations, see Section&#XA0;<a href="#declaration-annotations-for-java7">25.2.5</a>.</p></li><li class="li-itemize">This compile-time error<pre class="verbatim">  unknown enum constant java.lang.annotation.ElementType.TYPE_USE
</pre><p>indicates that you are compiling using a Java 6 or 7 JDK, but your code
references an enum constant that is only defined in the Java 8 JDK. The
problem might be that your code uses a library that references the enum
constant. In particular, the type annotations shipped with the Checker
Framework reference
<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/ElementType.html#TYPE_USE"><span style="font-family:monospace">ElementType.TYPE_USE</span></a>. You can use the Checker
Framework, but still compile and run your code in a Java 6 or 7 JVM, by
following the instructions in Section&#XA0;<a href="#backward-compatibility">25.2</a>.</p><p>If you ignore the error and run your code in a Java 6 or 7 JVM, then you will get a run-time error:</p><pre class="verbatim">  java.lang.ArrayStoreException: sun.reflect.annotation.EnumConstantNotPresentExceptionProxy
</pre></li><li class="li-itemize">If Eclipse gives the warning<pre class="verbatim">The annotation @NonNull is disallowed for this location
</pre><p>then you have the wrong version of the <span style="font-family:monospace">org.eclipse.jdt.annotation</span>
classes. Eclipse includes two incompatible versions of these annotations.
You want the one with a name like
<span style="font-family:monospace">org.eclipse.jdt.annotation_2.0.0.....jar</span>, which you can find in the
<span style="font-family:monospace">plugins</span> subdirectory under the Eclipse installation directory.
Add this .jar file to your build path.</p></li></ul>
<!--TOC subsection id="common-problems-running-javac" Unexpected compilation output when running javac without a pluggable type-checker-->
<h3 id="common-problems-running-javac" class="subsection">31.1.3&#XA0;&#XA0;Unexpected compilation output when running javac without a pluggable type-checker</h3><!--SEC END --><p>On rare occasions, javac may issue an error when compiling against the
Checker Framework&#X2019;s annotated JDK that you do not get when using the
regular JDK. (Recall that the Checker Framework compiler uses the
annotated JDK.) This may occur even when you are <em>not</em> running any
annotation processor. The error is:</p><pre class="verbatim">  unchecked method invocation: method myMethod in class C is applied to given types
</pre><p>The reason for this is that there are some wildcards in the annotated JDK
that have been given an explicit upper bound &#X2014; they have been changed
from, for example, <span style="font-family:monospace">List&lt;?&gt;</span> to <span style="font-family:monospace">List&lt;? extends Object&gt;</span>. The
JDK treats these two types as identical in almost all respects. However,
they have a different representation in bytecode. More importantly,
<span style="font-family:monospace">List&lt;?&gt;</span> is reifiable but <span style="font-family:monospace">List&lt;? extends Object&gt;</span> is not; this
means that the compiler permits uses of the former in some locations where
it issues a warning for the latter. You can suppress the warning.</p>
<!--TOC subsection id="common-problems-running-java" Unable to build the checker, or to run programs-->
<h3 id="common-problems-running-java" class="subsection">31.1.4&#XA0;&#XA0;Unable to build the checker, or to run programs</h3><!--SEC END --><p>An error like this</p><pre class="verbatim">Unsupported major.minor version 52.0
</pre><p>means that you have compiled some files into the Java 8 format (version
52.0), but you are trying to run them with Java 7 or earlier.
Likewise, &#X201C;Unsupported major.minor version 51.0&#X201D;
means that you have compiled some files into the Java 7 format (version
51.0), but you are trying to run them with Java 6 or earlier.
Here are ways to solve the problem:</p><ul class="itemize"><li class="li-itemize">
Use a newer JVM (run <span style="font-family:monospace">java -version</span> to
determine the version you are using)
</li><li class="li-itemize">Use the Checker Framework to type-check your code, then afterward produce a
classfile that targets an earlier JVM by supplying arguments such as
<span style="font-family:monospace">javac -source 7 -target 7 ...</span>.
</li></ul>
<!--TOC subsection id="common-problems-classfile-version" Classfile version warning-->
<h3 id="common-problems-classfile-version" class="subsection">31.1.5&#XA0;&#XA0;Classfile version warning</h3><!--SEC END --><p>The following warning is innocuous and you can ignore it, or you can
suppress it using the <span style="font-family:monospace">-Xlint:-classfile</span> command-line argument to javac:</p><div style="font-size:x-small;">
<pre class="verbatim">warning: [classfile] RuntimeVisibleTypeAnnotations attribute introduced in version 52.0 class files is ignored in version 51.0 class files
</pre></div><p>This warning results when you compile a library using the Checker Framework
compiler, then use a normal Java compiler to compile client code that uses
the library.
The Checker Framework compiler puts Java 8 type annotations even in Java 7
classfiles, for the benefit of modular type-checking. The Checker Framework
compiler reads these annotations in Java 7, and other compilers ignore them
(but some compilers print a warning that they are ignoring them).</p>
<!--TOC section id="reporting-bugs" How to report problems (bug reporting)-->
<h2 id="reporting-bugs" class="section">31.2&#XA0;&#XA0;How to report problems (bug reporting)</h2><!--SEC END --><p>If you have a problem with any checker, or with the Checker Framework,
please file a bug at
<a href="https://github.com/typetools/checker-framework/issues"><span style="font-family:monospace">https://github.com/typetools/checker-framework/issues</span></a>.
(First, check whether there is an existing bug report for that issue.)</p><p>Alternately (especially if your communication is not a bug report), you can
send mail to checker-framework-dev@googlegroups.com.
We welcome suggestions, annotated libraries, bug fixes, new
features, new checker plugins, and other improvements.</p><p>Please ensure that your bug report is clear and that it is complete.
Otherwise, we may be unable to understand it or to reproduce it, either of
which would prevent us from helping you. Your bug report will be most
helpful if you:</p><ul class="itemize"><li class="li-itemize">
Add <span style="font-family:monospace">-version -verbose -AprintErrorStack -AprintAllQualifiers</span>
to the javac options. This causes the compiler to output
debugging information, including its version number.
</li><li class="li-itemize">Indicate exactly what you did. Don&#X2019;t skip any steps, and don&#X2019;t merely
describe your actions in words. Show the exact commands by attaching a
file or using cut-and-paste from your command shell (a screenshot is not
as useful).
</li><li class="li-itemize">Include all files that are necessary to reproduce the problem. This
includes every file that is used by any of the commands you reported, and
possibly other files as well. Please attach the files, rather than
pasting their contents into the body of your bug report or email message,
because some mailers mangle formatting of pasted text. If you
encountered a problem while using tool integration such as the Eclipse
plugin or Maven integration, then try to reproduce the problem from the
command line as well &#X2014; this will indicate whether the problem is with
the checker itself or with the tool integration.
</li><li class="li-itemize">Indicate exactly what the result was by attaching a file or using
cut-and-paste from your command shell (don&#X2019;t merely describe it in
words).
</li><li class="li-itemize">Indicate what you expected the result to be, since a bug is a difference
between desired and actual outcomes. Also, please indicate <span style="font-weight:bold">why</span>
you expected that result &#X2014; explaining your reasoning can help you
understand how your reasoning is different than the checker&#X2019;s and which
one is wrong. Remember that the checker reasons modularly and
intraprocedurally: it examines one method at a time, using only the
method signatures of other methods.
</li><li class="li-itemize">Indicate what you have already done to try to understand the problem.
Did you do any additional experiments? What parts of the manual did
read, and what else did you search for in the manual? This information
will prevent you being given redundant suggestions.
</li></ul><p>A particularly useful format for a test case is as a new file, or a diff to
an existing file, for the existing Checker Framework test suite. For
instance, for the Nullness
Checker, see directory <span style="font-family:monospace">checker-framework/checker/tests/nullness/</span>.
But, please report your bug even if you do not report it in this format.</p>
<!--TOC section id="build-source" Building from source-->
<h2 id="build-source" class="section">31.3&#XA0;&#XA0;Building from source</h2><!--SEC END --><p>The Checker Framework release (Section&#XA0;<a href="#installation">1.3</a>) contains
everything that most users need, both to use the distributed checkers and
to write your own checkers. This section describes how to compile its
binaries from source. You will be using the latest development version of
the Checker Framework, rather than an official release.</p>
<!--TOC subsection id="building-prerequisites" Install prerequisites-->
<h3 id="building-prerequisites" class="subsection">31.3.1&#XA0;&#XA0;Install prerequisites</h3><!--SEC END --><p>You need to install several packages in order to build the Checker
Framework. The following command installs them for Ubuntu 14.04:</p><pre class="verbatim">sudo apt-get install --yes ant dia git hevea junit4 librsvg2-bin make mercurial openjdk-7-jdk unzip
</pre>
<!--TOC subsection id="building-obtain-source" Obtain the source-->
<h3 id="building-obtain-source" class="subsection">31.3.2&#XA0;&#XA0;Obtain the source</h3><!--SEC END --><p>Obtain the latest source code from the version control repository:</p><pre class="verbatim">export JSR308=$HOME/jsr308
mkdir -p $JSR308
cd $JSR308
hg clone https://bitbucket.org/typetools/jsr308-langtools jsr308-langtools
git clone https://github.com/typetools/checker-framework.git checker-framework
git clone https://github.com/typetools/annotation-tools.git annotation-tools
</pre>
<!--TOC subsection id="building-compiler" Build the Type Annotations compiler-->
<h3 id="building-compiler" class="subsection">31.3.3&#XA0;&#XA0;Build the Type Annotations compiler</h3><!--SEC END --><p>The Checker Framework compiler is built upon a compiler called the Type
Annotations compiler. The Type Annotations compiler is a variant of the
OpenJDK javac that supports annotations in comments. The Checker Framework
compiler is a small wrapper around the Type Annotations compiler, which
adds annotated JDKs and the Checker Framework jars to the classpath.</p><ol class="enumerate" type=1><li class="li-enumerate">
Set the <span style="font-family:monospace">JAVA_HOME</span> environment variable to the location of your JDK
7 or 8 installation (not the JRE installation, and not JDK 6 or earlier).
This needs to be an Oracle JDK.
(The <span style="font-family:monospace">JAVA_HOME</span> environment
variable might already be set, because it is needed for Ant to work.)<p>In the bash shell, the following command <em>sometimes</em> works (it might
not because <span style="font-family:monospace">java</span> might be the version in the JDK or in the JRE):
</p><pre class="verbatim">  export JAVA_HOME=${JAVA_HOME:-$(dirname $(dirname $(dirname $(readlink -f $(/usr/bin/which java)))))}
</pre></li><li class="li-enumerate">Compile the Type Annotations tools:<pre class="verbatim">  cd $JSR308/jsr308-langtools/make
  ant clean-and-build-all-tools
</pre></li><li class="li-enumerate">Add the <span style="font-family:monospace">jsr308-langtools/dist/bin</span> directory to the front of your PATH environment variable.
Example command:<pre class="verbatim">  export PATH=$JSR308/jsr308-langtools/dist/bin:${PATH}
</pre></li></ol>
<!--TOC subsection id="afu-building" Build the Annotation File Utilities-->
<h3 id="afu-building" class="subsection">31.3.4&#XA0;&#XA0;Build the Annotation File Utilities</h3><!--SEC END --><p>This is simply done by:</p><pre class="verbatim">  cd $JSR308/annotation-tools
  ant
</pre><p>You do not need to add the Annotation File Utilities to the path, as
the Checker Framework build finds it using relative paths.</p>
<!--TOC subsection id="building" Build the Checker Framework-->
<h3 id="building" class="subsection">31.3.5&#XA0;&#XA0;Build the Checker Framework</h3><!--SEC END --><ol class="enumerate" type=1><li class="li-enumerate">
Run <span style="font-family:monospace">ant</span> to build the Checker Framework:<pre class="verbatim">  cd $JSR308/checker-framework/checker
  ant
</pre></li><li class="li-enumerate">Once it is built, you may wish to put the Checker Framework&#X2019;s <span style="font-family:monospace">javac</span>
even earlier in your <span style="font-family:monospace">PATH</span>:<pre class="verbatim">export PATH=$JSR308/checker-framework/checker/bin:$JSR308/jsr308-langtools/dist/bin:${PATH}
</pre><p>The Checker Framework&#X2019;s <span style="font-family:monospace">javac</span> ensures that all required
libraries are on your classpath and boot classpath, but is otherwise
identical to the Type Annotations compiler.</p><p>Putting the Checker Framework&#X2019;s <span style="font-family:monospace">javac</span> earlier in your <span style="font-family:monospace">PATH</span> will
ensure that the Checker Framework&#X2019;s version is used.</p></li><li class="li-enumerate">If you are developing a checker within the Checker Framework, there is
a developer version of <span style="font-family:monospace">javac</span> in the <span style="font-family:monospace">bin-devel</span> directory. This
version will use compiled classes from <span style="font-family:monospace">dataflow/build</span>,
<span style="font-family:monospace">javacutil/build</span>, <span style="font-family:monospace">stubparser/build</span>, <span style="font-family:monospace">framework/build</span>,
and <span style="font-family:monospace">checker/build</span> in the <span style="font-family:monospace">checker-framework</span> directory instead of
the compiled jar files, and by default will print stack traces for all
errors.<p>To use it, set your <span style="font-family:monospace">PATH</span> to use <span style="font-family:monospace">javac</span> in the <span style="font-family:monospace">bin-devel</span> directory:</p><pre class="verbatim">export PATH=$JSR308/checker-framework/checker/bin-devel:$JSR308/jsr308-langtools/dist/bin:${PATH}
</pre><p>The developer version of <span style="font-family:monospace">javac</span> allows you to not have to rebuild
the jar files after every code change, in turn allowing you to test
your changes faster. Source files can be compiled using command <span style="font-family:monospace">ant
build</span> in the <span style="font-family:monospace">checker</span> directory, or can be automatically compiled by
an IDE such as Eclipse.</p></li><li class="li-enumerate">Test that everything works:<ul class="itemize"><li class="li-itemize">Run <span style="font-family:monospace">ant all-tests</span> in the <span style="font-family:monospace">checker</span> directory:
<pre class="verbatim">  cd $JSR308/checker-framework/checker
  ant all-tests
</pre></li><li class="li-itemize">Run the Nullness Checker examples (see
Section&#XA0;<a href="#nullness-example">3.5</a>).</li></ul></li></ol>
<!--TOC subsection id="building-manual" Build the Checker Framework Manual (this document)-->
<h3 id="building-manual" class="subsection">31.3.6&#XA0;&#XA0;Build the Checker Framework Manual (this document)</h3><!--SEC END --><ol class="enumerate" type=1><li class="li-enumerate">
Install needed packages; see Section&#XA0;<a href="#building-prerequisites">31.3.1</a> for
instructions.
</li><li class="li-enumerate">Run <span style="font-family:monospace">make</span> in the <span style="font-family:monospace">checker/manual</span> directory to build both the PDF and HTML versions of the manual.
</li></ol>
<!--TOC subsection id="building-travis" Enable Travis continuous integration builds-->
<h3 id="building-travis" class="subsection">31.3.7&#XA0;&#XA0;Enable Travis continuous integration builds</h3><!--SEC END --><p>If you have forked any of the projects rather than just creating a clone,
then we recommend that you enable Travis-CI continuous integration builds,
so that you learn quickly of any errors that creep into your fork.</p><p>Run the
<a href="https://docs.travis-ci.com/user/getting-started/#To-get-started-with-Travis-CI%3A">Travis-CI getting started directions</a>,
though note that the <span style="font-family:monospace">.travis.yml</span> files already exist.</p>
<!--TOC section id="publications" Publications-->
<h2 id="publications" class="section">31.4&#XA0;&#XA0;Publications<a id="learning-more"></a></h2><!--SEC END --><p>Here are two technical papers about the Checker Framework itself:</p><ul class="itemize"><li class="li-itemize">
&#X201C;Practical pluggable types for Java&#X201D;&#XA0;[<a href="#PapiACPE2008">PAC+08</a>]
(ISSTA 2008, <a href="http://homes.cs.washington.edu/~mernst/pubs/pluggable-checkers-issta2008.pdf"><span style="font-family:monospace">http://homes.cs.washington.edu/~mernst/pubs/pluggable-checkers-issta2008.pdf</span></a>)
describes the design and implementation of the Checker Framework.
The paper also describes case
studies in which the Nullness, Interning, Javari, and IGJ Checkers found
previously-unknown errors in real software.
The case studies also yielded new insights about type systems.</li><li class="li-itemize">&#X201C;Building and using pluggable
type-checkers&#X201D;&#XA0;[<a href="#DietlDEMS2011">DDE+11</a>]
(ICSE 2011, <a href="http://homes.cs.washington.edu/~mernst/pubs/pluggable-checkers-icse2011.pdf"><span style="font-family:monospace">http://homes.cs.washington.edu/~mernst/pubs/pluggable-checkers-icse2011.pdf</span></a>)
discusses further experience with the Checker Framework, increasing the
number of lines of verified code to 3 million. The case studies are of the
Fake Enum, Signature String, Interning, and Nullness Checkers.
The paper also evaluates the ease
of pluggable type-checking with the Checker Framework: type-checkers
were easy to write, easy for novices to use, and effective in finding
errors.
</li></ul><p>Here are some papers about type systems that were implemented and evaluated
using the Checker Framework:</p><dl class="description"><dt class="dt-description">
<span style="font-weight:bold">Nullness (Chapter&#XA0;</span><a href="#nullness-checker"><span style="font-weight:bold">3</span></a><span style="font-weight:bold">)</span></dt><dd class="dd-description">
See the two papers about the Checker Framework, described above.</dd><dt class="dt-description"><span style="font-weight:bold">Rawness initialization (Section&#XA0;</span><a href="#initialization-rawness-checker"><span style="font-weight:bold">3.8.7</span></a><span style="font-weight:bold">)</span></dt><dd class="dd-description">
&#X201C;Inference of field initialization&#X201D; (ICSE 2011, <a href="http://homes.cs.washington.edu/~mernst/pubs/initialization-icse2011-abstract.html"><span style="font-family:monospace">http://homes.cs.washington.edu/~mernst/pubs/initialization-icse2011-abstract.html</span></a>)
describes inference for the Rawness Initialization Checker.</dd><dt class="dt-description"><span style="font-weight:bold">Interning (Chapter&#XA0;</span><a href="#interning-checker"><span style="font-weight:bold">5</span></a><span style="font-weight:bold">)</span></dt><dd class="dd-description">
See the two papers about the Checker Framework, described above.</dd><dt class="dt-description"><span style="font-weight:bold">Locking (Chapter&#XA0;</span><a href="#lock-checker"><span style="font-weight:bold">6</span></a><span style="font-weight:bold">)</span></dt><dd class="dd-description">
&#X201C;Locking discipline inference and checking&#X201D; (ICSE 2016,
<a href="http://homes.cs.washington.edu/~mernst/pubs/locking-inference-checking-icse2016-abstract.html"><span style="font-family:monospace">http://homes.cs.washington.edu/~mernst/pubs/locking-inference-checking-icse2016-abstract.html</span></a>)
describes the Lock Checker.</dd><dt class="dt-description"><span style="font-weight:bold">Fake enumerations (Chapter&#XA0;</span><a href="#fenum-checker"><span style="font-weight:bold">7</span></a><span style="font-weight:bold">)</span></dt><dd class="dd-description">
See the ICSE 2011 paper about the Checker Framework, described above.</dd><dt class="dt-description"><span style="font-weight:bold">Regular expressions (Chapter&#XA0;</span><a href="#regex-checker"><span style="font-weight:bold">9</span></a><span style="font-weight:bold">)</span></dt><dd class="dd-description">
&#X201C;A type system for regular expressions&#X201D;&#XA0;[<a href="#SpishakDE2012">SDE12</a>] (FTfJP 2012, <a href="http://homes.cs.washington.edu/~mernst/pubs/regex-types-ftfjp2012-abstract.html"><span style="font-family:monospace">http://homes.cs.washington.edu/~mernst/pubs/regex-types-ftfjp2012-abstract.html</span></a>)
describes the Regex Checker.</dd><dt class="dt-description"><span style="font-weight:bold">Format Strings (Chapter&#XA0;</span><a href="#formatter-checker"><span style="font-weight:bold">10</span></a><span style="font-weight:bold">)</span></dt><dd class="dd-description">
&#X201C;A type system for format strings&#X201D;&#XA0;[<a href="#WeitzKSE2014">WKSE14</a>] (ISSTA 2014, <a href="http://homes.cs.washington.edu/~mernst/pubs/format-string-issta2014-abstract.html"><span style="font-family:monospace">http://homes.cs.washington.edu/~mernst/pubs/format-string-issta2014-abstract.html</span></a>)
describes the Format String Checker.</dd><dt class="dt-description"><span style="font-weight:bold">Signature strings (Chapter&#XA0;</span><a href="#signature-checker"><span style="font-weight:bold">13</span></a><span style="font-weight:bold">)</span></dt><dd class="dd-description">
See the ICSE 2011 paper about the Checker Framework, described above.</dd><dt class="dt-description"><span style="font-weight:bold">GUI Effects (Chapter&#XA0;</span><a href="#guieffect-checker"><span style="font-weight:bold">14</span></a><span style="font-weight:bold">)</span></dt><dd class="dd-description">
&#X201C;JavaUI: Effects for controlling UI object access&#X201D;&#XA0;[<a href="#GordonDEG2013">GDEG13</a>] (ECOOP 2013, <a href="http://homes.cs.washington.edu/~mernst/pubs/gui-thread-ecoop2013-abstract.html"><span style="font-family:monospace">http://homes.cs.washington.edu/~mernst/pubs/gui-thread-ecoop2013-abstract.html</span></a>)
describes the GUI Effect Checker.</dd><dt class="dt-description"></dt><dd class="dd-description">&#X201C;Verification games: Making verification fun&#X201D; (FTfJP 2012, <a href="http://homes.cs.washington.edu/~mernst/pubs/verigames-ftfjp2012-abstract.html"><span style="font-family:monospace">http://homes.cs.washington.edu/~mernst/pubs/verigames-ftfjp2012-abstract.html</span></a>)
describes a general inference approach that, at the time, had only been implemented for the Nullness Checker (Section&#XA0;<a href="#nullness-checker">3</a>).</dd><dt class="dt-description"><span style="font-weight:bold">IGJ and OIGJ immutability (Section&#XA0;</span><a href="#igj-checker"><span style="font-weight:bold">21.9</span></a><span style="font-weight:bold">)</span></dt><dd class="dd-description">
&#X201C;Object and reference immutability using Java generics&#X201D;&#XA0;[<a href="#ZibinPAAKE2007">ZPA+07</a>] (ESEC/FSE 2007, <a href="http://homes.cs.washington.edu/~mernst/pubs/immutability-generics-fse2007-abstract.html"><span style="font-family:monospace">http://homes.cs.washington.edu/~mernst/pubs/immutability-generics-fse2007-abstract.html</span></a>)
and
&#X201C;Ownership and immutability in generic Java&#X201D;&#XA0;[<a href="#ZibinPLAE2010">ZPL+10</a>] (OOPSLA 2010, <a href="http://homes.cs.washington.edu/~mernst/pubs/ownership-immutability-oopsla2010-abstract.html"><span style="font-family:monospace">http://homes.cs.washington.edu/~mernst/pubs/ownership-immutability-oopsla2010-abstract.html</span></a>)
describe the IGJ and OIGJ immutability type systems.
For further case studies, also see the ISSTA 2008 paper about the Checker
Framework, described above.</dd><dt class="dt-description"><span style="font-weight:bold">Javari immutability (Section&#XA0;</span><a href="#javari-checker"><span style="font-weight:bold">21.9</span></a><span style="font-weight:bold">)</span></dt><dd class="dd-description">
&#X201C;Javari: Adding reference immutability to Java&#X201D;&#XA0;[<a href="#TschantzE2005">TE05</a>] (OOPSLA 2005, <a href="http://homes.cs.washington.edu/~mernst/pubs/ref-immutability-oopsla2005-abstract.html"><span style="font-family:monospace">http://homes.cs.washington.edu/~mernst/pubs/ref-immutability-oopsla2005-abstract.html</span></a>)
describes the Javari type system.
For inference, see
&#X201C;Inference of reference immutability&#X201D;&#XA0;[<a href="#QuinonezTE2008">QTE08</a>] (ECOOP 2008, <a href="http://homes.cs.washington.edu/~mernst/pubs/infer-refimmutability-ecoop2008-abstract.html"><span style="font-family:monospace">http://homes.cs.washington.edu/~mernst/pubs/infer-refimmutability-ecoop2008-abstract.html</span></a>)
and
&#X201C;Parameter reference immutability: Formal definition, inference tool, and comparison&#X201D;&#XA0;[<a href="#ArtziQKE2009">AQKE09</a>] (J.ASE 2009, <a href="http://homes.cs.washington.edu/~mernst/pubs/mutability-jase2009-abstract.html"><span style="font-family:monospace">http://homes.cs.washington.edu/~mernst/pubs/mutability-jase2009-abstract.html</span></a>).
For further case studies, also see the ISSTA 2008 paper about the Checker
Framework, described above.</dd><dt class="dt-description"><span style="font-weight:bold">Thread locality (Section&#XA0;</span><a href="#loci-thread-locality-checker"><span style="font-weight:bold">21.3</span></a><span style="font-weight:bold">)</span></dt><dd class="dd-description">
&#X201C;Loci: Simple thread-locality for Java&#X201D;&#XA0;[<a href="#WrigstadPMZV2009">WPM+09</a>] (ECOOP 2009,
<a href="http://janvitek.org/pubs/ecoop09.pdf"><span style="font-family:monospace">http://janvitek.org/pubs/ecoop09.pdf</span></a>)</dd><dt class="dt-description"><a href="https://ece.uwaterloo.ca/~wdietl/ownership/"><span style="font-weight:bold">Generic Universe
Types</span></a><span style="font-weight:bold"> (Section&#XA0;</span><a href="#gut-checker"><span style="font-weight:bold">21.5</span></a><span style="font-weight:bold">)</span></dt><dd class="dd-description">
&#X201C;Tunable static inference for Generic Universe Types&#X201D; (ECOOP 2011, <a href="http://homes.cs.washington.edu/~mernst/pubs/tunable-typeinf-ecoop2011-abstract.html"><span style="font-family:monospace">http://homes.cs.washington.edu/~mernst/pubs/tunable-typeinf-ecoop2011-abstract.html</span></a>)
describes inference for the Generic Universe Types type system.<p>Another implementation of Universe Types and <a href="http://www.cs.rpi.edu/~huangw5/cf-inference/">ownership types</a> is described in
&#X201C;Inference and checking of object ownership&#X201D;&#XA0;[<a href="#HuangDME2012">HDME12</a>] (ECOOP 2012, <a href="http://homes.cs.washington.edu/~mernst/pubs/infer-ownership-ecoop2012-abstract.html"><span style="font-family:monospace">http://homes.cs.washington.edu/~mernst/pubs/infer-ownership-ecoop2012-abstract.html</span></a>).</p></dd><dt class="dt-description"><span style="font-weight:bold">Approximate data (Section&#XA0;</span><a href="#enerj-checker"><span style="font-weight:bold">21.6</span></a><span style="font-weight:bold">)</span></dt><dd class="dd-description">
&#X201C;EnerJ: Approximate Data Types for Safe and General Low-Power Computation&#X201D;&#XA0;[<a href="#SampsonDFGCG2011">SDF+11</a>] (PLDI 2011, <a href="http://adriansampson.net/media/papers/enerj-pldi2011.pdf"><span style="font-family:monospace">http://adriansampson.net/media/papers/enerj-pldi2011.pdf</span></a>)</dd><dt class="dt-description"><span style="font-weight:bold">Information flow and tainting (Section&#XA0;</span><a href="#sparta-checker"><span style="font-weight:bold">21.8</span></a><span style="font-weight:bold">)</span></dt><dd class="dd-description">
&#X201C;Collaborative Verification of Information Flow
for a High-Assurance App Store&#X201D;&#XA0;[<a href="#ErnstJMDPRKBBHVW2014">EJM+14</a>] (CCS 2014, <a href="http://homes.cs.washington.edu/~mernst/pubs/infoflow-ccs2014.pdf"><span style="font-family:monospace">http://homes.cs.washington.edu/~mernst/pubs/infoflow-ccs2014.pdf</span></a>) describes the SPARTA information flow type system.</dd><dt class="dt-description"><span style="font-weight:bold">ReIm immutability</span></dt><dd class="dd-description">
&#X201C;ReIm &amp; ReImInfer: Checking and inference of reference immutability and method purity&#X201D;&#XA0;[<a href="#HuangMDE2012">HMDE12</a>] (OOPSLA 2012, <a href="http://homes.cs.washington.edu/~mernst/pubs/infer-refimmutability-oopsla2012-abstract.html"><span style="font-family:monospace">http://homes.cs.washington.edu/~mernst/pubs/infer-refimmutability-oopsla2012-abstract.html</span></a>)
describes the ReIm immutability type system.</dd></dl><p>In addition to these papers that discuss use the Checker Framework
directly, other academic papers use the Checker Framework in their
implementation or evaluation.
Most educational use of the Checker
Framework is never published, and most commercial use of the Checker
Framework is never discussed publicly.</p><p>(If you know of a paper or other use that is not listed here, please inform
the Checker Framework developers so we can add it.)</p>
<!--TOC section id="other-tools" Comparison to other tools-->
<h2 id="other-tools" class="section">31.5&#XA0;&#XA0;Comparison to other tools</h2><!--SEC END --><p>A pluggable type-checker, such as those created by the Checker Framework,
aims to help you prevent or detect all errors of a given variety. An
alternate approach is to use a bug detector such as
<a href="http://findbugs.sourceforge.net/">FindBugs</a>,
<a href="http://jlint.sourceforge.net/">Jlint</a>, or
<a href="http://pmd.sourceforge.net/">PMD</a>.</p><p>A pluggable type-checker
differs from a bug detector in several ways:
</p><ul class="itemize"><li class="li-itemize">
A type-checker aims to find <em>all</em> errors. Thus, it can verify the
<em>absence</em> of errors: if the type-checker says there are no null
pointer errors in your code, then there are none. (This guarantee only
holds for the code it checks, of course; see
Section&#XA0;<a href="#checker-guarantees">2.3</a>.)<p>A bug detector aims to find <em>some</em> of the most obvious errors. Even
if it reports no errors, then there may still be errors in your code.</p><p>Both types of tools may issue false alarms,
also known as false positive warnings;
see Section&#XA0;<a href="#suppressing-warnings">24</a>.</p></li><li class="li-itemize">A type-checker requires you to annotate your code with type qualifiers,
or to run an inference tool that does so for you. A bug detector may not
require annotations. This means that it may be easier to get started
running a bug detector.</li><li class="li-itemize">A type-checker may use a more sophisticated and complete analysis.
A bug detector typically does a more lightweight analysis, coupled with
heuristics to suppress false positives.<p>As one example, a type-checker can take advantage of annotations on
generic type parameters, such as <span style="font-family:monospace">List&lt;@NonNull String&gt;</span>, permitting
it to be much more precise for code that uses generics.</p></li></ul><p>A case study&#XA0;[<a href="#PapiACPE2008">PAC+08</a>, &#XA7;6] compared the Checker Framework&#X2019;s nullness
checker with those of FindBugs, Jlint, and PMD. The case study was on a
well-tested program in daily use. The Checker Framework tool found 8
nullness errors (that is, null pointer dereferences). None of the other
tools found any errors.</p><p>Also see the
<a href="http://types.cs.washington.edu/jsr308/">JSR 308</a>&#XA0;[<a href="#JSR308-2008-09-12">Ern08</a>]
documentation for a detailed discussion of related work.</p>
<!--TOC section id="credits" Credits, changelog, and license-->
<h2 id="credits" class="section">31.6&#XA0;&#XA0;Credits, changelog, and license</h2><!--SEC END --><p>Differences from previous versions of the checkers and framework can be found
in the <span style="font-family:monospace">changelog.txt</span> file. This file is included in the
Checker Framework distribution and is also available on the web at
<a href="http://types.cs.washington.edu/checker-framework/current/changelog.txt"><span style="font-family:monospace">http://types.cs.washington.edu/checker-framework/current/changelog.txt</span></a>.</p><p>Two different licenses apply to different parts of the Checker Framework.
</p><ul class="itemize"><li class="li-itemize">
The Checker Framework itself is licensed under the GNU General Public License
(GPL), version 2. The GPL is the same license that OpenJDK is licensed
under. Just as compiling your code with javac does not infect your code
with the GPL, type-checking your code with the Checker Framework does not
infect your code with the GPL. Running the Checker Framework during
development has no effect on your intellectual property or licensing. If
you want to ship the Checker Framework as part of your product, then your
product must be licensed under the GPL.
</li><li class="li-itemize">The more permissive MIT License applies
to code that you might want to include in your own
program, such as the annotations.
</li></ul><p>
For details, see file <span style="font-family:monospace">LICENSE.txt</span>.</p><p>Developers who have contributed code to the Checker Framework include
Abraham Lin,
Anatoly Kupriyanov,
Asumu Takikawa,
Charlie Garrett,
Colin Gordon,
Dan Brotherston,
Dan Brown,
David Lazar,
David McArthur,
Eric Spishak,
Javier Thaine,
Jeff Luo,
Jonathan Burke,
Kivanc Muslu,
Konstantin Weitz,
Mahmood Ali,
Mark Roberts,
Matt Mullen,
Michael Bayne,
Michael Coblenz,
Michael Ernst,
Michael Sloan,
Paul Vines,
Paulo Barros,
Philip Lai,
Renato Athaydes,
Ren&#XE9; Just,
Ryan Oblak,
Stefan Heule,
Steph Dietzel,
Stuart Pernsteiner,
Suzanne Millstein,
Trask Stalnaker,
Werner Dietl.
In addition, too many users to list have provided valuable feedback, which
has improved the toolset&#X2019;s design and implementation.
Thanks for your help!</p><hr><!--TOC chapter id="sec441" References-->
<h1 id="sec441" class="chapter">References</h1><!--SEC END --><dl class="thebibliography"><dt class="dt-thebibliography">
<a id="ArtziQKE2009">[AQKE09]</a></dt><dd class="dd-thebibliography">
Shay Artzi, Jaime Quinonez, Adam Kie&#X17C;un, and Michael&#XA0;D. Ernst.
Parameter reference immutability: Formal definition, inference tool,
and comparison.
<em>Automated Software Engineering</em>, 16(1):145&#X2013;192, March 2009.</dd><dt class="dt-thebibliography"><a id="Artho2001">[Art01]</a></dt><dd class="dd-thebibliography">
Cyrille Artho.
Finding faults in multi-threaded programs.
Master&#X2019;s thesis, Swiss Federal Institute of Technology, March&#XA0;15,
2001.</dd><dt class="dt-thebibliography"><a id="Copeland2005">[Cop05]</a></dt><dd class="dd-thebibliography">
Tom Copeland.
<em>PMD Applied</em>.
Centennial Books, November 2005.</dd><dt class="dt-thebibliography"><a id="JSR198">[Cro06]</a></dt><dd class="dd-thebibliography">
Jose Cronembold.
JSR 198: A standard extension API for Integrated Development
Environments.
<a href="http://jcp.org/en/jsr/detail?id=198"><span style="font-family:monospace">http://jcp.org/en/jsr/detail?id=198</span></a>, May&#XA0;8, 2006.</dd><dt class="dt-thebibliography"><a id="JSR269">[Dar06]</a></dt><dd class="dd-thebibliography">
Joe Darcy.
JSR 269: Pluggable annotation processing API.
<a href="http://jcp.org/en/jsr/detail?id=269"><span style="font-family:monospace">http://jcp.org/en/jsr/detail?id=269</span></a>, May&#XA0;17, 2006.
Public review version.</dd><dt class="dt-thebibliography"><a id="DietlDEMS2011">[DDE<sup>+</sup>11]</a></dt><dd class="dd-thebibliography">
Werner Dietl, Stephanie Dietzel, Michael&#XA0;D. Ernst, Kivan&#XE7; Mu&#X15F;lu,
and Todd Schiller.
Building and using pluggable type-checkers.
In <em>ICSE&#X2019;11, Proceedings of the 33rd International Conference on
Software Engineering</em>, pages 681&#X2013;690, Waikiki, Hawaii, USA, May&#XA0;25&#X2013;27,
2011.</dd><dt class="dt-thebibliography"><a id="DietlEM2011">[DEM11]</a></dt><dd class="dd-thebibliography">
Werner Dietl, Michael&#XA0;D. Ernst, and Peter M&#XFC;ller.
Tunable static inference for Generic Universe Types.
In <em>ECOOP 2011 &#X2014; Object-Oriented Programming, 25th European
Conference</em>, pages 333&#X2013;357, Lancaster, UK, July&#XA0;27&#X2013;29, 2011.</dd><dt class="dt-thebibliography"><a id="ErnstJMDPRKBBHVW2014">[EJM<sup>+</sup>14]</a></dt><dd class="dd-thebibliography">
Michael&#XA0;D. Ernst, Ren&#XE9; Just, Suzanne Millstein, Werner Dietl, Stuart
Pernsteiner, Franziska Roesner, Karl Koscher, Paulo Barros, Ravi Bhoraskar,
Seungyeop Han, Paul Vines, and Edward&#XA0;X. Wu.
Collaborative verification of information flow for a high-assurance
app store.
In <em>Proceedings of the 21st ACM Conference on Computer and
Communications Security (CCS)</em>, pages 1092&#X2013;1104, Scottsdale, AZ, USA,
November&#XA0;4&#X2013;6, 2014.</dd><dt class="dt-thebibliography"><a id="JSR308-2008-09-12">[Ern08]</a></dt><dd class="dd-thebibliography">
Michael&#XA0;D. Ernst.
Type Annotations specification (JSR 308).
<a href="http://types.cs.washington.edu/jsr308/"><span style="font-family:monospace">http://types.cs.washington.edu/jsr308/</span></a>, September&#XA0;12, 2008.</dd><dt class="dt-thebibliography"><a id="Evans96">[Eva96]</a></dt><dd class="dd-thebibliography">
David Evans.
Static detection of dynamic memory errors.
In <em>PLDI 1996, Proceedings of the SIGPLAN &#X2019;96 Conference on
Programming Language Design and Implementation</em>, pages 44&#X2013;53, Philadelphia,
PA, USA, May&#XA0;21&#X2013;24, 1996.</dd><dt class="dt-thebibliography"><a id="FahndrichL2003">[FL03]</a></dt><dd class="dd-thebibliography">
Manuel F&#XE4;hndrich and K.&#XA0;Rustan&#XA0;M. Leino.
Declaring and checking non-null types in an object-oriented language.
In <em>Object-Oriented Programming Systems, Languages, and
Applications (OOPSLA 2003)</em>, pages 302&#X2013;312, Anaheim, CA, USA, November&#XA0;6&#X2013;8,
2003.</dd><dt class="dt-thebibliography"><a id="FlanaganLLNSS02">[FLL<sup>+</sup>02]</a></dt><dd class="dd-thebibliography">
Cormac Flanagan, K.&#XA0;Rustan&#XA0;M. Leino, Mark Lillibridge, Greg Nelson, James&#XA0;B.
Saxe, and Raymie Stata.
Extended static checking for Java.
In <em>PLDI 2002, Proceedings of the </em><em>ACM</em><em> </em><em>SIGPLAN</em><em> 2002 Conference
on Programming Language Design and Implementation</em>, pages 234&#X2013;245, Berlin,
Germany, June&#XA0;17&#X2013;19, 2002.</dd><dt class="dt-thebibliography"><a id="GordonDEG2013">[GDEG13]</a></dt><dd class="dd-thebibliography">
Colin&#XA0;S. Gordon, Werner Dietl, Michael&#XA0;D. Ernst, and Dan Grossman.
JavaUI: Effects for controlling UI object access.
In <em>ECOOP 2013 &#X2014; Object-Oriented Programming, 27th European
Conference</em>, pages 179&#X2013;204, Montpellier, France, July&#XA0;3&#X2013;5, 2013.</dd><dt class="dt-thebibliography"><a id="Goetz2006:typedef">[Goe06]</a></dt><dd class="dd-thebibliography">
Brian Goetz.
The pseudo-typedef antipattern: Extension is not type definition.
<a href="http://www.ibm.com/developerworks/java/library/j-jtp02216/"><span style="font-family:monospace">http://www.ibm.com/developerworks/java/library/j-jtp02216/</span></a>,
February&#XA0;21, 2006.</dd><dt class="dt-thebibliography"><a id="Goetz2006">[GPB<sup>+</sup>06]</a></dt><dd class="dd-thebibliography">
Brian Goetz, Tim Peierls, Joshua Bloch, Joseph Bowbeer, David Holmes, and Doug
Lea.
<em>Java Concurrency in Practice</em>.
Addison-Wesley, 2006.</dd><dt class="dt-thebibliography"><a id="HuangDME2012">[HDME12]</a></dt><dd class="dd-thebibliography">
Wei Huang, Werner Dietl, Ana Milanova, and Michael&#XA0;D. Ernst.
Inference and checking of object ownership.
In <em>ECOOP 2012 &#X2014; Object-Oriented Programming, 26th European
Conference</em>, pages 181&#X2013;206, Beijing, China, June&#XA0;14&#X2013;16, 2012.</dd><dt class="dt-thebibliography"><a id="HuangMDE2012">[HMDE12]</a></dt><dd class="dd-thebibliography">
Wei Huang, Ana Milanova, Werner Dietl, and Michael&#XA0;D. Ernst.
ReIm &amp; ReImInfer: Checking and inference of reference
immutability and method purity.
In <em>Object-Oriented Programming Systems, Languages, and
Applications (OOPSLA 2012)</em>, pages 879&#X2013;896, Tucson, AZ, USA, October&#XA0;23&#X2013;25,
2012.</dd><dt class="dt-thebibliography"><a id="HovemeyerP2004">[HP04]</a></dt><dd class="dd-thebibliography">
David Hovemeyer and William Pugh.
Finding bugs is easy.
In <em>Companion to Object-Oriented Programming Systems, Languages,
and Applications (OOPSLA 2004)</em>, pages 132&#X2013;136, Vancouver, BC, Canada,
October&#XA0;26&#X2013;28, 2004.</dd><dt class="dt-thebibliography"><a id="HovemeyerSP2005">[HSP05]</a></dt><dd class="dd-thebibliography">
David Hovemeyer, Jaime Spacco, and William Pugh.
Evaluating and tuning a static analysis to find null pointer bugs.
In <em>ACM SIGPLAN/SIGSOFT Workshop on Program Analysis for Software
Tools and Engineering (PASTE 2005)</em>, pages 13&#X2013;19, Lisbon, Portugal,
September&#XA0;5&#X2013;6, 2005.</dd><dt class="dt-thebibliography"><a id="LeavensBR2006:JML">[LBR06]</a></dt><dd class="dd-thebibliography">
Gary&#XA0;T. Leavens, Albert&#XA0;L. Baker, and Clyde Ruby.
Preliminary design of JML: A behavioral interface specification
language for Java.
<em>ACM SIGSOFT Software Engineering Notes</em>, 31(3), March 2006.</dd><dt class="dt-thebibliography"><a id="PapiACPE2008">[PAC<sup>+</sup>08]</a></dt><dd class="dd-thebibliography">
Matthew&#XA0;M. Papi, Mahmood Ali, Telmo&#XA0;Luis Correa&#XA0;Jr., Jeff&#XA0;H. Perkins, and
Michael&#XA0;D. Ernst.
Practical pluggable types for Java.
In <em>ISSTA 2008, Proceedings of the 2008 International Symposium
on Software Testing and Analysis</em>, pages 201&#X2013;212, Seattle, WA, USA,
July&#XA0;22&#X2013;24, 2008.</dd><dt class="dt-thebibliography"><a id="QuinonezTE2008">[QTE08]</a></dt><dd class="dd-thebibliography">
Jaime Quinonez, Matthew&#XA0;S. Tschantz, and Michael&#XA0;D. Ernst.
Inference of reference immutability.
In <em>ECOOP 2008 &#X2014; Object-Oriented Programming, 22nd European
Conference</em>, pages 616&#X2013;641, Paphos, Cyprus, July&#XA0;9&#X2013;11, 2008.</dd><dt class="dt-thebibliography"><a id="SpishakDE2012">[SDE12]</a></dt><dd class="dd-thebibliography">
Eric Spishak, Werner Dietl, and Michael&#XA0;D. Ernst.
A type system for regular expressions.
In <em>FTfJP 2012: 14th Workshop on Formal Techniques for Java-like
Programs</em>, pages 20&#X2013;26, Beijing, China, June&#XA0;12, 2012.</dd><dt class="dt-thebibliography"><a id="SampsonDFGCG2011">[SDF<sup>+</sup>11]</a></dt><dd class="dd-thebibliography">
Adrian Sampson, Werner Dietl, Emily Fortuna, Danushen Gnanapragasam, Luis Ceze,
and Dan Grossman.
EnerJ: Approximate data types for safe and general low-power
computation.
In <em>PLDI 2011, Proceedings of the </em><em>ACM</em><em> </em><em>SIGPLAN</em><em> 2011 Conference
on Programming Language Design and Implementation</em>, pages 164&#X2013;174, San Jose,
CA, USA, June&#XA0;6&#X2013;8, 2011.</dd><dt class="dt-thebibliography"><a id="SummersM2011">[SM11]</a></dt><dd class="dd-thebibliography">
Alexander&#XA0;J. Summers and Peter M&#XFC;ller.
Freedom before commitment: A lightweight type system for object
initialisation.
In <em>Object-Oriented Programming Systems, Languages, and
Applications (OOPSLA 2011)</em>, pages 1013&#X2013;1032, Portland, OR, USA,
October&#XA0;25&#X2013;27, 2011.</dd><dt class="dt-thebibliography"><a id="TschantzE2005">[TE05]</a></dt><dd class="dd-thebibliography">
Matthew&#XA0;S. Tschantz and Michael&#XA0;D. Ernst.
Javari: Adding reference immutability to Java.
In <em>Object-Oriented Programming Systems, Languages, and
Applications (OOPSLA 2005)</em>, pages 211&#X2013;230, San Diego, CA, USA,
October&#XA0;18&#X2013;20, 2005.</dd><dt class="dt-thebibliography"><a id="TangPJ2010">[TPV10]</a></dt><dd class="dd-thebibliography">
Daniel Tang, Ales Plsek, and Jan Vitek.
Static checking of safety critical Java annotations.
In <em>8th International Workshop on Java Technologies for Real-time
and Embedded Systems</em>, pages 148&#X2013;154, Prague, Czech Republic, August&#XA0;19&#X2013;21,
2010.</dd><dt class="dt-thebibliography"><a id="VakilianPEJ2014">[VPEJ14]</a></dt><dd class="dd-thebibliography">
Mohsen Vakilian, Amarin Phaosawasdi, Michael&#XA0;D. Ernst, and Ralph&#XA0;E. Johnson.
Cascade: A universal type qualifier inference tool.
Technical report, University of Illinois at Urbana-Champaign, Urbana,
IL, USA, September 2014.</dd><dt class="dt-thebibliography"><a id="WeitzKSE2014">[WKSE14]</a></dt><dd class="dd-thebibliography">
Konstantin Weitz, Gene Kim, Siwakorn Srisakaokul, and Michael&#XA0;D. Ernst.
A type system for format strings.
In <em>ISSTA 2014, Proceedings of the 2014 International Symposium
on Software Testing and Analysis</em>, pages 127&#X2013;137, San Jose, CA, USA,
July&#XA0;23&#X2013;25, 2014.</dd><dt class="dt-thebibliography"><a id="WrigstadPMZV2009">[WPM<sup>+</sup>09]</a></dt><dd class="dd-thebibliography">
Tobias Wrigstad, Filip Pizlo, Fadi Meawad, Lei Zhao, and Jan Vitek.
Loci: Simple thread-locality for Java.
In <em>ECOOP 2009 &#X2014; Object-Oriented Programming, 23rd European
Conference</em>, pages 445&#X2013;469, Genova, Italy, July&#XA0;8&#X2013;10, 2009.</dd><dt class="dt-thebibliography"><a id="ZibinPAAKE2007">[ZPA<sup>+</sup>07]</a></dt><dd class="dd-thebibliography">
Yoav Zibin, Alex Potanin, Mahmood Ali, Shay Artzi, Adam Kie&#X17C;un, and
Michael&#XA0;D. Ernst.
Object and reference immutability using Java generics.
In <em>ESEC/FSE 2007: Proceedings of the 11th European Software
Engineering Conference and the 15th </em><em>ACM</em><em> </em><em>SIGSOFT</em><em> Symposium on the
Foundations of Software Engineering</em>, pages 75&#X2013;84, Dubrovnik, Croatia,
September&#XA0;5&#X2013;7, 2007.</dd><dt class="dt-thebibliography"><a id="ZibinPLAE2010">[ZPL<sup>+</sup>10]</a></dt><dd class="dd-thebibliography">
Yoav Zibin, Alex Potanin, Paley Li, Mahmood Ali, and Michael&#XA0;D. Ernst.
Ownership and immutability in generic Java.
In <em>Object-Oriented Programming Systems, Languages, and
Applications (OOPSLA 2010)</em>, pages 598&#X2013;617, Revo, NV, USA, October&#XA0;19&#X2013;21,
2010.</dd></dl><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
</body>
</html>
